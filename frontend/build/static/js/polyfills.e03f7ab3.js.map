{"version":3,"sources":["webpack:///static/js/polyfills.e03f7ab3.js","webpack:///webpack/bootstrap e03f7ab37f5049c883bf?4dd6","webpack:///./config/polyfills.js","webpack:////home/vagrant/~/intl/index.js","webpack:////home/vagrant/~/intl/lib/core.js","webpack:////home/vagrant/~/promise/lib/core.js","webpack:////home/vagrant/~/asap/browser-raw.js","webpack:////home/vagrant/~/intl-locales-supported/index.js","webpack:////home/vagrant/~/promise/lib/es6-extensions.js","webpack:////home/vagrant/~/promise/lib/rejection-tracking.js","webpack:////home/vagrant/~/whatwg-fetch/fetch.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","0","global","Promise","enable","window","areIntlLocalesSupported","localesMyAppSupports","Intl","IntlPolyfill","NumberFormat","DateTimeFormat","this","38","__applyLocaleSensitivePrototypes","73","log10Floor","n","Math","log10","floor","x","round","log","LOG10E","Number","Record","obj","k","hop","defineProperty","value","enumerable","writable","configurable","List","arguments","length","arrPush","apply","arrSlice","createRegExpRestore","esc","lm","RegExp","lastMatch","ml","multiline","ret","input","reg","has","cap","i","replace","_i","slice","indexOf","exp","arrJoin","toObject","arg","TypeError","Object","getInternalProperties","__getInternalProperties","secret","objCreate","setDefaultLocale","locale","defaultLocale","toLatinUpperCase","str","ch","charAt","toUpperCase","IsStructurallyValidLanguageTag","expBCP47Syntax","test","expVariantDupes","expSingletonDupes","CanonicalizeLanguageTag","match","parts","toLowerCase","split","max","expExtSequences","sort","source","redundantTags","tags","_max","subtags","extLang","DefaultLocale","IsWellFormedCurrencyCode","currency","String","normalized","expCurrencyCode","CanonicalizeLocaleList","locales","undefined","seen","O","len","Pk","kPresent","kValue","babelHelpers","tag","RangeError","arrIndexOf","BestAvailableLocale","availableLocales","candidate","pos","lastIndexOf","substring","LookupMatcher","requestedLocales","availableLocale","noExtensionsLocale","expUnicodeExSeq","result","extension","extensionIndex","BestFitMatcher","ResolveLocale","options","relevantExtensionKeys","localeData","ReferenceError","matcher","r","foundLocale","extensionSubtags","extensionSubtagsLength","prototype","supportedExtension","key","foundLocaleData","keyLocaleData","supportedExtensionAddition","keyPos","requestedValue","valuePos","_valuePos","optionsValue","privateIndex","preExtension","postExtension","LookupSupportedLocales","subset","subsetArray","BestFitSupportedLocales","SupportedLocales","localeMatcher","P","GetOption","property","type","values","fallback","Boolean","GetNumberOption","minimum","maximum","isNaN","NumberFormatConstructor","InitializeNumberFormat","numberFormat","internal","regexpState","opt","internals","dataLocale","s","cDigits","CurrencyDigits","cd","mnid","mnfdDefault","mnfd","mxfdDefault","mxfd","mnsd","minimumSignificantDigits","mxsd","maximumSignificantDigits","g","dataLocaleData","patterns","stylePatterns","positivePattern","negativePattern","es3","format","GetFormatNumber","currencyMinorUnits","F","FormatNumber","bf","fnBind","FormatNumberToParts","PartitionNumberPattern","part","nums","data","ild","symbols","latn","pattern","beginIndex","endIndex","nextIndex","Error","literal","[[type]]","[[value]]","nan","isFinite","_n2","ToRawPrecision","ToRawFixed","numSys","digits","digit","integer","fraction","decimalSepIndex","groupSepSymbol","group","groups","pgSize","primaryGroupSize","sgSize","secondaryGroupSize","end","idx","start","integerGroup","arrShift","decimalSepSymbol","decimal","_n","infinity","plusSignSymbol","plusSign","minusSignSymbol","minusSign","percentSignSymbol","percentSign","currencies","_literal","_literal2","minPrecision","maxPrecision","e","Array","abs","f","LN10","cut","minInteger","minFraction","maxFraction","pow","toFixed","int","z","a","b","_z","isDateFormatOnly","tmKeys","hasOwnProperty","isTimeFormatOnly","dtKeys","joinDateAndTimeFormats","dateFormatObj","timeFormatObj","o","_","j","computeFinalPatterns","formatObj","pattern12","extendedPattern","$0","expPatternTrimmer","expDTComponentsMeta","era","year","quarter","month","week","day","weekday","hour12","hour","minute","second","timeZoneName","createDateTimeFormat","skeleton","unwantedDTCs","originalPattern","expDTComponents","createDateTimeFormats","formats","availableFormats","timeFormats","dateFormats","computed","timeRelatedFormats","dateRelatedFormats","push","full","long","medium","short","resolveDateString","ca","component","width","gregory","alts","narrow","resolved","DateTimeFormatConstructor","InitializeDateTimeFormat","dateTimeFormat","ToDateTimeOptions","tz","timeZone","prop","dateTimeComponents","bestFormat","ToDateTimeFormats","BasicFormatMatcher","_hr","BestFitFormatMatcher","_prop","hr12","hourNo0","GetFormatDateTime","toString","required","defaults","opt2","create","needDefaults","removalPenalty","additionPenalty","longLessPenalty","longMorePenalty","shortLessPenalty","shortMorePenalty","bestScore","Infinity","score","optionsProp","formatProp","optionsPropIndex","formatPropIndex","delta","min","hour12Penalty","Date","now","FormatDateTime","GetFormatToPartsDateTime","FormatToPartsDateTime","CreateDateTimeParts","nf","useGrouping","nf2","minimumIntegerDigits","tm","ToLocalTime","index","calendars","fv","v","dateWidths","_v","substr","date","calendar","d","[[weekday]]","[[era]]","[[year]]","[[month]]","[[day]]","[[hour]]","[[minute]]","[[second]]","[[inDST]]","addLocaleData","number","nu","typeof","Symbol","iterator","constructor","realDefineProp","sentinel","__defineGetter__","name","desc","get","search","t","proto","props","arrConcat","concat","join","shift","Function","bind","thisObj","fn","args","random","extlang","language","script","region","variant","singleton","privateuse","irregular","regular","grandfathered","langtag","art-lojban","i-ami","i-bnn","i-hak","i-klingon","i-lux","i-navajo","i-pwn","i-tao","i-tay","i-tsu","no-bok","no-nyn","sgn-BE-FR","sgn-BE-NL","sgn-CH-DE","zh-guoyu","zh-hakka","zh-min-nan","zh-xiang","sgn-BR","sgn-CO","sgn-DE","sgn-DK","sgn-ES","sgn-FR","sgn-GB","sgn-GR","sgn-IE","sgn-IT","sgn-JP","sgn-MX","sgn-NI","sgn-NL","sgn-NO","sgn-PT","sgn-SE","sgn-US","sgn-ZA","zh-cmn","zh-cmn-Hans","zh-cmn-Hant","zh-gan","zh-wuu","zh-yue","BU","DD","FX","TP","YD","ZR","heploc","in","iw","ji","jw","mo","ayx","bjd","ccq","cjr","cka","cmk","drh","drw","gav","hrr","ibi","kgh","lcq","mst","myt","sca","tie","tkk","tlw","tnf","ybd","yma","aao","abh","abv","acm","acq","acw","acx","acy","adf","ads","aeb","aec","aed","aen","afb","afg","ajp","apc","apd","arb","arq","ars","ary","arz","ase","asf","asp","asq","asw","auz","avl","ayh","ayl","ayn","ayp","bbz","bfi","bfk","bjn","bog","bqn","bqy","btj","bve","bvl","bvu","bzs","cdo","cds","cjy","cmn","coa","cpx","csc","csd","cse","csf","csg","csl","csn","csq","csr","czh","czo","doq","dse","dsl","dup","ecs","esl","esn","eso","eth","fcs","fse","fsl","fss","gan","gds","gom","gse","gsg","gsm","gss","gus","hab","haf","hak","hds","hji","hks","hos","hps","hsh","hsl","hsn","icl","ils","inl","ins","ise","isg","isr","jak","jax","jcs","jhs","jls","jos","jsl","jus","kgi","knn","kvb","kvk","kvr","kxd","lbs","lce","lcf","liw","lls","lsg","lsl","lso","lsp","lst","lsy","ltg","lvs","lzh","mdl","meo","mfa","mfb","mfs","mnp","mqg","mre","msd","msi","msr","mui","mzc","mzg","mzy","nbs","ncs","nsi","nsl","nsp","nsr","nzs","okl","orn","ors","pel","pga","pks","prl","prz","psc","psd","pse","psg","psl","pso","psp","psr","pys","rms","rsi","rsl","sdl","sfb","sfs","sgg","sgx","shu","slf","sls","sqk","sqs","ssh","ssp","ssr","svk","swc","swh","swl","syy","tmw","tse","tsm","tsq","tss","tsy","tza","ugn","ugy","ukl","uks","urk","uzn","uzs","vgt","vkk","vkt","vsi","vsl","vsv","wuu","xki","xml","xmm","xms","yds","ysl","yue","zib","zlm","zmi","zsl","zsm","getCanonicalLocales","ll","code","BHD","BYR","XOF","BIF","XAF","CLF","CLP","KMF","DJF","XPF","GNF","ISK","IQD","JPY","JOD","KRW","KWD","LYD","OMR","PYG","RWF","TND","UGX","UYI","VUV","VND","[[availableLocales]]","[[relevantExtensionKeys]]","[[localeData]]","formatToParts","arab","arabext","bali","beng","deva","fullwide","gujr","guru","hanidec","khmr","knda","laoo","limb","mlym","mong","mymr","orya","tamldec","telu","thai","tibt","descs","ls","__localeSensitiveProtos","toLocaleString","toLocaleDateString","toLocaleTimeString","119","164","noop","getThen","then","ex","LAST_ERROR","IS_ERROR","tryCallOne","tryCallTwo","_45","_81","_65","_54","doResolve","safeThen","self","onFulfilled","onRejected","resolve","reject","res","handle","Handler","deferred","_10","handleResolved","asap","cb","promise","newValue","finale","_97","done","reason","_61","202","rawAsap","task","queue","requestFlush","flushing","flush","currentIndex","capacity","scan","newLength","makeRequestCallFromMutationObserver","callback","toggle","observer","BrowserMutationObserver","node","document","createTextNode","observe","characterData","makeRequestCallFromTimer","handleTimer","clearTimeout","timeoutHandle","clearInterval","intervalHandle","setTimeout","setInterval","MutationObserver","WebKitMutationObserver","261","isArray","intlConstructors","Collator","filter","intlConstructor","every","supportedLocales","supportedLocalesOf","383","valuePromise","TRUE","FALSE","NULL","UNDEFINED","ZERO","EMPTYSTRING","all","arr","val","remaining","race","forEach","384","disable","enabled","onUnhandled","allRejections","matchWhitelist","rejections","error","whitelist","DEFAULT_WHITELIST","displayId","logged","logError","onHandled","console","warn","_72","timeout","err","errStr","stack","line","list","some","cls","481","normalizeName","normalizeValue","iteratorFor","items","next","support","iterable","Headers","headers","map","append","getOwnPropertyNames","consumed","body","bodyUsed","fileReaderReady","reader","onload","onerror","readBlobAsArrayBuffer","blob","FileReader","readAsArrayBuffer","readBlobAsText","readAsText","Body","_initBody","_bodyInit","_bodyText","Blob","isPrototypeOf","_bodyBlob","formData","FormData","_bodyFormData","searchParams","URLSearchParams","arrayBuffer","ArrayBuffer","set","rejected","text","decode","json","JSON","parse","normalizeMethod","method","upcased","methods","Request","url","credentials","mode","referrer","form","trim","bytes","decodeURIComponent","xhr","head","pairs","getAllResponseHeaders","header","Response","bodyInit","status","ok","statusText","fetch","getAll","thisArg","keys","entries","clone","response","redirectStatuses","redirect","location","init","responseURL","getResponseHeader","request","XMLHttpRequest","responseText","ontimeout","open","withCredentials","responseType","setRequestHeader","send","polyfill"],"mappings":"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AC,IAAA,MACAC,IAAA,MACAC,IAAA,MACAC,IAAA,MACAC,IAAA,MACAC,IAAA,MACAC,IAAA,MACAC,IAAA,MACAC,IAAA,MACAC,IAAA,MACAC,IAAA,MACAC,IAAA,MACAC,IAAA,MACAC,IAAA,MACAC,IAAA,MACAC,IAAA,OAEAva,SACAwa,KAAA,YACAC,KAAA,YACAC,KAAA,YACAC,KAAA,YACAC,KAAA,YACAC,KAAA,YACAC,KAAA,YACAC,KAAA,YACAC,KAAA,YACAC,KAAA,aACAC,KAAA,YACAC,KAAA,YACAC,KAAA,aACAC,KAAA,aACAC,KAAA,YACAC,KAAA,aACAC,KAAA,YACAC,KAAA,YACAC,KAAA,YACAC,KAAA,YACAC,KAAA,YACAC,KAAA,YACAC,KAAA,YACAC,KAAA,YACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,YACAC,KAAA,YACAC,KAAA,YACAC,KAAA,YACAC,KAAA,YACAC,KAAA,YACAC,KAAA,YACAC,KAAA,aACAC,KAAA,aACAC,KAAA,YACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,YACAC,KAAA,YACAC,KAAA,aACAC,KAAA,YACAC,KAAA,aACAC,KAAA,YACAC,KAAA,aACAC,KAAA,YACAC,KAAA,YACAC,KAAA,YACAC,KAAA,YACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,YACAC,KAAA,YACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,YACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,YACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,YACAC,KAAA,aACAC,KAAA,YACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,YACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,YACAC,KAAA,YACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,YACAC,KAAA,aACAC,KAAA,YACAC,KAAA,YACAC,KAAA,aACAC,KAAA,YACAC,KAAA,YACAC,KAAA,YACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,YACAC,KAAA,YACAC,KAAA,YACAljB,KAAA,YACAmjB,KAAA,aACAC,KAAA,YACAC,KAAA,YACAC,KAAA,YACAC,KAAA,aACA7R,KAAA,YACA8R,KAAA,YACAC,KAAA,YACAC,KAAA,aACAC,KAAA,aACAC,KAAA,YACAC,KAAA,aACAC,KAAA,YACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACA1b,KAAA,YACA2b,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,YACAC,KAAA,YACAC,KAAA,YACAC,KAAA,YACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,YACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,YACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,YACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,YACAC,KAAA,YACAC,KAAA,aACAC,KAAA,aACAC,KAAA,YACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,aACAC,KAAA,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","file":"static/js/polyfills.e03f7ab3.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {if (typeof Promise === 'undefined') {\n\t  // Rejection tracking prevents a common issue where React gets into an\n\t  // inconsistent state due to an error, but it gets swallowed by a Promise,\n\t  // and the user has no idea what causes React's erratic future behavior.\n\t  __webpack_require__(384).enable();\n\t  window.Promise = __webpack_require__(383);\n\t}\n\t\n\t__webpack_require__(481);\n\t\n\tconst areIntlLocalesSupported = __webpack_require__(261);\n\tvar localesMyAppSupports = [\n\t  \"nb-NO\"\n\t];\n\tif (!global.Intl) {\n\t  global.Intl = __webpack_require__(38);\n\t}\n\telse {\n\t  // Determine if the built-in `Intl` has the locale data we need.\n\t  if (!areIntlLocalesSupported(localesMyAppSupports)) {\n\t    // `Intl` exists, but it doesn't have the data we need, so load the\n\t    // polyfill and replace the constructors we need with the polyfill's.\n\t    var IntlPolyfill    = __webpack_require__(38);\n\t    Intl.NumberFormat   = IntlPolyfill.NumberFormat;\n\t    Intl.DateTimeFormat = IntlPolyfill.DateTimeFormat;\n\t  }\n\t}\n\t\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n\n/***/ 38:\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {// Expose `IntlPolyfill` as global to add locale data into runtime later on.\n\tglobal.IntlPolyfill = __webpack_require__(73);\n\t\n\t// Require all locale data for `Intl`. This module will be\n\t// ignored when bundling for the browser with Browserify/Webpack.\n\t__webpack_require__(119);\n\t\n\t// hack to export the polyfill as global Intl if needed\n\tif (!global.Intl) {\n\t    global.Intl = global.IntlPolyfill;\n\t    global.IntlPolyfill.__applyLocaleSensitivePrototypes();\n\t}\n\t\n\t// providing an idiomatic api for the nodejs version of this module\n\tmodule.exports = global.IntlPolyfill;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n\n/***/ 73:\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar babelHelpers = {};\n\tbabelHelpers.typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n\t  return typeof obj;\n\t} : function (obj) {\n\t  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n\t};\n\tbabelHelpers;\n\t\n\tvar realDefineProp = function () {\n\t    var sentinel = {};\n\t    try {\n\t        Object.defineProperty(sentinel, 'a', {});\n\t        return 'a' in sentinel;\n\t    } catch (e) {\n\t        return false;\n\t    }\n\t}();\n\t\n\t// Need a workaround for getters in ES3\n\tvar es3 = !realDefineProp && !Object.prototype.__defineGetter__;\n\t\n\t// We use this a lot (and need it for proto-less objects)\n\tvar hop = Object.prototype.hasOwnProperty;\n\t\n\t// Naive defineProperty for compatibility\n\tvar defineProperty = realDefineProp ? Object.defineProperty : function (obj, name, desc) {\n\t    if ('get' in desc && obj.__defineGetter__) obj.__defineGetter__(name, desc.get);else if (!hop.call(obj, name) || 'value' in desc) obj[name] = desc.value;\n\t};\n\t\n\t// Array.prototype.indexOf, as good as we need it to be\n\tvar arrIndexOf = Array.prototype.indexOf || function (search) {\n\t    /*jshint validthis:true */\n\t    var t = this;\n\t    if (!t.length) return -1;\n\t\n\t    for (var i = arguments[1] || 0, max = t.length; i < max; i++) {\n\t        if (t[i] === search) return i;\n\t    }\n\t\n\t    return -1;\n\t};\n\t\n\t// Create an object with the specified prototype (2nd arg required for Record)\n\tvar objCreate = Object.create || function (proto, props) {\n\t    var obj = void 0;\n\t\n\t    function F() {}\n\t    F.prototype = proto;\n\t    obj = new F();\n\t\n\t    for (var k in props) {\n\t        if (hop.call(props, k)) defineProperty(obj, k, props[k]);\n\t    }\n\t\n\t    return obj;\n\t};\n\t\n\t// Snapshot some (hopefully still) native built-ins\n\tvar arrSlice = Array.prototype.slice;\n\tvar arrConcat = Array.prototype.concat;\n\tvar arrPush = Array.prototype.push;\n\tvar arrJoin = Array.prototype.join;\n\tvar arrShift = Array.prototype.shift;\n\t\n\t// Naive Function.prototype.bind for compatibility\n\tvar fnBind = Function.prototype.bind || function (thisObj) {\n\t    var fn = this,\n\t        args = arrSlice.call(arguments, 1);\n\t\n\t    // All our (presently) bound functions have either 1 or 0 arguments. By returning\n\t    // different function signatures, we can pass some tests in ES3 environments\n\t    if (fn.length === 1) {\n\t        return function () {\n\t            return fn.apply(thisObj, arrConcat.call(args, arrSlice.call(arguments)));\n\t        };\n\t    }\n\t    return function () {\n\t        return fn.apply(thisObj, arrConcat.call(args, arrSlice.call(arguments)));\n\t    };\n\t};\n\t\n\t// Object housing internal properties for constructors\n\tvar internals = objCreate(null);\n\t\n\t// Keep internal properties internal\n\tvar secret = Math.random();\n\t\n\t// Helper functions\n\t// ================\n\t\n\t/**\n\t * A function to deal with the inaccuracy of calculating log10 in pre-ES6\n\t * JavaScript environments. Math.log(num) / Math.LN10 was responsible for\n\t * causing issue #62.\n\t */\n\tfunction log10Floor(n) {\n\t    // ES6 provides the more accurate Math.log10\n\t    if (typeof Math.log10 === 'function') return Math.floor(Math.log10(n));\n\t\n\t    var x = Math.round(Math.log(n) * Math.LOG10E);\n\t    return x - (Number('1e' + x) > n);\n\t}\n\t\n\t/**\n\t * A map that doesn't contain Object in its prototype chain\n\t */\n\tfunction Record(obj) {\n\t    // Copy only own properties over unless this object is already a Record instance\n\t    for (var k in obj) {\n\t        if (obj instanceof Record || hop.call(obj, k)) defineProperty(this, k, { value: obj[k], enumerable: true, writable: true, configurable: true });\n\t    }\n\t}\n\tRecord.prototype = objCreate(null);\n\t\n\t/**\n\t * An ordered list\n\t */\n\tfunction List() {\n\t    defineProperty(this, 'length', { writable: true, value: 0 });\n\t\n\t    if (arguments.length) arrPush.apply(this, arrSlice.call(arguments));\n\t}\n\tList.prototype = objCreate(null);\n\t\n\t/**\n\t * Constructs a regular expression to restore tainted RegExp properties\n\t */\n\tfunction createRegExpRestore() {\n\t    var esc = /[.?*+^$[\\]\\\\(){}|-]/g,\n\t        lm = RegExp.lastMatch || '',\n\t        ml = RegExp.multiline ? 'm' : '',\n\t        ret = { input: RegExp.input },\n\t        reg = new List(),\n\t        has = false,\n\t        cap = {};\n\t\n\t    // Create a snapshot of all the 'captured' properties\n\t    for (var i = 1; i <= 9; i++) {\n\t        has = (cap['$' + i] = RegExp['$' + i]) || has;\n\t    } // Now we've snapshotted some properties, escape the lastMatch string\n\t    lm = lm.replace(esc, '\\\\$&');\n\t\n\t    // If any of the captured strings were non-empty, iterate over them all\n\t    if (has) {\n\t        for (var _i = 1; _i <= 9; _i++) {\n\t            var m = cap['$' + _i];\n\t\n\t            // If it's empty, add an empty capturing group\n\t            if (!m) lm = '()' + lm;\n\t\n\t            // Else find the string in lm and escape & wrap it to capture it\n\t            else {\n\t                    m = m.replace(esc, '\\\\$&');\n\t                    lm = lm.replace(m, '(' + m + ')');\n\t                }\n\t\n\t            // Push it to the reg and chop lm to make sure further groups come after\n\t            arrPush.call(reg, lm.slice(0, lm.indexOf('(') + 1));\n\t            lm = lm.slice(lm.indexOf('(') + 1);\n\t        }\n\t    }\n\t\n\t    // Create the regular expression that will reconstruct the RegExp properties\n\t    ret.exp = new RegExp(arrJoin.call(reg, '') + lm, ml);\n\t\n\t    return ret;\n\t}\n\t\n\t/**\n\t * Mimics ES5's abstract ToObject() function\n\t */\n\tfunction toObject(arg) {\n\t    if (arg === null) throw new TypeError('Cannot convert null or undefined to object');\n\t\n\t    return Object(arg);\n\t}\n\t\n\t/**\n\t * Returns \"internal\" properties for an object\n\t */\n\tfunction getInternalProperties(obj) {\n\t    if (hop.call(obj, '__getInternalProperties')) return obj.__getInternalProperties(secret);\n\t\n\t    return objCreate(null);\n\t}\n\t\n\t/**\n\t* Defines regular expressions for various operations related to the BCP 47 syntax,\n\t* as defined at http://tools.ietf.org/html/bcp47#section-2.1\n\t*/\n\t\n\t// extlang       = 3ALPHA              ; selected ISO 639 codes\n\t//                 *2(\"-\" 3ALPHA)      ; permanently reserved\n\tvar extlang = '[a-z]{3}(?:-[a-z]{3}){0,2}';\n\t\n\t// language      = 2*3ALPHA            ; shortest ISO 639 code\n\t//                 [\"-\" extlang]       ; sometimes followed by\n\t//                                     ; extended language subtags\n\t//               / 4ALPHA              ; or reserved for future use\n\t//               / 5*8ALPHA            ; or registered language subtag\n\tvar language = '(?:[a-z]{2,3}(?:-' + extlang + ')?|[a-z]{4}|[a-z]{5,8})';\n\t\n\t// script        = 4ALPHA              ; ISO 15924 code\n\tvar script = '[a-z]{4}';\n\t\n\t// region        = 2ALPHA              ; ISO 3166-1 code\n\t//               / 3DIGIT              ; UN M.49 code\n\tvar region = '(?:[a-z]{2}|\\\\d{3})';\n\t\n\t// variant       = 5*8alphanum         ; registered variants\n\t//               / (DIGIT 3alphanum)\n\tvar variant = '(?:[a-z0-9]{5,8}|\\\\d[a-z0-9]{3})';\n\t\n\t//                                     ; Single alphanumerics\n\t//                                     ; \"x\" reserved for private use\n\t// singleton     = DIGIT               ; 0 - 9\n\t//               / %x41-57             ; A - W\n\t//               / %x59-5A             ; Y - Z\n\t//               / %x61-77             ; a - w\n\t//               / %x79-7A             ; y - z\n\tvar singleton = '[0-9a-wy-z]';\n\t\n\t// extension     = singleton 1*(\"-\" (2*8alphanum))\n\tvar extension = singleton + '(?:-[a-z0-9]{2,8})+';\n\t\n\t// privateuse    = \"x\" 1*(\"-\" (1*8alphanum))\n\tvar privateuse = 'x(?:-[a-z0-9]{1,8})+';\n\t\n\t// irregular     = \"en-GB-oed\"         ; irregular tags do not match\n\t//               / \"i-ami\"             ; the 'langtag' production and\n\t//               / \"i-bnn\"             ; would not otherwise be\n\t//               / \"i-default\"         ; considered 'well-formed'\n\t//               / \"i-enochian\"        ; These tags are all valid,\n\t//               / \"i-hak\"             ; but most are deprecated\n\t//               / \"i-klingon\"         ; in favor of more modern\n\t//               / \"i-lux\"             ; subtags or subtag\n\t//               / \"i-mingo\"           ; combination\n\t//               / \"i-navajo\"\n\t//               / \"i-pwn\"\n\t//               / \"i-tao\"\n\t//               / \"i-tay\"\n\t//               / \"i-tsu\"\n\t//               / \"sgn-BE-FR\"\n\t//               / \"sgn-BE-NL\"\n\t//               / \"sgn-CH-DE\"\n\tvar irregular = '(?:en-GB-oed' + '|i-(?:ami|bnn|default|enochian|hak|klingon|lux|mingo|navajo|pwn|tao|tay|tsu)' + '|sgn-(?:BE-FR|BE-NL|CH-DE))';\n\t\n\t// regular       = \"art-lojban\"        ; these tags match the 'langtag'\n\t//               / \"cel-gaulish\"       ; production, but their subtags\n\t//               / \"no-bok\"            ; are not extended language\n\t//               / \"no-nyn\"            ; or variant subtags: their meaning\n\t//               / \"zh-guoyu\"          ; is defined by their registration\n\t//               / \"zh-hakka\"          ; and all of these are deprecated\n\t//               / \"zh-min\"            ; in favor of a more modern\n\t//               / \"zh-min-nan\"        ; subtag or sequence of subtags\n\t//               / \"zh-xiang\"\n\tvar regular = '(?:art-lojban|cel-gaulish|no-bok|no-nyn' + '|zh-(?:guoyu|hakka|min|min-nan|xiang))';\n\t\n\t// grandfathered = irregular           ; non-redundant tags registered\n\t//               / regular             ; during the RFC 3066 era\n\tvar grandfathered = '(?:' + irregular + '|' + regular + ')';\n\t\n\t// langtag       = language\n\t//                 [\"-\" script]\n\t//                 [\"-\" region]\n\t//                 *(\"-\" variant)\n\t//                 *(\"-\" extension)\n\t//                 [\"-\" privateuse]\n\tvar langtag = language + '(?:-' + script + ')?(?:-' + region + ')?(?:-' + variant + ')*(?:-' + extension + ')*(?:-' + privateuse + ')?';\n\t\n\t// Language-Tag  = langtag             ; normal language tags\n\t//               / privateuse          ; private use tag\n\t//               / grandfathered       ; grandfathered tags\n\tvar expBCP47Syntax = RegExp('^(?:' + langtag + '|' + privateuse + '|' + grandfathered + ')$', 'i');\n\t\n\t// Match duplicate variants in a language tag\n\tvar expVariantDupes = RegExp('^(?!x).*?-(' + variant + ')-(?:\\\\w{4,8}-(?!x-))*\\\\1\\\\b', 'i');\n\t\n\t// Match duplicate singletons in a language tag (except in private use)\n\tvar expSingletonDupes = RegExp('^(?!x).*?-(' + singleton + ')-(?:\\\\w+-(?!x-))*\\\\1\\\\b', 'i');\n\t\n\t// Match all extension sequences\n\tvar expExtSequences = RegExp('-' + extension, 'ig');\n\t\n\t// Default locale is the first-added locale data for us\n\tvar defaultLocale = void 0;\n\tfunction setDefaultLocale(locale) {\n\t    defaultLocale = locale;\n\t}\n\t\n\t// IANA Subtag Registry redundant tag and subtag maps\n\tvar redundantTags = {\n\t    tags: {\n\t        \"art-lojban\": \"jbo\",\n\t        \"i-ami\": \"ami\",\n\t        \"i-bnn\": \"bnn\",\n\t        \"i-hak\": \"hak\",\n\t        \"i-klingon\": \"tlh\",\n\t        \"i-lux\": \"lb\",\n\t        \"i-navajo\": \"nv\",\n\t        \"i-pwn\": \"pwn\",\n\t        \"i-tao\": \"tao\",\n\t        \"i-tay\": \"tay\",\n\t        \"i-tsu\": \"tsu\",\n\t        \"no-bok\": \"nb\",\n\t        \"no-nyn\": \"nn\",\n\t        \"sgn-BE-FR\": \"sfb\",\n\t        \"sgn-BE-NL\": \"vgt\",\n\t        \"sgn-CH-DE\": \"sgg\",\n\t        \"zh-guoyu\": \"cmn\",\n\t        \"zh-hakka\": \"hak\",\n\t        \"zh-min-nan\": \"nan\",\n\t        \"zh-xiang\": \"hsn\",\n\t        \"sgn-BR\": \"bzs\",\n\t        \"sgn-CO\": \"csn\",\n\t        \"sgn-DE\": \"gsg\",\n\t        \"sgn-DK\": \"dsl\",\n\t        \"sgn-ES\": \"ssp\",\n\t        \"sgn-FR\": \"fsl\",\n\t        \"sgn-GB\": \"bfi\",\n\t        \"sgn-GR\": \"gss\",\n\t        \"sgn-IE\": \"isg\",\n\t        \"sgn-IT\": \"ise\",\n\t        \"sgn-JP\": \"jsl\",\n\t        \"sgn-MX\": \"mfs\",\n\t        \"sgn-NI\": \"ncs\",\n\t        \"sgn-NL\": \"dse\",\n\t        \"sgn-NO\": \"nsl\",\n\t        \"sgn-PT\": \"psr\",\n\t        \"sgn-SE\": \"swl\",\n\t        \"sgn-US\": \"ase\",\n\t        \"sgn-ZA\": \"sfs\",\n\t        \"zh-cmn\": \"cmn\",\n\t        \"zh-cmn-Hans\": \"cmn-Hans\",\n\t        \"zh-cmn-Hant\": \"cmn-Hant\",\n\t        \"zh-gan\": \"gan\",\n\t        \"zh-wuu\": \"wuu\",\n\t        \"zh-yue\": \"yue\"\n\t    },\n\t    subtags: {\n\t        BU: \"MM\",\n\t        DD: \"DE\",\n\t        FX: \"FR\",\n\t        TP: \"TL\",\n\t        YD: \"YE\",\n\t        ZR: \"CD\",\n\t        heploc: \"alalc97\",\n\t        'in': \"id\",\n\t        iw: \"he\",\n\t        ji: \"yi\",\n\t        jw: \"jv\",\n\t        mo: \"ro\",\n\t        ayx: \"nun\",\n\t        bjd: \"drl\",\n\t        ccq: \"rki\",\n\t        cjr: \"mom\",\n\t        cka: \"cmr\",\n\t        cmk: \"xch\",\n\t        drh: \"khk\",\n\t        drw: \"prs\",\n\t        gav: \"dev\",\n\t        hrr: \"jal\",\n\t        ibi: \"opa\",\n\t        kgh: \"kml\",\n\t        lcq: \"ppr\",\n\t        mst: \"mry\",\n\t        myt: \"mry\",\n\t        sca: \"hle\",\n\t        tie: \"ras\",\n\t        tkk: \"twm\",\n\t        tlw: \"weo\",\n\t        tnf: \"prs\",\n\t        ybd: \"rki\",\n\t        yma: \"lrr\"\n\t    },\n\t    extLang: {\n\t        aao: [\"aao\", \"ar\"],\n\t        abh: [\"abh\", \"ar\"],\n\t        abv: [\"abv\", \"ar\"],\n\t        acm: [\"acm\", \"ar\"],\n\t        acq: [\"acq\", \"ar\"],\n\t        acw: [\"acw\", \"ar\"],\n\t        acx: [\"acx\", \"ar\"],\n\t        acy: [\"acy\", \"ar\"],\n\t        adf: [\"adf\", \"ar\"],\n\t        ads: [\"ads\", \"sgn\"],\n\t        aeb: [\"aeb\", \"ar\"],\n\t        aec: [\"aec\", \"ar\"],\n\t        aed: [\"aed\", \"sgn\"],\n\t        aen: [\"aen\", \"sgn\"],\n\t        afb: [\"afb\", \"ar\"],\n\t        afg: [\"afg\", \"sgn\"],\n\t        ajp: [\"ajp\", \"ar\"],\n\t        apc: [\"apc\", \"ar\"],\n\t        apd: [\"apd\", \"ar\"],\n\t        arb: [\"arb\", \"ar\"],\n\t        arq: [\"arq\", \"ar\"],\n\t        ars: [\"ars\", \"ar\"],\n\t        ary: [\"ary\", \"ar\"],\n\t        arz: [\"arz\", \"ar\"],\n\t        ase: [\"ase\", \"sgn\"],\n\t        asf: [\"asf\", \"sgn\"],\n\t        asp: [\"asp\", \"sgn\"],\n\t        asq: [\"asq\", \"sgn\"],\n\t        asw: [\"asw\", \"sgn\"],\n\t        auz: [\"auz\", \"ar\"],\n\t        avl: [\"avl\", \"ar\"],\n\t        ayh: [\"ayh\", \"ar\"],\n\t        ayl: [\"ayl\", \"ar\"],\n\t        ayn: [\"ayn\", \"ar\"],\n\t        ayp: [\"ayp\", \"ar\"],\n\t        bbz: [\"bbz\", \"ar\"],\n\t        bfi: [\"bfi\", \"sgn\"],\n\t        bfk: [\"bfk\", \"sgn\"],\n\t        bjn: [\"bjn\", \"ms\"],\n\t        bog: [\"bog\", \"sgn\"],\n\t        bqn: [\"bqn\", \"sgn\"],\n\t        bqy: [\"bqy\", \"sgn\"],\n\t        btj: [\"btj\", \"ms\"],\n\t        bve: [\"bve\", \"ms\"],\n\t        bvl: [\"bvl\", \"sgn\"],\n\t        bvu: [\"bvu\", \"ms\"],\n\t        bzs: [\"bzs\", \"sgn\"],\n\t        cdo: [\"cdo\", \"zh\"],\n\t        cds: [\"cds\", \"sgn\"],\n\t        cjy: [\"cjy\", \"zh\"],\n\t        cmn: [\"cmn\", \"zh\"],\n\t        coa: [\"coa\", \"ms\"],\n\t        cpx: [\"cpx\", \"zh\"],\n\t        csc: [\"csc\", \"sgn\"],\n\t        csd: [\"csd\", \"sgn\"],\n\t        cse: [\"cse\", \"sgn\"],\n\t        csf: [\"csf\", \"sgn\"],\n\t        csg: [\"csg\", \"sgn\"],\n\t        csl: [\"csl\", \"sgn\"],\n\t        csn: [\"csn\", \"sgn\"],\n\t        csq: [\"csq\", \"sgn\"],\n\t        csr: [\"csr\", \"sgn\"],\n\t        czh: [\"czh\", \"zh\"],\n\t        czo: [\"czo\", \"zh\"],\n\t        doq: [\"doq\", \"sgn\"],\n\t        dse: [\"dse\", \"sgn\"],\n\t        dsl: [\"dsl\", \"sgn\"],\n\t        dup: [\"dup\", \"ms\"],\n\t        ecs: [\"ecs\", \"sgn\"],\n\t        esl: [\"esl\", \"sgn\"],\n\t        esn: [\"esn\", \"sgn\"],\n\t        eso: [\"eso\", \"sgn\"],\n\t        eth: [\"eth\", \"sgn\"],\n\t        fcs: [\"fcs\", \"sgn\"],\n\t        fse: [\"fse\", \"sgn\"],\n\t        fsl: [\"fsl\", \"sgn\"],\n\t        fss: [\"fss\", \"sgn\"],\n\t        gan: [\"gan\", \"zh\"],\n\t        gds: [\"gds\", \"sgn\"],\n\t        gom: [\"gom\", \"kok\"],\n\t        gse: [\"gse\", \"sgn\"],\n\t        gsg: [\"gsg\", \"sgn\"],\n\t        gsm: [\"gsm\", \"sgn\"],\n\t        gss: [\"gss\", \"sgn\"],\n\t        gus: [\"gus\", \"sgn\"],\n\t        hab: [\"hab\", \"sgn\"],\n\t        haf: [\"haf\", \"sgn\"],\n\t        hak: [\"hak\", \"zh\"],\n\t        hds: [\"hds\", \"sgn\"],\n\t        hji: [\"hji\", \"ms\"],\n\t        hks: [\"hks\", \"sgn\"],\n\t        hos: [\"hos\", \"sgn\"],\n\t        hps: [\"hps\", \"sgn\"],\n\t        hsh: [\"hsh\", \"sgn\"],\n\t        hsl: [\"hsl\", \"sgn\"],\n\t        hsn: [\"hsn\", \"zh\"],\n\t        icl: [\"icl\", \"sgn\"],\n\t        ils: [\"ils\", \"sgn\"],\n\t        inl: [\"inl\", \"sgn\"],\n\t        ins: [\"ins\", \"sgn\"],\n\t        ise: [\"ise\", \"sgn\"],\n\t        isg: [\"isg\", \"sgn\"],\n\t        isr: [\"isr\", \"sgn\"],\n\t        jak: [\"jak\", \"ms\"],\n\t        jax: [\"jax\", \"ms\"],\n\t        jcs: [\"jcs\", \"sgn\"],\n\t        jhs: [\"jhs\", \"sgn\"],\n\t        jls: [\"jls\", \"sgn\"],\n\t        jos: [\"jos\", \"sgn\"],\n\t        jsl: [\"jsl\", \"sgn\"],\n\t        jus: [\"jus\", \"sgn\"],\n\t        kgi: [\"kgi\", \"sgn\"],\n\t        knn: [\"knn\", \"kok\"],\n\t        kvb: [\"kvb\", \"ms\"],\n\t        kvk: [\"kvk\", \"sgn\"],\n\t        kvr: [\"kvr\", \"ms\"],\n\t        kxd: [\"kxd\", \"ms\"],\n\t        lbs: [\"lbs\", \"sgn\"],\n\t        lce: [\"lce\", \"ms\"],\n\t        lcf: [\"lcf\", \"ms\"],\n\t        liw: [\"liw\", \"ms\"],\n\t        lls: [\"lls\", \"sgn\"],\n\t        lsg: [\"lsg\", \"sgn\"],\n\t        lsl: [\"lsl\", \"sgn\"],\n\t        lso: [\"lso\", \"sgn\"],\n\t        lsp: [\"lsp\", \"sgn\"],\n\t        lst: [\"lst\", \"sgn\"],\n\t        lsy: [\"lsy\", \"sgn\"],\n\t        ltg: [\"ltg\", \"lv\"],\n\t        lvs: [\"lvs\", \"lv\"],\n\t        lzh: [\"lzh\", \"zh\"],\n\t        max: [\"max\", \"ms\"],\n\t        mdl: [\"mdl\", \"sgn\"],\n\t        meo: [\"meo\", \"ms\"],\n\t        mfa: [\"mfa\", \"ms\"],\n\t        mfb: [\"mfb\", \"ms\"],\n\t        mfs: [\"mfs\", \"sgn\"],\n\t        min: [\"min\", \"ms\"],\n\t        mnp: [\"mnp\", \"zh\"],\n\t        mqg: [\"mqg\", \"ms\"],\n\t        mre: [\"mre\", \"sgn\"],\n\t        msd: [\"msd\", \"sgn\"],\n\t        msi: [\"msi\", \"ms\"],\n\t        msr: [\"msr\", \"sgn\"],\n\t        mui: [\"mui\", \"ms\"],\n\t        mzc: [\"mzc\", \"sgn\"],\n\t        mzg: [\"mzg\", \"sgn\"],\n\t        mzy: [\"mzy\", \"sgn\"],\n\t        nan: [\"nan\", \"zh\"],\n\t        nbs: [\"nbs\", \"sgn\"],\n\t        ncs: [\"ncs\", \"sgn\"],\n\t        nsi: [\"nsi\", \"sgn\"],\n\t        nsl: [\"nsl\", \"sgn\"],\n\t        nsp: [\"nsp\", \"sgn\"],\n\t        nsr: [\"nsr\", \"sgn\"],\n\t        nzs: [\"nzs\", \"sgn\"],\n\t        okl: [\"okl\", \"sgn\"],\n\t        orn: [\"orn\", \"ms\"],\n\t        ors: [\"ors\", \"ms\"],\n\t        pel: [\"pel\", \"ms\"],\n\t        pga: [\"pga\", \"ar\"],\n\t        pks: [\"pks\", \"sgn\"],\n\t        prl: [\"prl\", \"sgn\"],\n\t        prz: [\"prz\", \"sgn\"],\n\t        psc: [\"psc\", \"sgn\"],\n\t        psd: [\"psd\", \"sgn\"],\n\t        pse: [\"pse\", \"ms\"],\n\t        psg: [\"psg\", \"sgn\"],\n\t        psl: [\"psl\", \"sgn\"],\n\t        pso: [\"pso\", \"sgn\"],\n\t        psp: [\"psp\", \"sgn\"],\n\t        psr: [\"psr\", \"sgn\"],\n\t        pys: [\"pys\", \"sgn\"],\n\t        rms: [\"rms\", \"sgn\"],\n\t        rsi: [\"rsi\", \"sgn\"],\n\t        rsl: [\"rsl\", \"sgn\"],\n\t        sdl: [\"sdl\", \"sgn\"],\n\t        sfb: [\"sfb\", \"sgn\"],\n\t        sfs: [\"sfs\", \"sgn\"],\n\t        sgg: [\"sgg\", \"sgn\"],\n\t        sgx: [\"sgx\", \"sgn\"],\n\t        shu: [\"shu\", \"ar\"],\n\t        slf: [\"slf\", \"sgn\"],\n\t        sls: [\"sls\", \"sgn\"],\n\t        sqk: [\"sqk\", \"sgn\"],\n\t        sqs: [\"sqs\", \"sgn\"],\n\t        ssh: [\"ssh\", \"ar\"],\n\t        ssp: [\"ssp\", \"sgn\"],\n\t        ssr: [\"ssr\", \"sgn\"],\n\t        svk: [\"svk\", \"sgn\"],\n\t        swc: [\"swc\", \"sw\"],\n\t        swh: [\"swh\", \"sw\"],\n\t        swl: [\"swl\", \"sgn\"],\n\t        syy: [\"syy\", \"sgn\"],\n\t        tmw: [\"tmw\", \"ms\"],\n\t        tse: [\"tse\", \"sgn\"],\n\t        tsm: [\"tsm\", \"sgn\"],\n\t        tsq: [\"tsq\", \"sgn\"],\n\t        tss: [\"tss\", \"sgn\"],\n\t        tsy: [\"tsy\", \"sgn\"],\n\t        tza: [\"tza\", \"sgn\"],\n\t        ugn: [\"ugn\", \"sgn\"],\n\t        ugy: [\"ugy\", \"sgn\"],\n\t        ukl: [\"ukl\", \"sgn\"],\n\t        uks: [\"uks\", \"sgn\"],\n\t        urk: [\"urk\", \"ms\"],\n\t        uzn: [\"uzn\", \"uz\"],\n\t        uzs: [\"uzs\", \"uz\"],\n\t        vgt: [\"vgt\", \"sgn\"],\n\t        vkk: [\"vkk\", \"ms\"],\n\t        vkt: [\"vkt\", \"ms\"],\n\t        vsi: [\"vsi\", \"sgn\"],\n\t        vsl: [\"vsl\", \"sgn\"],\n\t        vsv: [\"vsv\", \"sgn\"],\n\t        wuu: [\"wuu\", \"zh\"],\n\t        xki: [\"xki\", \"sgn\"],\n\t        xml: [\"xml\", \"sgn\"],\n\t        xmm: [\"xmm\", \"ms\"],\n\t        xms: [\"xms\", \"sgn\"],\n\t        yds: [\"yds\", \"sgn\"],\n\t        ysl: [\"ysl\", \"sgn\"],\n\t        yue: [\"yue\", \"zh\"],\n\t        zib: [\"zib\", \"sgn\"],\n\t        zlm: [\"zlm\", \"ms\"],\n\t        zmi: [\"zmi\", \"ms\"],\n\t        zsl: [\"zsl\", \"sgn\"],\n\t        zsm: [\"zsm\", \"ms\"]\n\t    }\n\t};\n\t\n\t/**\n\t * Convert only a-z to uppercase as per section 6.1 of the spec\n\t */\n\tfunction toLatinUpperCase(str) {\n\t    var i = str.length;\n\t\n\t    while (i--) {\n\t        var ch = str.charAt(i);\n\t\n\t        if (ch >= \"a\" && ch <= \"z\") str = str.slice(0, i) + ch.toUpperCase() + str.slice(i + 1);\n\t    }\n\t\n\t    return str;\n\t}\n\t\n\t/**\n\t * The IsStructurallyValidLanguageTag abstract operation verifies that the locale\n\t * argument (which must be a String value)\n\t *\n\t * - represents a well-formed BCP 47 language tag as specified in RFC 5646 section\n\t *   2.1, or successor,\n\t * - does not include duplicate variant subtags, and\n\t * - does not include duplicate singleton subtags.\n\t *\n\t * The abstract operation returns true if locale can be generated from the ABNF\n\t * grammar in section 2.1 of the RFC, starting with Language-Tag, and does not\n\t * contain duplicate variant or singleton subtags (other than as a private use\n\t * subtag). It returns false otherwise. Terminal value characters in the grammar are\n\t * interpreted as the Unicode equivalents of the ASCII octet values given.\n\t */\n\tfunction /* 6.2.2 */IsStructurallyValidLanguageTag(locale) {\n\t    // represents a well-formed BCP 47 language tag as specified in RFC 5646\n\t    if (!expBCP47Syntax.test(locale)) return false;\n\t\n\t    // does not include duplicate variant subtags, and\n\t    if (expVariantDupes.test(locale)) return false;\n\t\n\t    // does not include duplicate singleton subtags.\n\t    if (expSingletonDupes.test(locale)) return false;\n\t\n\t    return true;\n\t}\n\t\n\t/**\n\t * The CanonicalizeLanguageTag abstract operation returns the canonical and case-\n\t * regularized form of the locale argument (which must be a String value that is\n\t * a structurally valid BCP 47 language tag as verified by the\n\t * IsStructurallyValidLanguageTag abstract operation). It takes the steps\n\t * specified in RFC 5646 section 4.5, or successor, to bring the language tag\n\t * into canonical form, and to regularize the case of the subtags, but does not\n\t * take the steps to bring a language tag into extlang form and to reorder\n\t * variant subtags.\n\t\n\t * The specifications for extensions to BCP 47 language tags, such as RFC 6067,\n\t * may include canonicalization rules for the extension subtag sequences they\n\t * define that go beyond the canonicalization rules of RFC 5646 section 4.5.\n\t * Implementations are allowed, but not required, to apply these additional rules.\n\t */\n\tfunction /* 6.2.3 */CanonicalizeLanguageTag(locale) {\n\t    var match = void 0,\n\t        parts = void 0;\n\t\n\t    // A language tag is in 'canonical form' when the tag is well-formed\n\t    // according to the rules in Sections 2.1 and 2.2\n\t\n\t    // Section 2.1 says all subtags use lowercase...\n\t    locale = locale.toLowerCase();\n\t\n\t    // ...with 2 exceptions: 'two-letter and four-letter subtags that neither\n\t    // appear at the start of the tag nor occur after singletons.  Such two-letter\n\t    // subtags are all uppercase (as in the tags \"en-CA-x-ca\" or \"sgn-BE-FR\") and\n\t    // four-letter subtags are titlecase (as in the tag \"az-Latn-x-latn\").\n\t    parts = locale.split('-');\n\t    for (var i = 1, max = parts.length; i < max; i++) {\n\t        // Two-letter subtags are all uppercase\n\t        if (parts[i].length === 2) parts[i] = parts[i].toUpperCase();\n\t\n\t        // Four-letter subtags are titlecase\n\t        else if (parts[i].length === 4) parts[i] = parts[i].charAt(0).toUpperCase() + parts[i].slice(1);\n\t\n\t            // Is it a singleton?\n\t            else if (parts[i].length === 1 && parts[i] !== 'x') break;\n\t    }\n\t    locale = arrJoin.call(parts, '-');\n\t\n\t    // The steps laid out in RFC 5646 section 4.5 are as follows:\n\t\n\t    // 1.  Extension sequences are ordered into case-insensitive ASCII order\n\t    //     by singleton subtag.\n\t    if ((match = locale.match(expExtSequences)) && match.length > 1) {\n\t        // The built-in sort() sorts by ASCII order, so use that\n\t        match.sort();\n\t\n\t        // Replace all extensions with the joined, sorted array\n\t        locale = locale.replace(RegExp('(?:' + expExtSequences.source + ')+', 'i'), arrJoin.call(match, ''));\n\t    }\n\t\n\t    // 2.  Redundant or grandfathered tags are replaced by their 'Preferred-\n\t    //     Value', if there is one.\n\t    if (hop.call(redundantTags.tags, locale)) locale = redundantTags.tags[locale];\n\t\n\t    // 3.  Subtags are replaced by their 'Preferred-Value', if there is one.\n\t    //     For extlangs, the original primary language subtag is also\n\t    //     replaced if there is a primary language subtag in the 'Preferred-\n\t    //     Value'.\n\t    parts = locale.split('-');\n\t\n\t    for (var _i = 1, _max = parts.length; _i < _max; _i++) {\n\t        if (hop.call(redundantTags.subtags, parts[_i])) parts[_i] = redundantTags.subtags[parts[_i]];else if (hop.call(redundantTags.extLang, parts[_i])) {\n\t            parts[_i] = redundantTags.extLang[parts[_i]][0];\n\t\n\t            // For extlang tags, the prefix needs to be removed if it is redundant\n\t            if (_i === 1 && redundantTags.extLang[parts[1]][1] === parts[0]) {\n\t                parts = arrSlice.call(parts, _i++);\n\t                _max -= 1;\n\t            }\n\t        }\n\t    }\n\t\n\t    return arrJoin.call(parts, '-');\n\t}\n\t\n\t/**\n\t * The DefaultLocale abstract operation returns a String value representing the\n\t * structurally valid (6.2.2) and canonicalized (6.2.3) BCP 47 language tag for the\n\t * host environments current locale.\n\t */\n\tfunction /* 6.2.4 */DefaultLocale() {\n\t    return defaultLocale;\n\t}\n\t\n\t// Sect 6.3 Currency Codes\n\t// =======================\n\t\n\tvar expCurrencyCode = /^[A-Z]{3}$/;\n\t\n\t/**\n\t * The IsWellFormedCurrencyCode abstract operation verifies that the currency argument\n\t * (after conversion to a String value) represents a well-formed 3-letter ISO currency\n\t * code. The following steps are taken:\n\t */\n\tfunction /* 6.3.1 */IsWellFormedCurrencyCode(currency) {\n\t    // 1. Let `c` be ToString(currency)\n\t    var c = String(currency);\n\t\n\t    // 2. Let `normalized` be the result of mapping c to upper case as described\n\t    //    in 6.1.\n\t    var normalized = toLatinUpperCase(c);\n\t\n\t    // 3. If the string length of normalized is not 3, return false.\n\t    // 4. If normalized contains any character that is not in the range \"A\" to \"Z\"\n\t    //    (U+0041 to U+005A), return false.\n\t    if (expCurrencyCode.test(normalized) === false) return false;\n\t\n\t    // 5. Return true\n\t    return true;\n\t}\n\t\n\tvar expUnicodeExSeq = /-u(?:-[0-9a-z]{2,8})+/gi; // See `extension` below\n\t\n\tfunction /* 9.2.1 */CanonicalizeLocaleList(locales) {\n\t    // The abstract operation CanonicalizeLocaleList takes the following steps:\n\t\n\t    // 1. If locales is undefined, then a. Return a new empty List\n\t    if (locales === undefined) return new List();\n\t\n\t    // 2. Let seen be a new empty List.\n\t    var seen = new List();\n\t\n\t    // 3. If locales is a String value, then\n\t    //    a. Let locales be a new array created as if by the expression new\n\t    //    Array(locales) where Array is the standard built-in constructor with\n\t    //    that name and locales is the value of locales.\n\t    locales = typeof locales === 'string' ? [locales] : locales;\n\t\n\t    // 4. Let O be ToObject(locales).\n\t    var O = toObject(locales);\n\t\n\t    // 5. Let lenValue be the result of calling the [[Get]] internal method of\n\t    //    O with the argument \"length\".\n\t    // 6. Let len be ToUint32(lenValue).\n\t    var len = O.length;\n\t\n\t    // 7. Let k be 0.\n\t    var k = 0;\n\t\n\t    // 8. Repeat, while k < len\n\t    while (k < len) {\n\t        // a. Let Pk be ToString(k).\n\t        var Pk = String(k);\n\t\n\t        // b. Let kPresent be the result of calling the [[HasProperty]] internal\n\t        //    method of O with argument Pk.\n\t        var kPresent = Pk in O;\n\t\n\t        // c. If kPresent is true, then\n\t        if (kPresent) {\n\t            // i. Let kValue be the result of calling the [[Get]] internal\n\t            //     method of O with argument Pk.\n\t            var kValue = O[Pk];\n\t\n\t            // ii. If the type of kValue is not String or Object, then throw a\n\t            //     TypeError exception.\n\t            if (kValue === null || typeof kValue !== 'string' && (typeof kValue === \"undefined\" ? \"undefined\" : babelHelpers[\"typeof\"](kValue)) !== 'object') throw new TypeError('String or Object type expected');\n\t\n\t            // iii. Let tag be ToString(kValue).\n\t            var tag = String(kValue);\n\t\n\t            // iv. If the result of calling the abstract operation\n\t            //     IsStructurallyValidLanguageTag (defined in 6.2.2), passing tag as\n\t            //     the argument, is false, then throw a RangeError exception.\n\t            if (!IsStructurallyValidLanguageTag(tag)) throw new RangeError(\"'\" + tag + \"' is not a structurally valid language tag\");\n\t\n\t            // v. Let tag be the result of calling the abstract operation\n\t            //    CanonicalizeLanguageTag (defined in 6.2.3), passing tag as the\n\t            //    argument.\n\t            tag = CanonicalizeLanguageTag(tag);\n\t\n\t            // vi. If tag is not an element of seen, then append tag as the last\n\t            //     element of seen.\n\t            if (arrIndexOf.call(seen, tag) === -1) arrPush.call(seen, tag);\n\t        }\n\t\n\t        // d. Increase k by 1.\n\t        k++;\n\t    }\n\t\n\t    // 9. Return seen.\n\t    return seen;\n\t}\n\t\n\t/**\n\t * The BestAvailableLocale abstract operation compares the provided argument\n\t * locale, which must be a String value with a structurally valid and\n\t * canonicalized BCP 47 language tag, against the locales in availableLocales and\n\t * returns either the longest non-empty prefix of locale that is an element of\n\t * availableLocales, or undefined if there is no such element. It uses the\n\t * fallback mechanism of RFC 4647, section 3.4. The following steps are taken:\n\t */\n\tfunction /* 9.2.2 */BestAvailableLocale(availableLocales, locale) {\n\t    // 1. Let candidate be locale\n\t    var candidate = locale;\n\t\n\t    // 2. Repeat\n\t    while (candidate) {\n\t        // a. If availableLocales contains an element equal to candidate, then return\n\t        // candidate.\n\t        if (arrIndexOf.call(availableLocales, candidate) > -1) return candidate;\n\t\n\t        // b. Let pos be the character index of the last occurrence of \"-\"\n\t        // (U+002D) within candidate. If that character does not occur, return\n\t        // undefined.\n\t        var pos = candidate.lastIndexOf('-');\n\t\n\t        if (pos < 0) return;\n\t\n\t        // c. If pos  2 and the character \"-\" occurs at index pos-2 of candidate,\n\t        //    then decrease pos by 2.\n\t        if (pos >= 2 && candidate.charAt(pos - 2) === '-') pos -= 2;\n\t\n\t        // d. Let candidate be the substring of candidate from position 0, inclusive,\n\t        //    to position pos, exclusive.\n\t        candidate = candidate.substring(0, pos);\n\t    }\n\t}\n\t\n\t/**\n\t * The LookupMatcher abstract operation compares requestedLocales, which must be\n\t * a List as returned by CanonicalizeLocaleList, against the locales in\n\t * availableLocales and determines the best available language to meet the\n\t * request. The following steps are taken:\n\t */\n\tfunction /* 9.2.3 */LookupMatcher(availableLocales, requestedLocales) {\n\t    // 1. Let i be 0.\n\t    var i = 0;\n\t\n\t    // 2. Let len be the number of elements in requestedLocales.\n\t    var len = requestedLocales.length;\n\t\n\t    // 3. Let availableLocale be undefined.\n\t    var availableLocale = void 0;\n\t\n\t    var locale = void 0,\n\t        noExtensionsLocale = void 0;\n\t\n\t    // 4. Repeat while i < len and availableLocale is undefined:\n\t    while (i < len && !availableLocale) {\n\t        // a. Let locale be the element of requestedLocales at 0-origined list\n\t        //    position i.\n\t        locale = requestedLocales[i];\n\t\n\t        // b. Let noExtensionsLocale be the String value that is locale with all\n\t        //    Unicode locale extension sequences removed.\n\t        noExtensionsLocale = String(locale).replace(expUnicodeExSeq, '');\n\t\n\t        // c. Let availableLocale be the result of calling the\n\t        //    BestAvailableLocale abstract operation (defined in 9.2.2) with\n\t        //    arguments availableLocales and noExtensionsLocale.\n\t        availableLocale = BestAvailableLocale(availableLocales, noExtensionsLocale);\n\t\n\t        // d. Increase i by 1.\n\t        i++;\n\t    }\n\t\n\t    // 5. Let result be a new Record.\n\t    var result = new Record();\n\t\n\t    // 6. If availableLocale is not undefined, then\n\t    if (availableLocale !== undefined) {\n\t        // a. Set result.[[locale]] to availableLocale.\n\t        result['[[locale]]'] = availableLocale;\n\t\n\t        // b. If locale and noExtensionsLocale are not the same String value, then\n\t        if (String(locale) !== String(noExtensionsLocale)) {\n\t            // i. Let extension be the String value consisting of the first\n\t            //    substring of locale that is a Unicode locale extension sequence.\n\t            var extension = locale.match(expUnicodeExSeq)[0];\n\t\n\t            // ii. Let extensionIndex be the character position of the initial\n\t            //     \"-\" of the first Unicode locale extension sequence within locale.\n\t            var extensionIndex = locale.indexOf('-u-');\n\t\n\t            // iii. Set result.[[extension]] to extension.\n\t            result['[[extension]]'] = extension;\n\t\n\t            // iv. Set result.[[extensionIndex]] to extensionIndex.\n\t            result['[[extensionIndex]]'] = extensionIndex;\n\t        }\n\t    }\n\t    // 7. Else\n\t    else\n\t        // a. Set result.[[locale]] to the value returned by the DefaultLocale abstract\n\t        //    operation (defined in 6.2.4).\n\t        result['[[locale]]'] = DefaultLocale();\n\t\n\t    // 8. Return result\n\t    return result;\n\t}\n\t\n\t/**\n\t * The BestFitMatcher abstract operation compares requestedLocales, which must be\n\t * a List as returned by CanonicalizeLocaleList, against the locales in\n\t * availableLocales and determines the best available language to meet the\n\t * request. The algorithm is implementation dependent, but should produce results\n\t * that a typical user of the requested locales would perceive as at least as\n\t * good as those produced by the LookupMatcher abstract operation. Options\n\t * specified through Unicode locale extension sequences must be ignored by the\n\t * algorithm. Information about such subsequences is returned separately.\n\t * The abstract operation returns a record with a [[locale]] field, whose value\n\t * is the language tag of the selected locale, which must be an element of\n\t * availableLocales. If the language tag of the request locale that led to the\n\t * selected locale contained a Unicode locale extension sequence, then the\n\t * returned record also contains an [[extension]] field whose value is the first\n\t * Unicode locale extension sequence, and an [[extensionIndex]] field whose value\n\t * is the index of the first Unicode locale extension sequence within the request\n\t * locale language tag.\n\t */\n\tfunction /* 9.2.4 */BestFitMatcher(availableLocales, requestedLocales) {\n\t    return LookupMatcher(availableLocales, requestedLocales);\n\t}\n\t\n\t/**\n\t * The ResolveLocale abstract operation compares a BCP 47 language priority list\n\t * requestedLocales against the locales in availableLocales and determines the\n\t * best available language to meet the request. availableLocales and\n\t * requestedLocales must be provided as List values, options as a Record.\n\t */\n\tfunction /* 9.2.5 */ResolveLocale(availableLocales, requestedLocales, options, relevantExtensionKeys, localeData) {\n\t    if (availableLocales.length === 0) {\n\t        throw new ReferenceError('No locale data has been provided for this object yet.');\n\t    }\n\t\n\t    // The following steps are taken:\n\t    // 1. Let matcher be the value of options.[[localeMatcher]].\n\t    var matcher = options['[[localeMatcher]]'];\n\t\n\t    var r = void 0;\n\t\n\t    // 2. If matcher is \"lookup\", then\n\t    if (matcher === 'lookup')\n\t        // a. Let r be the result of calling the LookupMatcher abstract operation\n\t        //    (defined in 9.2.3) with arguments availableLocales and\n\t        //    requestedLocales.\n\t        r = LookupMatcher(availableLocales, requestedLocales);\n\t\n\t        // 3. Else\n\t    else\n\t        // a. Let r be the result of calling the BestFitMatcher abstract\n\t        //    operation (defined in 9.2.4) with arguments availableLocales and\n\t        //    requestedLocales.\n\t        r = BestFitMatcher(availableLocales, requestedLocales);\n\t\n\t    // 4. Let foundLocale be the value of r.[[locale]].\n\t    var foundLocale = r['[[locale]]'];\n\t\n\t    var extensionSubtags = void 0,\n\t        extensionSubtagsLength = void 0;\n\t\n\t    // 5. If r has an [[extension]] field, then\n\t    if (hop.call(r, '[[extension]]')) {\n\t        // a. Let extension be the value of r.[[extension]].\n\t        var extension = r['[[extension]]'];\n\t        // b. Let split be the standard built-in function object defined in ES5,\n\t        //    15.5.4.14.\n\t        var split = String.prototype.split;\n\t        // c. Let extensionSubtags be the result of calling the [[Call]] internal\n\t        //    method of split with extension as the this value and an argument\n\t        //    list containing the single item \"-\".\n\t        extensionSubtags = split.call(extension, '-');\n\t        // d. Let extensionSubtagsLength be the result of calling the [[Get]]\n\t        //    internal method of extensionSubtags with argument \"length\".\n\t        extensionSubtagsLength = extensionSubtags.length;\n\t    }\n\t\n\t    // 6. Let result be a new Record.\n\t    var result = new Record();\n\t\n\t    // 7. Set result.[[dataLocale]] to foundLocale.\n\t    result['[[dataLocale]]'] = foundLocale;\n\t\n\t    // 8. Let supportedExtension be \"-u\".\n\t    var supportedExtension = '-u';\n\t    // 9. Let i be 0.\n\t    var i = 0;\n\t    // 10. Let len be the result of calling the [[Get]] internal method of\n\t    //     relevantExtensionKeys with argument \"length\".\n\t    var len = relevantExtensionKeys.length;\n\t\n\t    // 11 Repeat while i < len:\n\t    while (i < len) {\n\t        // a. Let key be the result of calling the [[Get]] internal method of\n\t        //    relevantExtensionKeys with argument ToString(i).\n\t        var key = relevantExtensionKeys[i];\n\t        // b. Let foundLocaleData be the result of calling the [[Get]] internal\n\t        //    method of localeData with the argument foundLocale.\n\t        var foundLocaleData = localeData[foundLocale];\n\t        // c. Let keyLocaleData be the result of calling the [[Get]] internal\n\t        //    method of foundLocaleData with the argument key.\n\t        var keyLocaleData = foundLocaleData[key];\n\t        // d. Let value be the result of calling the [[Get]] internal method of\n\t        //    keyLocaleData with argument \"0\".\n\t        var value = keyLocaleData['0'];\n\t        // e. Let supportedExtensionAddition be \"\".\n\t        var supportedExtensionAddition = '';\n\t        // f. Let indexOf be the standard built-in function object defined in\n\t        //    ES5, 15.4.4.14.\n\t        var indexOf = arrIndexOf;\n\t\n\t        // g. If extensionSubtags is not undefined, then\n\t        if (extensionSubtags !== undefined) {\n\t            // i. Let keyPos be the result of calling the [[Call]] internal\n\t            //    method of indexOf with extensionSubtags as the this value and\n\t            // an argument list containing the single item key.\n\t            var keyPos = indexOf.call(extensionSubtags, key);\n\t\n\t            // ii. If keyPos  -1, then\n\t            if (keyPos !== -1) {\n\t                // 1. If keyPos + 1 < extensionSubtagsLength and the length of the\n\t                //    result of calling the [[Get]] internal method of\n\t                //    extensionSubtags with argument ToString(keyPos +1) is greater\n\t                //    than 2, then\n\t                if (keyPos + 1 < extensionSubtagsLength && extensionSubtags[keyPos + 1].length > 2) {\n\t                    // a. Let requestedValue be the result of calling the [[Get]]\n\t                    //    internal method of extensionSubtags with argument\n\t                    //    ToString(keyPos + 1).\n\t                    var requestedValue = extensionSubtags[keyPos + 1];\n\t                    // b. Let valuePos be the result of calling the [[Call]]\n\t                    //    internal method of indexOf with keyLocaleData as the\n\t                    //    this value and an argument list containing the single\n\t                    //    item requestedValue.\n\t                    var valuePos = indexOf.call(keyLocaleData, requestedValue);\n\t\n\t                    // c. If valuePos  -1, then\n\t                    if (valuePos !== -1) {\n\t                        // i. Let value be requestedValue.\n\t                        value = requestedValue,\n\t                        // ii. Let supportedExtensionAddition be the\n\t                        //     concatenation of \"-\", key, \"-\", and value.\n\t                        supportedExtensionAddition = '-' + key + '-' + value;\n\t                    }\n\t                }\n\t                // 2. Else\n\t                else {\n\t                        // a. Let valuePos be the result of calling the [[Call]]\n\t                        // internal method of indexOf with keyLocaleData as the this\n\t                        // value and an argument list containing the single item\n\t                        // \"true\".\n\t                        var _valuePos = indexOf(keyLocaleData, 'true');\n\t\n\t                        // b. If valuePos  -1, then\n\t                        if (_valuePos !== -1)\n\t                            // i. Let value be \"true\".\n\t                            value = 'true';\n\t                    }\n\t            }\n\t        }\n\t        // h. If options has a field [[<key>]], then\n\t        if (hop.call(options, '[[' + key + ']]')) {\n\t            // i. Let optionsValue be the value of options.[[<key>]].\n\t            var optionsValue = options['[[' + key + ']]'];\n\t\n\t            // ii. If the result of calling the [[Call]] internal method of indexOf\n\t            //     with keyLocaleData as the this value and an argument list\n\t            //     containing the single item optionsValue is not -1, then\n\t            if (indexOf.call(keyLocaleData, optionsValue) !== -1) {\n\t                // 1. If optionsValue is not equal to value, then\n\t                if (optionsValue !== value) {\n\t                    // a. Let value be optionsValue.\n\t                    value = optionsValue;\n\t                    // b. Let supportedExtensionAddition be \"\".\n\t                    supportedExtensionAddition = '';\n\t                }\n\t            }\n\t        }\n\t        // i. Set result.[[<key>]] to value.\n\t        result['[[' + key + ']]'] = value;\n\t\n\t        // j. Append supportedExtensionAddition to supportedExtension.\n\t        supportedExtension += supportedExtensionAddition;\n\t\n\t        // k. Increase i by 1.\n\t        i++;\n\t    }\n\t    // 12. If the length of supportedExtension is greater than 2, then\n\t    if (supportedExtension.length > 2) {\n\t        // a.\n\t        var privateIndex = foundLocale.indexOf(\"-x-\");\n\t        // b.\n\t        if (privateIndex === -1) {\n\t            // i.\n\t            foundLocale = foundLocale + supportedExtension;\n\t        }\n\t        // c.\n\t        else {\n\t                // i.\n\t                var preExtension = foundLocale.substring(0, privateIndex);\n\t                // ii.\n\t                var postExtension = foundLocale.substring(privateIndex);\n\t                // iii.\n\t                foundLocale = preExtension + supportedExtension + postExtension;\n\t            }\n\t        // d. asserting - skipping\n\t        // e.\n\t        foundLocale = CanonicalizeLanguageTag(foundLocale);\n\t    }\n\t    // 13. Set result.[[locale]] to foundLocale.\n\t    result['[[locale]]'] = foundLocale;\n\t\n\t    // 14. Return result.\n\t    return result;\n\t}\n\t\n\t/**\n\t * The LookupSupportedLocales abstract operation returns the subset of the\n\t * provided BCP 47 language priority list requestedLocales for which\n\t * availableLocales has a matching locale when using the BCP 47 Lookup algorithm.\n\t * Locales appear in the same order in the returned list as in requestedLocales.\n\t * The following steps are taken:\n\t */\n\tfunction /* 9.2.6 */LookupSupportedLocales(availableLocales, requestedLocales) {\n\t    // 1. Let len be the number of elements in requestedLocales.\n\t    var len = requestedLocales.length;\n\t    // 2. Let subset be a new empty List.\n\t    var subset = new List();\n\t    // 3. Let k be 0.\n\t    var k = 0;\n\t\n\t    // 4. Repeat while k < len\n\t    while (k < len) {\n\t        // a. Let locale be the element of requestedLocales at 0-origined list\n\t        //    position k.\n\t        var locale = requestedLocales[k];\n\t        // b. Let noExtensionsLocale be the String value that is locale with all\n\t        //    Unicode locale extension sequences removed.\n\t        var noExtensionsLocale = String(locale).replace(expUnicodeExSeq, '');\n\t        // c. Let availableLocale be the result of calling the\n\t        //    BestAvailableLocale abstract operation (defined in 9.2.2) with\n\t        //    arguments availableLocales and noExtensionsLocale.\n\t        var availableLocale = BestAvailableLocale(availableLocales, noExtensionsLocale);\n\t\n\t        // d. If availableLocale is not undefined, then append locale to the end of\n\t        //    subset.\n\t        if (availableLocale !== undefined) arrPush.call(subset, locale);\n\t\n\t        // e. Increment k by 1.\n\t        k++;\n\t    }\n\t\n\t    // 5. Let subsetArray be a new Array object whose elements are the same\n\t    //    values in the same order as the elements of subset.\n\t    var subsetArray = arrSlice.call(subset);\n\t\n\t    // 6. Return subsetArray.\n\t    return subsetArray;\n\t}\n\t\n\t/**\n\t * The BestFitSupportedLocales abstract operation returns the subset of the\n\t * provided BCP 47 language priority list requestedLocales for which\n\t * availableLocales has a matching locale when using the Best Fit Matcher\n\t * algorithm. Locales appear in the same order in the returned list as in\n\t * requestedLocales. The steps taken are implementation dependent.\n\t */\n\tfunction /*9.2.7 */BestFitSupportedLocales(availableLocales, requestedLocales) {\n\t    // ###TODO: implement this function as described by the specification###\n\t    return LookupSupportedLocales(availableLocales, requestedLocales);\n\t}\n\t\n\t/**\n\t * The SupportedLocales abstract operation returns the subset of the provided BCP\n\t * 47 language priority list requestedLocales for which availableLocales has a\n\t * matching locale. Two algorithms are available to match the locales: the Lookup\n\t * algorithm described in RFC 4647 section 3.4, and an implementation dependent\n\t * best-fit algorithm. Locales appear in the same order in the returned list as\n\t * in requestedLocales. The following steps are taken:\n\t */\n\tfunction /*9.2.8 */SupportedLocales(availableLocales, requestedLocales, options) {\n\t    var matcher = void 0,\n\t        subset = void 0;\n\t\n\t    // 1. If options is not undefined, then\n\t    if (options !== undefined) {\n\t        // a. Let options be ToObject(options).\n\t        options = new Record(toObject(options));\n\t        // b. Let matcher be the result of calling the [[Get]] internal method of\n\t        //    options with argument \"localeMatcher\".\n\t        matcher = options.localeMatcher;\n\t\n\t        // c. If matcher is not undefined, then\n\t        if (matcher !== undefined) {\n\t            // i. Let matcher be ToString(matcher).\n\t            matcher = String(matcher);\n\t\n\t            // ii. If matcher is not \"lookup\" or \"best fit\", then throw a RangeError\n\t            //     exception.\n\t            if (matcher !== 'lookup' && matcher !== 'best fit') throw new RangeError('matcher should be \"lookup\" or \"best fit\"');\n\t        }\n\t    }\n\t    // 2. If matcher is undefined or \"best fit\", then\n\t    if (matcher === undefined || matcher === 'best fit')\n\t        // a. Let subset be the result of calling the BestFitSupportedLocales\n\t        //    abstract operation (defined in 9.2.7) with arguments\n\t        //    availableLocales and requestedLocales.\n\t        subset = BestFitSupportedLocales(availableLocales, requestedLocales);\n\t        // 3. Else\n\t    else\n\t        // a. Let subset be the result of calling the LookupSupportedLocales\n\t        //    abstract operation (defined in 9.2.6) with arguments\n\t        //    availableLocales and requestedLocales.\n\t        subset = LookupSupportedLocales(availableLocales, requestedLocales);\n\t\n\t    // 4. For each named own property name P of subset,\n\t    for (var P in subset) {\n\t        if (!hop.call(subset, P)) continue;\n\t\n\t        // a. Let desc be the result of calling the [[GetOwnProperty]] internal\n\t        //    method of subset with P.\n\t        // b. Set desc.[[Writable]] to false.\n\t        // c. Set desc.[[Configurable]] to false.\n\t        // d. Call the [[DefineOwnProperty]] internal method of subset with P, desc,\n\t        //    and true as arguments.\n\t        defineProperty(subset, P, {\n\t            writable: false, configurable: false, value: subset[P]\n\t        });\n\t    }\n\t    // \"Freeze\" the array so no new elements can be added\n\t    defineProperty(subset, 'length', { writable: false });\n\t\n\t    // 5. Return subset\n\t    return subset;\n\t}\n\t\n\t/**\n\t * The GetOption abstract operation extracts the value of the property named\n\t * property from the provided options object, converts it to the required type,\n\t * checks whether it is one of a List of allowed values, and fills in a fallback\n\t * value if necessary.\n\t */\n\tfunction /*9.2.9 */GetOption(options, property, type, values, fallback) {\n\t    // 1. Let value be the result of calling the [[Get]] internal method of\n\t    //    options with argument property.\n\t    var value = options[property];\n\t\n\t    // 2. If value is not undefined, then\n\t    if (value !== undefined) {\n\t        // a. Assert: type is \"boolean\" or \"string\".\n\t        // b. If type is \"boolean\", then let value be ToBoolean(value).\n\t        // c. If type is \"string\", then let value be ToString(value).\n\t        value = type === 'boolean' ? Boolean(value) : type === 'string' ? String(value) : value;\n\t\n\t        // d. If values is not undefined, then\n\t        if (values !== undefined) {\n\t            // i. If values does not contain an element equal to value, then throw a\n\t            //    RangeError exception.\n\t            if (arrIndexOf.call(values, value) === -1) throw new RangeError(\"'\" + value + \"' is not an allowed value for `\" + property + '`');\n\t        }\n\t\n\t        // e. Return value.\n\t        return value;\n\t    }\n\t    // Else return fallback.\n\t    return fallback;\n\t}\n\t\n\t/**\n\t * The GetNumberOption abstract operation extracts a property value from the\n\t * provided options object, converts it to a Number value, checks whether it is\n\t * in the allowed range, and fills in a fallback value if necessary.\n\t */\n\tfunction /* 9.2.10 */GetNumberOption(options, property, minimum, maximum, fallback) {\n\t    // 1. Let value be the result of calling the [[Get]] internal method of\n\t    //    options with argument property.\n\t    var value = options[property];\n\t\n\t    // 2. If value is not undefined, then\n\t    if (value !== undefined) {\n\t        // a. Let value be ToNumber(value).\n\t        value = Number(value);\n\t\n\t        // b. If value is NaN or less than minimum or greater than maximum, throw a\n\t        //    RangeError exception.\n\t        if (isNaN(value) || value < minimum || value > maximum) throw new RangeError('Value is not a number or outside accepted range');\n\t\n\t        // c. Return floor(value).\n\t        return Math.floor(value);\n\t    }\n\t    // 3. Else return fallback.\n\t    return fallback;\n\t}\n\t\n\t// 8 The Intl Object\n\tvar Intl = {};\n\t\n\t// 8.2 Function Properties of the Intl Object\n\t\n\t// 8.2.1\n\t// @spec[tc39/ecma402/master/spec/intl.html]\n\t// @clause[sec-intl.getcanonicallocales]\n\tIntl.getCanonicalLocales = function (locales) {\n\t    // 1. Let ll be ? CanonicalizeLocaleList(locales).\n\t    var ll = CanonicalizeLocaleList(locales);\n\t    // 2. Return CreateArrayFromList(ll).\n\t    {\n\t        var result = [];\n\t        for (var code in ll) {\n\t            result.push(ll[code]);\n\t        }\n\t        return result;\n\t    }\n\t};\n\t\n\t// Currency minor units output from get-4217 grunt task, formatted\n\tvar currencyMinorUnits = {\n\t    BHD: 3, BYR: 0, XOF: 0, BIF: 0, XAF: 0, CLF: 4, CLP: 0, KMF: 0, DJF: 0,\n\t    XPF: 0, GNF: 0, ISK: 0, IQD: 3, JPY: 0, JOD: 3, KRW: 0, KWD: 3, LYD: 3,\n\t    OMR: 3, PYG: 0, RWF: 0, TND: 3, UGX: 0, UYI: 0, VUV: 0, VND: 0\n\t};\n\t\n\t// Define the NumberFormat constructor internally so it cannot be tainted\n\tfunction NumberFormatConstructor() {\n\t    var locales = arguments[0];\n\t    var options = arguments[1];\n\t\n\t    if (!this || this === Intl) {\n\t        return new Intl.NumberFormat(locales, options);\n\t    }\n\t\n\t    return InitializeNumberFormat(toObject(this), locales, options);\n\t}\n\t\n\tdefineProperty(Intl, 'NumberFormat', {\n\t    configurable: true,\n\t    writable: true,\n\t    value: NumberFormatConstructor\n\t});\n\t\n\t// Must explicitly set prototypes as unwritable\n\tdefineProperty(Intl.NumberFormat, 'prototype', {\n\t    writable: false\n\t});\n\t\n\t/**\n\t * The abstract operation InitializeNumberFormat accepts the arguments\n\t * numberFormat (which must be an object), locales, and options. It initializes\n\t * numberFormat as a NumberFormat object.\n\t */\n\tfunction /*11.1.1.1 */InitializeNumberFormat(numberFormat, locales, options) {\n\t    // This will be a internal properties object if we're not already initialized\n\t    var internal = getInternalProperties(numberFormat);\n\t\n\t    // Create an object whose props can be used to restore the values of RegExp props\n\t    var regexpState = createRegExpRestore();\n\t\n\t    // 1. If numberFormat has an [[initializedIntlObject]] internal property with\n\t    // value true, throw a TypeError exception.\n\t    if (internal['[[initializedIntlObject]]'] === true) throw new TypeError('`this` object has already been initialized as an Intl object');\n\t\n\t    // Need this to access the `internal` object\n\t    defineProperty(numberFormat, '__getInternalProperties', {\n\t        value: function value() {\n\t            // NOTE: Non-standard, for internal use only\n\t            if (arguments[0] === secret) return internal;\n\t        }\n\t    });\n\t\n\t    // 2. Set the [[initializedIntlObject]] internal property of numberFormat to true.\n\t    internal['[[initializedIntlObject]]'] = true;\n\t\n\t    // 3. Let requestedLocales be the result of calling the CanonicalizeLocaleList\n\t    //    abstract operation (defined in 9.2.1) with argument locales.\n\t    var requestedLocales = CanonicalizeLocaleList(locales);\n\t\n\t    // 4. If options is undefined, then\n\t    if (options === undefined)\n\t        // a. Let options be the result of creating a new object as if by the\n\t        // expression new Object() where Object is the standard built-in constructor\n\t        // with that name.\n\t        options = {};\n\t\n\t        // 5. Else\n\t    else\n\t        // a. Let options be ToObject(options).\n\t        options = toObject(options);\n\t\n\t    // 6. Let opt be a new Record.\n\t    var opt = new Record(),\n\t\n\t\n\t    // 7. Let matcher be the result of calling the GetOption abstract operation\n\t    //    (defined in 9.2.9) with the arguments options, \"localeMatcher\", \"string\",\n\t    //    a List containing the two String values \"lookup\" and \"best fit\", and\n\t    //    \"best fit\".\n\t    matcher = GetOption(options, 'localeMatcher', 'string', new List('lookup', 'best fit'), 'best fit');\n\t\n\t    // 8. Set opt.[[localeMatcher]] to matcher.\n\t    opt['[[localeMatcher]]'] = matcher;\n\t\n\t    // 9. Let NumberFormat be the standard built-in object that is the initial value\n\t    //    of Intl.NumberFormat.\n\t    // 10. Let localeData be the value of the [[localeData]] internal property of\n\t    //     NumberFormat.\n\t    var localeData = internals.NumberFormat['[[localeData]]'];\n\t\n\t    // 11. Let r be the result of calling the ResolveLocale abstract operation\n\t    //     (defined in 9.2.5) with the [[availableLocales]] internal property of\n\t    //     NumberFormat, requestedLocales, opt, the [[relevantExtensionKeys]]\n\t    //     internal property of NumberFormat, and localeData.\n\t    var r = ResolveLocale(internals.NumberFormat['[[availableLocales]]'], requestedLocales, opt, internals.NumberFormat['[[relevantExtensionKeys]]'], localeData);\n\t\n\t    // 12. Set the [[locale]] internal property of numberFormat to the value of\n\t    //     r.[[locale]].\n\t    internal['[[locale]]'] = r['[[locale]]'];\n\t\n\t    // 13. Set the [[numberingSystem]] internal property of numberFormat to the value\n\t    //     of r.[[nu]].\n\t    internal['[[numberingSystem]]'] = r['[[nu]]'];\n\t\n\t    // The specification doesn't tell us to do this, but it's helpful later on\n\t    internal['[[dataLocale]]'] = r['[[dataLocale]]'];\n\t\n\t    // 14. Let dataLocale be the value of r.[[dataLocale]].\n\t    var dataLocale = r['[[dataLocale]]'];\n\t\n\t    // 15. Let s be the result of calling the GetOption abstract operation with the\n\t    //     arguments options, \"style\", \"string\", a List containing the three String\n\t    //     values \"decimal\", \"percent\", and \"currency\", and \"decimal\".\n\t    var s = GetOption(options, 'style', 'string', new List('decimal', 'percent', 'currency'), 'decimal');\n\t\n\t    // 16. Set the [[style]] internal property of numberFormat to s.\n\t    internal['[[style]]'] = s;\n\t\n\t    // 17. Let c be the result of calling the GetOption abstract operation with the\n\t    //     arguments options, \"currency\", \"string\", undefined, and undefined.\n\t    var c = GetOption(options, 'currency', 'string');\n\t\n\t    // 18. If c is not undefined and the result of calling the\n\t    //     IsWellFormedCurrencyCode abstract operation (defined in 6.3.1) with\n\t    //     argument c is false, then throw a RangeError exception.\n\t    if (c !== undefined && !IsWellFormedCurrencyCode(c)) throw new RangeError(\"'\" + c + \"' is not a valid currency code\");\n\t\n\t    // 19. If s is \"currency\" and c is undefined, throw a TypeError exception.\n\t    if (s === 'currency' && c === undefined) throw new TypeError('Currency code is required when style is currency');\n\t\n\t    var cDigits = void 0;\n\t\n\t    // 20. If s is \"currency\", then\n\t    if (s === 'currency') {\n\t        // a. Let c be the result of converting c to upper case as specified in 6.1.\n\t        c = c.toUpperCase();\n\t\n\t        // b. Set the [[currency]] internal property of numberFormat to c.\n\t        internal['[[currency]]'] = c;\n\t\n\t        // c. Let cDigits be the result of calling the CurrencyDigits abstract\n\t        //    operation (defined below) with argument c.\n\t        cDigits = CurrencyDigits(c);\n\t    }\n\t\n\t    // 21. Let cd be the result of calling the GetOption abstract operation with the\n\t    //     arguments options, \"currencyDisplay\", \"string\", a List containing the\n\t    //     three String values \"code\", \"symbol\", and \"name\", and \"symbol\".\n\t    var cd = GetOption(options, 'currencyDisplay', 'string', new List('code', 'symbol', 'name'), 'symbol');\n\t\n\t    // 22. If s is \"currency\", then set the [[currencyDisplay]] internal property of\n\t    //     numberFormat to cd.\n\t    if (s === 'currency') internal['[[currencyDisplay]]'] = cd;\n\t\n\t    // 23. Let mnid be the result of calling the GetNumberOption abstract operation\n\t    //     (defined in 9.2.10) with arguments options, \"minimumIntegerDigits\", 1, 21,\n\t    //     and 1.\n\t    var mnid = GetNumberOption(options, 'minimumIntegerDigits', 1, 21, 1);\n\t\n\t    // 24. Set the [[minimumIntegerDigits]] internal property of numberFormat to mnid.\n\t    internal['[[minimumIntegerDigits]]'] = mnid;\n\t\n\t    // 25. If s is \"currency\", then let mnfdDefault be cDigits; else let mnfdDefault\n\t    //     be 0.\n\t    var mnfdDefault = s === 'currency' ? cDigits : 0;\n\t\n\t    // 26. Let mnfd be the result of calling the GetNumberOption abstract operation\n\t    //     with arguments options, \"minimumFractionDigits\", 0, 20, and mnfdDefault.\n\t    var mnfd = GetNumberOption(options, 'minimumFractionDigits', 0, 20, mnfdDefault);\n\t\n\t    // 27. Set the [[minimumFractionDigits]] internal property of numberFormat to mnfd.\n\t    internal['[[minimumFractionDigits]]'] = mnfd;\n\t\n\t    // 28. If s is \"currency\", then let mxfdDefault be max(mnfd, cDigits); else if s\n\t    //     is \"percent\", then let mxfdDefault be max(mnfd, 0); else let mxfdDefault\n\t    //     be max(mnfd, 3).\n\t    var mxfdDefault = s === 'currency' ? Math.max(mnfd, cDigits) : s === 'percent' ? Math.max(mnfd, 0) : Math.max(mnfd, 3);\n\t\n\t    // 29. Let mxfd be the result of calling the GetNumberOption abstract operation\n\t    //     with arguments options, \"maximumFractionDigits\", mnfd, 20, and mxfdDefault.\n\t    var mxfd = GetNumberOption(options, 'maximumFractionDigits', mnfd, 20, mxfdDefault);\n\t\n\t    // 30. Set the [[maximumFractionDigits]] internal property of numberFormat to mxfd.\n\t    internal['[[maximumFractionDigits]]'] = mxfd;\n\t\n\t    // 31. Let mnsd be the result of calling the [[Get]] internal method of options\n\t    //     with argument \"minimumSignificantDigits\".\n\t    var mnsd = options.minimumSignificantDigits;\n\t\n\t    // 32. Let mxsd be the result of calling the [[Get]] internal method of options\n\t    //     with argument \"maximumSignificantDigits\".\n\t    var mxsd = options.maximumSignificantDigits;\n\t\n\t    // 33. If mnsd is not undefined or mxsd is not undefined, then:\n\t    if (mnsd !== undefined || mxsd !== undefined) {\n\t        // a. Let mnsd be the result of calling the GetNumberOption abstract\n\t        //    operation with arguments options, \"minimumSignificantDigits\", 1, 21,\n\t        //    and 1.\n\t        mnsd = GetNumberOption(options, 'minimumSignificantDigits', 1, 21, 1);\n\t\n\t        // b. Let mxsd be the result of calling the GetNumberOption abstract\n\t        //     operation with arguments options, \"maximumSignificantDigits\", mnsd,\n\t        //     21, and 21.\n\t        mxsd = GetNumberOption(options, 'maximumSignificantDigits', mnsd, 21, 21);\n\t\n\t        // c. Set the [[minimumSignificantDigits]] internal property of numberFormat\n\t        //    to mnsd, and the [[maximumSignificantDigits]] internal property of\n\t        //    numberFormat to mxsd.\n\t        internal['[[minimumSignificantDigits]]'] = mnsd;\n\t        internal['[[maximumSignificantDigits]]'] = mxsd;\n\t    }\n\t    // 34. Let g be the result of calling the GetOption abstract operation with the\n\t    //     arguments options, \"useGrouping\", \"boolean\", undefined, and true.\n\t    var g = GetOption(options, 'useGrouping', 'boolean', undefined, true);\n\t\n\t    // 35. Set the [[useGrouping]] internal property of numberFormat to g.\n\t    internal['[[useGrouping]]'] = g;\n\t\n\t    // 36. Let dataLocaleData be the result of calling the [[Get]] internal method of\n\t    //     localeData with argument dataLocale.\n\t    var dataLocaleData = localeData[dataLocale];\n\t\n\t    // 37. Let patterns be the result of calling the [[Get]] internal method of\n\t    //     dataLocaleData with argument \"patterns\".\n\t    var patterns = dataLocaleData.patterns;\n\t\n\t    // 38. Assert: patterns is an object (see 11.2.3)\n\t\n\t    // 39. Let stylePatterns be the result of calling the [[Get]] internal method of\n\t    //     patterns with argument s.\n\t    var stylePatterns = patterns[s];\n\t\n\t    // 40. Set the [[positivePattern]] internal property of numberFormat to the\n\t    //     result of calling the [[Get]] internal method of stylePatterns with the\n\t    //     argument \"positivePattern\".\n\t    internal['[[positivePattern]]'] = stylePatterns.positivePattern;\n\t\n\t    // 41. Set the [[negativePattern]] internal property of numberFormat to the\n\t    //     result of calling the [[Get]] internal method of stylePatterns with the\n\t    //     argument \"negativePattern\".\n\t    internal['[[negativePattern]]'] = stylePatterns.negativePattern;\n\t\n\t    // 42. Set the [[boundFormat]] internal property of numberFormat to undefined.\n\t    internal['[[boundFormat]]'] = undefined;\n\t\n\t    // 43. Set the [[initializedNumberFormat]] internal property of numberFormat to\n\t    //     true.\n\t    internal['[[initializedNumberFormat]]'] = true;\n\t\n\t    // In ES3, we need to pre-bind the format() function\n\t    if (es3) numberFormat.format = GetFormatNumber.call(numberFormat);\n\t\n\t    // Restore the RegExp properties\n\t    regexpState.exp.test(regexpState.input);\n\t\n\t    // Return the newly initialised object\n\t    return numberFormat;\n\t}\n\t\n\tfunction CurrencyDigits(currency) {\n\t    // When the CurrencyDigits abstract operation is called with an argument currency\n\t    // (which must be an upper case String value), the following steps are taken:\n\t\n\t    // 1. If the ISO 4217 currency and funds code list contains currency as an\n\t    // alphabetic code, then return the minor unit value corresponding to the\n\t    // currency from the list; else return 2.\n\t    return currencyMinorUnits[currency] !== undefined ? currencyMinorUnits[currency] : 2;\n\t}\n\t\n\t/* 11.2.3 */internals.NumberFormat = {\n\t    '[[availableLocales]]': [],\n\t    '[[relevantExtensionKeys]]': ['nu'],\n\t    '[[localeData]]': {}\n\t};\n\t\n\t/**\n\t * When the supportedLocalesOf method of Intl.NumberFormat is called, the\n\t * following steps are taken:\n\t */\n\t/* 11.2.2 */\n\tdefineProperty(Intl.NumberFormat, 'supportedLocalesOf', {\n\t    configurable: true,\n\t    writable: true,\n\t    value: fnBind.call(function (locales) {\n\t        // Bound functions only have the `this` value altered if being used as a constructor,\n\t        // this lets us imitate a native function that has no constructor\n\t        if (!hop.call(this, '[[availableLocales]]')) throw new TypeError('supportedLocalesOf() is not a constructor');\n\t\n\t        // Create an object whose props can be used to restore the values of RegExp props\n\t        var regexpState = createRegExpRestore(),\n\t\n\t\n\t        // 1. If options is not provided, then let options be undefined.\n\t        options = arguments[1],\n\t\n\t\n\t        // 2. Let availableLocales be the value of the [[availableLocales]] internal\n\t        //    property of the standard built-in object that is the initial value of\n\t        //    Intl.NumberFormat.\n\t\n\t        availableLocales = this['[[availableLocales]]'],\n\t\n\t\n\t        // 3. Let requestedLocales be the result of calling the CanonicalizeLocaleList\n\t        //    abstract operation (defined in 9.2.1) with argument locales.\n\t        requestedLocales = CanonicalizeLocaleList(locales);\n\t\n\t        // Restore the RegExp properties\n\t        regexpState.exp.test(regexpState.input);\n\t\n\t        // 4. Return the result of calling the SupportedLocales abstract operation\n\t        //    (defined in 9.2.8) with arguments availableLocales, requestedLocales,\n\t        //    and options.\n\t        return SupportedLocales(availableLocales, requestedLocales, options);\n\t    }, internals.NumberFormat)\n\t});\n\t\n\t/**\n\t * This named accessor property returns a function that formats a number\n\t * according to the effective locale and the formatting options of this\n\t * NumberFormat object.\n\t */\n\t/* 11.3.2 */defineProperty(Intl.NumberFormat.prototype, 'format', {\n\t    configurable: true,\n\t    get: GetFormatNumber\n\t});\n\t\n\tfunction GetFormatNumber() {\n\t    var internal = this !== null && babelHelpers[\"typeof\"](this) === 'object' && getInternalProperties(this);\n\t\n\t    // Satisfy test 11.3_b\n\t    if (!internal || !internal['[[initializedNumberFormat]]']) throw new TypeError('`this` value for format() is not an initialized Intl.NumberFormat object.');\n\t\n\t    // The value of the [[Get]] attribute is a function that takes the following\n\t    // steps:\n\t\n\t    // 1. If the [[boundFormat]] internal property of this NumberFormat object\n\t    //    is undefined, then:\n\t    if (internal['[[boundFormat]]'] === undefined) {\n\t        // a. Let F be a Function object, with internal properties set as\n\t        //    specified for built-in functions in ES5, 15, or successor, and the\n\t        //    length property set to 1, that takes the argument value and\n\t        //    performs the following steps:\n\t        var F = function F(value) {\n\t            // i. If value is not provided, then let value be undefined.\n\t            // ii. Let x be ToNumber(value).\n\t            // iii. Return the result of calling the FormatNumber abstract\n\t            //      operation (defined below) with arguments this and x.\n\t            return FormatNumber(this, /* x = */Number(value));\n\t        };\n\t\n\t        // b. Let bind be the standard built-in function object defined in ES5,\n\t        //    15.3.4.5.\n\t        // c. Let bf be the result of calling the [[Call]] internal method of\n\t        //    bind with F as the this value and an argument list containing\n\t        //    the single item this.\n\t        var bf = fnBind.call(F, this);\n\t\n\t        // d. Set the [[boundFormat]] internal property of this NumberFormat\n\t        //    object to bf.\n\t        internal['[[boundFormat]]'] = bf;\n\t    }\n\t    // Return the value of the [[boundFormat]] internal property of this\n\t    // NumberFormat object.\n\t    return internal['[[boundFormat]]'];\n\t}\n\t\n\tIntl.NumberFormat.prototype.formatToParts = function (value) {\n\t    var internal = this !== null && babelHelpers[\"typeof\"](this) === 'object' && getInternalProperties(this);\n\t    if (!internal || !internal['[[initializedNumberFormat]]']) throw new TypeError('`this` value for formatToParts() is not an initialized Intl.NumberFormat object.');\n\t\n\t    var x = Number(value);\n\t    return FormatNumberToParts(this, x);\n\t};\n\t\n\t/*\n\t * @spec[stasm/ecma402/number-format-to-parts/spec/numberformat.html]\n\t * @clause[sec-formatnumbertoparts]\n\t */\n\tfunction FormatNumberToParts(numberFormat, x) {\n\t    // 1. Let parts be ? PartitionNumberPattern(numberFormat, x).\n\t    var parts = PartitionNumberPattern(numberFormat, x);\n\t    // 2. Let result be ArrayCreate(0).\n\t    var result = [];\n\t    // 3. Let n be 0.\n\t    var n = 0;\n\t    // 4. For each part in parts, do:\n\t    for (var i = 0; parts.length > i; i++) {\n\t        var part = parts[i];\n\t        // a. Let O be ObjectCreate(%ObjectPrototype%).\n\t        var O = {};\n\t        // a. Perform ? CreateDataPropertyOrThrow(O, \"type\", part.[[type]]).\n\t        O.type = part['[[type]]'];\n\t        // a. Perform ? CreateDataPropertyOrThrow(O, \"value\", part.[[value]]).\n\t        O.value = part['[[value]]'];\n\t        // a. Perform ? CreateDataPropertyOrThrow(result, ? ToString(n), O).\n\t        result[n] = O;\n\t        // a. Increment n by 1.\n\t        n += 1;\n\t    }\n\t    // 5. Return result.\n\t    return result;\n\t}\n\t\n\t/*\n\t * @spec[stasm/ecma402/number-format-to-parts/spec/numberformat.html]\n\t * @clause[sec-partitionnumberpattern]\n\t */\n\tfunction PartitionNumberPattern(numberFormat, x) {\n\t\n\t    var internal = getInternalProperties(numberFormat),\n\t        locale = internal['[[dataLocale]]'],\n\t        nums = internal['[[numberingSystem]]'],\n\t        data = internals.NumberFormat['[[localeData]]'][locale],\n\t        ild = data.symbols[nums] || data.symbols.latn,\n\t        pattern = void 0;\n\t\n\t    // 1. If x is not NaN and x < 0, then:\n\t    if (!isNaN(x) && x < 0) {\n\t        // a. Let x be -x.\n\t        x = -x;\n\t        // a. Let pattern be the value of numberFormat.[[negativePattern]].\n\t        pattern = internal['[[negativePattern]]'];\n\t    }\n\t    // 2. Else,\n\t    else {\n\t            // a. Let pattern be the value of numberFormat.[[positivePattern]].\n\t            pattern = internal['[[positivePattern]]'];\n\t        }\n\t    // 3. Let result be a new empty List.\n\t    var result = new List();\n\t    // 4. Let beginIndex be Call(%StringProto_indexOf%, pattern, \"{\", 0).\n\t    var beginIndex = pattern.indexOf('{', 0);\n\t    // 5. Let endIndex be 0.\n\t    var endIndex = 0;\n\t    // 6. Let nextIndex be 0.\n\t    var nextIndex = 0;\n\t    // 7. Let length be the number of code units in pattern.\n\t    var length = pattern.length;\n\t    // 8. Repeat while beginIndex is an integer index into pattern:\n\t    while (beginIndex > -1 && beginIndex < length) {\n\t        // a. Set endIndex to Call(%StringProto_indexOf%, pattern, \"}\", beginIndex)\n\t        endIndex = pattern.indexOf('}', beginIndex);\n\t        // a. If endIndex = -1, throw new Error exception.\n\t        if (endIndex === -1) throw new Error();\n\t        // a. If beginIndex is greater than nextIndex, then:\n\t        if (beginIndex > nextIndex) {\n\t            // i. Let literal be a substring of pattern from position nextIndex, inclusive, to position beginIndex, exclusive.\n\t            var literal = pattern.substring(nextIndex, beginIndex);\n\t            // ii. Add new part record { [[type]]: \"literal\", [[value]]: literal } as a new element of the list result.\n\t            arrPush.call(result, { '[[type]]': 'literal', '[[value]]': literal });\n\t        }\n\t        // a. Let p be the substring of pattern from position beginIndex, exclusive, to position endIndex, exclusive.\n\t        var p = pattern.substring(beginIndex + 1, endIndex);\n\t        // a. If p is equal \"number\", then:\n\t        if (p === \"number\") {\n\t            // i. If x is NaN,\n\t            if (isNaN(x)) {\n\t                // 1. Let n be an ILD String value indicating the NaN value.\n\t                var n = ild.nan;\n\t                // 2. Add new part record { [[type]]: \"nan\", [[value]]: n } as a new element of the list result.\n\t                arrPush.call(result, { '[[type]]': 'nan', '[[value]]': n });\n\t            }\n\t            // ii. Else if isFinite(x) is false,\n\t            else if (!isFinite(x)) {\n\t                    // 1. Let n be an ILD String value indicating infinity.\n\t                    var _n = ild.infinity;\n\t                    // 2. Add new part record { [[type]]: \"infinity\", [[value]]: n } as a new element of the list result.\n\t                    arrPush.call(result, { '[[type]]': 'infinity', '[[value]]': _n });\n\t                }\n\t                // iii. Else,\n\t                else {\n\t                        // 1. If the value of numberFormat.[[style]] is \"percent\" and isFinite(x), let x be 100  x.\n\t                        if (internal['[[style]]'] === 'percent' && isFinite(x)) x *= 100;\n\t\n\t                        var _n2 = void 0;\n\t                        // 2. If the numberFormat.[[minimumSignificantDigits]] and numberFormat.[[maximumSignificantDigits]] are present, then\n\t                        if (hop.call(internal, '[[minimumSignificantDigits]]') && hop.call(internal, '[[maximumSignificantDigits]]')) {\n\t                            // a. Let n be ToRawPrecision(x, numberFormat.[[minimumSignificantDigits]], numberFormat.[[maximumSignificantDigits]]).\n\t                            _n2 = ToRawPrecision(x, internal['[[minimumSignificantDigits]]'], internal['[[maximumSignificantDigits]]']);\n\t                        }\n\t                        // 3. Else,\n\t                        else {\n\t                                // a. Let n be ToRawFixed(x, numberFormat.[[minimumIntegerDigits]], numberFormat.[[minimumFractionDigits]], numberFormat.[[maximumFractionDigits]]).\n\t                                _n2 = ToRawFixed(x, internal['[[minimumIntegerDigits]]'], internal['[[minimumFractionDigits]]'], internal['[[maximumFractionDigits]]']);\n\t                            }\n\t                        // 4. If the value of the numberFormat.[[numberingSystem]] matches one of the values in the \"Numbering System\" column of Table 2 below, then\n\t                        if (numSys[nums]) {\n\t                            (function () {\n\t                                // a. Let digits be an array whose 10 String valued elements are the UTF-16 string representations of the 10 digits specified in the \"Digits\" column of the matching row in Table 2.\n\t                                var digits = numSys[nums];\n\t                                // a. Replace each digit in n with the value of digits[digit].\n\t                                _n2 = String(_n2).replace(/\\d/g, function (digit) {\n\t                                    return digits[digit];\n\t                                });\n\t                            })();\n\t                        }\n\t                        // 5. Else use an implementation dependent algorithm to map n to the appropriate representation of n in the given numbering system.\n\t                        else _n2 = String(_n2); // ###TODO###\n\t\n\t                        var integer = void 0;\n\t                        var fraction = void 0;\n\t                        // 6. Let decimalSepIndex be Call(%StringProto_indexOf%, n, \".\", 0).\n\t                        var decimalSepIndex = _n2.indexOf('.', 0);\n\t                        // 7. If decimalSepIndex > 0, then:\n\t                        if (decimalSepIndex > 0) {\n\t                            // a. Let integer be the substring of n from position 0, inclusive, to position decimalSepIndex, exclusive.\n\t                            integer = _n2.substring(0, decimalSepIndex);\n\t                            // a. Let fraction be the substring of n from position decimalSepIndex, exclusive, to the end of n.\n\t                            fraction = _n2.substring(decimalSepIndex + 1, decimalSepIndex.length);\n\t                        }\n\t                        // 8. Else:\n\t                        else {\n\t                                // a. Let integer be n.\n\t                                integer = _n2;\n\t                                // a. Let fraction be undefined.\n\t                                fraction = undefined;\n\t                            }\n\t                        // 9. If the value of the numberFormat.[[useGrouping]] is true,\n\t                        if (internal['[[useGrouping]]'] === true) {\n\t                            // a. Let groupSepSymbol be the ILND String representing the grouping separator.\n\t                            var groupSepSymbol = ild.group;\n\t                            // a. Let groups be a List whose elements are, in left to right order, the substrings defined by ILND set of locations within the integer.\n\t                            var groups = [];\n\t                            // ----> implementation:\n\t                            // Primary group represents the group closest to the decimal\n\t                            var pgSize = data.patterns.primaryGroupSize || 3;\n\t                            // Secondary group is every other group\n\t                            var sgSize = data.patterns.secondaryGroupSize || pgSize;\n\t                            // Group only if necessary\n\t                            if (integer.length > pgSize) {\n\t                                // Index of the primary grouping separator\n\t                                var end = integer.length - pgSize;\n\t                                // Starting index for our loop\n\t                                var idx = end % sgSize;\n\t                                var start = integer.slice(0, idx);\n\t                                if (start.length) arrPush.call(groups, start);\n\t                                // Loop to separate into secondary grouping digits\n\t                                while (idx < end) {\n\t                                    arrPush.call(groups, integer.slice(idx, idx + sgSize));\n\t                                    idx += sgSize;\n\t                                }\n\t                                // Add the primary grouping digits\n\t                                arrPush.call(groups, integer.slice(end));\n\t                            } else {\n\t                                arrPush.call(groups, integer);\n\t                            }\n\t                            // a. Assert: The number of elements in groups List is greater than 0.\n\t                            if (groups.length === 0) throw new Error();\n\t                            // a. Repeat, while groups List is not empty:\n\t                            while (groups.length) {\n\t                                // i. Remove the first element from groups and let integerGroup be the value of that element.\n\t                                var integerGroup = arrShift.call(groups);\n\t                                // ii. Add new part record { [[type]]: \"integer\", [[value]]: integerGroup } as a new element of the list result.\n\t                                arrPush.call(result, { '[[type]]': 'integer', '[[value]]': integerGroup });\n\t                                // iii. If groups List is not empty, then:\n\t                                if (groups.length) {\n\t                                    // 1. Add new part record { [[type]]: \"group\", [[value]]: groupSepSymbol } as a new element of the list result.\n\t                                    arrPush.call(result, { '[[type]]': 'group', '[[value]]': groupSepSymbol });\n\t                                }\n\t                            }\n\t                        }\n\t                        // 10. Else,\n\t                        else {\n\t                                // a. Add new part record { [[type]]: \"integer\", [[value]]: integer } as a new element of the list result.\n\t                                arrPush.call(result, { '[[type]]': 'integer', '[[value]]': integer });\n\t                            }\n\t                        // 11. If fraction is not undefined, then:\n\t                        if (fraction !== undefined) {\n\t                            // a. Let decimalSepSymbol be the ILND String representing the decimal separator.\n\t                            var decimalSepSymbol = ild.decimal;\n\t                            // a. Add new part record { [[type]]: \"decimal\", [[value]]: decimalSepSymbol } as a new element of the list result.\n\t                            arrPush.call(result, { '[[type]]': 'decimal', '[[value]]': decimalSepSymbol });\n\t                            // a. Add new part record { [[type]]: \"fraction\", [[value]]: fraction } as a new element of the list result.\n\t                            arrPush.call(result, { '[[type]]': 'fraction', '[[value]]': fraction });\n\t                        }\n\t                    }\n\t        }\n\t        // a. Else if p is equal \"plusSign\", then:\n\t        else if (p === \"plusSign\") {\n\t                // i. Let plusSignSymbol be the ILND String representing the plus sign.\n\t                var plusSignSymbol = ild.plusSign;\n\t                // ii. Add new part record { [[type]]: \"plusSign\", [[value]]: plusSignSymbol } as a new element of the list result.\n\t                arrPush.call(result, { '[[type]]': 'plusSign', '[[value]]': plusSignSymbol });\n\t            }\n\t            // a. Else if p is equal \"minusSign\", then:\n\t            else if (p === \"minusSign\") {\n\t                    // i. Let minusSignSymbol be the ILND String representing the minus sign.\n\t                    var minusSignSymbol = ild.minusSign;\n\t                    // ii. Add new part record { [[type]]: \"minusSign\", [[value]]: minusSignSymbol } as a new element of the list result.\n\t                    arrPush.call(result, { '[[type]]': 'minusSign', '[[value]]': minusSignSymbol });\n\t                }\n\t                // a. Else if p is equal \"percentSign\" and numberFormat.[[style]] is \"percent\", then:\n\t                else if (p === \"percentSign\" && internal['[[style]]'] === \"percent\") {\n\t                        // i. Let percentSignSymbol be the ILND String representing the percent sign.\n\t                        var percentSignSymbol = ild.percentSign;\n\t                        // ii. Add new part record { [[type]]: \"percentSign\", [[value]]: percentSignSymbol } as a new element of the list result.\n\t                        arrPush.call(result, { '[[type]]': 'literal', '[[value]]': percentSignSymbol });\n\t                    }\n\t                    // a. Else if p is equal \"currency\" and numberFormat.[[style]] is \"currency\", then:\n\t                    else if (p === \"currency\" && internal['[[style]]'] === \"currency\") {\n\t                            // i. Let currency be the value of numberFormat.[[currency]].\n\t                            var currency = internal['[[currency]]'];\n\t\n\t                            var cd = void 0;\n\t\n\t                            // ii. If numberFormat.[[currencyDisplay]] is \"code\", then\n\t                            if (internal['[[currencyDisplay]]'] === \"code\") {\n\t                                // 1. Let cd be currency.\n\t                                cd = currency;\n\t                            }\n\t                            // iii. Else if numberFormat.[[currencyDisplay]] is \"symbol\", then\n\t                            else if (internal['[[currencyDisplay]]'] === \"symbol\") {\n\t                                    // 1. Let cd be an ILD string representing currency in short form. If the implementation does not have such a representation of currency, use currency itself.\n\t                                    cd = data.currencies[currency] || currency;\n\t                                }\n\t                                // iv. Else if numberFormat.[[currencyDisplay]] is \"name\", then\n\t                                else if (internal['[[currencyDisplay]]'] === \"name\") {\n\t                                        // 1. Let cd be an ILD string representing currency in long form. If the implementation does not have such a representation of currency, then use currency itself.\n\t                                        cd = currency;\n\t                                    }\n\t                            // v. Add new part record { [[type]]: \"currency\", [[value]]: cd } as a new element of the list result.\n\t                            arrPush.call(result, { '[[type]]': 'currency', '[[value]]': cd });\n\t                        }\n\t                        // a. Else,\n\t                        else {\n\t                                // i. Let literal be the substring of pattern from position beginIndex, inclusive, to position endIndex, inclusive.\n\t                                var _literal = pattern.substring(beginIndex, endIndex);\n\t                                // ii. Add new part record { [[type]]: \"literal\", [[value]]: literal } as a new element of the list result.\n\t                                arrPush.call(result, { '[[type]]': 'literal', '[[value]]': _literal });\n\t                            }\n\t        // a. Set nextIndex to endIndex + 1.\n\t        nextIndex = endIndex + 1;\n\t        // a. Set beginIndex to Call(%StringProto_indexOf%, pattern, \"{\", nextIndex)\n\t        beginIndex = pattern.indexOf('{', nextIndex);\n\t    }\n\t    // 9. If nextIndex is less than length, then:\n\t    if (nextIndex < length) {\n\t        // a. Let literal be the substring of pattern from position nextIndex, inclusive, to position length, exclusive.\n\t        var _literal2 = pattern.substring(nextIndex, length);\n\t        // a. Add new part record { [[type]]: \"literal\", [[value]]: literal } as a new element of the list result.\n\t        arrPush.call(result, { '[[type]]': 'literal', '[[value]]': _literal2 });\n\t    }\n\t    // 10. Return result.\n\t    return result;\n\t}\n\t\n\t/*\n\t * @spec[stasm/ecma402/number-format-to-parts/spec/numberformat.html]\n\t * @clause[sec-formatnumber]\n\t */\n\tfunction FormatNumber(numberFormat, x) {\n\t    // 1. Let parts be ? PartitionNumberPattern(numberFormat, x).\n\t    var parts = PartitionNumberPattern(numberFormat, x);\n\t    // 2. Let result be an empty String.\n\t    var result = '';\n\t    // 3. For each part in parts, do:\n\t    for (var i = 0; parts.length > i; i++) {\n\t        var part = parts[i];\n\t        // a. Set result to a String value produced by concatenating result and part.[[value]].\n\t        result += part['[[value]]'];\n\t    }\n\t    // 4. Return result.\n\t    return result;\n\t}\n\t\n\t/**\n\t * When the ToRawPrecision abstract operation is called with arguments x (which\n\t * must be a finite non-negative number), minPrecision, and maxPrecision (both\n\t * must be integers between 1 and 21) the following steps are taken:\n\t */\n\tfunction ToRawPrecision(x, minPrecision, maxPrecision) {\n\t    // 1. Let p be maxPrecision.\n\t    var p = maxPrecision;\n\t\n\t    var m = void 0,\n\t        e = void 0;\n\t\n\t    // 2. If x = 0, then\n\t    if (x === 0) {\n\t        // a. Let m be the String consisting of p occurrences of the character \"0\".\n\t        m = arrJoin.call(Array(p + 1), '0');\n\t        // b. Let e be 0.\n\t        e = 0;\n\t    }\n\t    // 3. Else\n\t    else {\n\t            // a. Let e and n be integers such that 10  n < 10 and for which the\n\t            //    exact mathematical value of n  10  x is as close to zero as\n\t            //    possible. If there are two such sets of e and n, pick the e and n for\n\t            //    which n  10 is larger.\n\t            e = log10Floor(Math.abs(x));\n\t\n\t            // Easier to get to m from here\n\t            var f = Math.round(Math.exp(Math.abs(e - p + 1) * Math.LN10));\n\t\n\t            // b. Let m be the String consisting of the digits of the decimal\n\t            //    representation of n (in order, with no leading zeroes)\n\t            m = String(Math.round(e - p + 1 < 0 ? x * f : x / f));\n\t        }\n\t\n\t    // 4. If e  p, then\n\t    if (e >= p)\n\t        // a. Return the concatenation of m and e-p+1 occurrences of the character \"0\".\n\t        return m + arrJoin.call(Array(e - p + 1 + 1), '0');\n\t\n\t        // 5. If e = p-1, then\n\t    else if (e === p - 1)\n\t            // a. Return m.\n\t            return m;\n\t\n\t            // 6. If e  0, then\n\t        else if (e >= 0)\n\t                // a. Let m be the concatenation of the first e+1 characters of m, the character\n\t                //    \".\", and the remaining p(e+1) characters of m.\n\t                m = m.slice(0, e + 1) + '.' + m.slice(e + 1);\n\t\n\t                // 7. If e < 0, then\n\t            else if (e < 0)\n\t                    // a. Let m be the concatenation of the String \"0.\", (e+1) occurrences of the\n\t                    //    character \"0\", and the string m.\n\t                    m = '0.' + arrJoin.call(Array(-(e + 1) + 1), '0') + m;\n\t\n\t    // 8. If m contains the character \".\", and maxPrecision > minPrecision, then\n\t    if (m.indexOf(\".\") >= 0 && maxPrecision > minPrecision) {\n\t        // a. Let cut be maxPrecision  minPrecision.\n\t        var cut = maxPrecision - minPrecision;\n\t\n\t        // b. Repeat while cut > 0 and the last character of m is \"0\":\n\t        while (cut > 0 && m.charAt(m.length - 1) === '0') {\n\t            //  i. Remove the last character from m.\n\t            m = m.slice(0, -1);\n\t\n\t            //  ii. Decrease cut by 1.\n\t            cut--;\n\t        }\n\t\n\t        // c. If the last character of m is \".\", then\n\t        if (m.charAt(m.length - 1) === '.')\n\t            //    i. Remove the last character from m.\n\t            m = m.slice(0, -1);\n\t    }\n\t    // 9. Return m.\n\t    return m;\n\t}\n\t\n\t/**\n\t * @spec[tc39/ecma402/master/spec/numberformat.html]\n\t * @clause[sec-torawfixed]\n\t * When the ToRawFixed abstract operation is called with arguments x (which must\n\t * be a finite non-negative number), minInteger (which must be an integer between\n\t * 1 and 21), minFraction, and maxFraction (which must be integers between 0 and\n\t * 20) the following steps are taken:\n\t */\n\tfunction ToRawFixed(x, minInteger, minFraction, maxFraction) {\n\t    // 1. Let f be maxFraction.\n\t    var f = maxFraction;\n\t    // 2. Let n be an integer for which the exact mathematical value of n  10f  x is as close to zero as possible. If there are two such n, pick the larger n.\n\t    var n = Math.pow(10, f) * x; // diverging...\n\t    // 3. If n = 0, let m be the String \"0\". Otherwise, let m be the String consisting of the digits of the decimal representation of n (in order, with no leading zeroes).\n\t    var m = n === 0 ? \"0\" : n.toFixed(0); // divering...\n\t\n\t    {\n\t        // this diversion is needed to take into consideration big numbers, e.g.:\n\t        // 1.2344501e+37 -> 12344501000000000000000000000000000000\n\t        var idx = void 0;\n\t        var exp = (idx = m.indexOf('e')) > -1 ? m.slice(idx + 1) : 0;\n\t        if (exp) {\n\t            m = m.slice(0, idx).replace('.', '');\n\t            m += arrJoin.call(Array(exp - (m.length - 1) + 1), '0');\n\t        }\n\t    }\n\t\n\t    var int = void 0;\n\t    // 4. If f  0, then\n\t    if (f !== 0) {\n\t        // a. Let k be the number of characters in m.\n\t        var k = m.length;\n\t        // a. If k  f, then\n\t        if (k <= f) {\n\t            // i. Let z be the String consisting of f+1k occurrences of the character \"0\".\n\t            var z = arrJoin.call(Array(f + 1 - k + 1), '0');\n\t            // ii. Let m be the concatenation of Strings z and m.\n\t            m = z + m;\n\t            // iii. Let k be f+1.\n\t            k = f + 1;\n\t        }\n\t        // a. Let a be the first kf characters of m, and let b be the remaining f characters of m.\n\t        var a = m.substring(0, k - f),\n\t            b = m.substring(k - f, m.length);\n\t        // a. Let m be the concatenation of the three Strings a, \".\", and b.\n\t        m = a + \".\" + b;\n\t        // a. Let int be the number of characters in a.\n\t        int = a.length;\n\t    }\n\t    // 5. Else, let int be the number of characters in m.\n\t    else int = m.length;\n\t    // 6. Let cut be maxFraction  minFraction.\n\t    var cut = maxFraction - minFraction;\n\t    // 7. Repeat while cut > 0 and the last character of m is \"0\":\n\t    while (cut > 0 && m.slice(-1) === \"0\") {\n\t        // a. Remove the last character from m.\n\t        m = m.slice(0, -1);\n\t        // a. Decrease cut by 1.\n\t        cut--;\n\t    }\n\t    // 8. If the last character of m is \".\", then\n\t    if (m.slice(-1) === \".\") {\n\t        // a. Remove the last character from m.\n\t        m = m.slice(0, -1);\n\t    }\n\t    // 9. If int < minInteger, then\n\t    if (int < minInteger) {\n\t        // a. Let z be the String consisting of minIntegerint occurrences of the character \"0\".\n\t        var _z = arrJoin.call(Array(minInteger - int + 1), '0');\n\t        // a. Let m be the concatenation of Strings z and m.\n\t        m = _z + m;\n\t    }\n\t    // 10. Return m.\n\t    return m;\n\t}\n\t\n\t// Sect 11.3.2 Table 2, Numbering systems\n\t// ======================================\n\tvar numSys = {\n\t    arab: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n\t    arabext: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n\t    bali: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n\t    beng: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n\t    deva: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n\t    fullwide: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n\t    gujr: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n\t    guru: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n\t    hanidec: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n\t    khmr: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n\t    knda: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n\t    laoo: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n\t    latn: [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"],\n\t    limb: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n\t    mlym: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n\t    mong: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n\t    mymr: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n\t    orya: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n\t    tamldec: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n\t    telu: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n\t    thai: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n\t    tibt: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"]\n\t};\n\t\n\t/**\n\t * This function provides access to the locale and formatting options computed\n\t * during initialization of the object.\n\t *\n\t * The function returns a new object whose properties and attributes are set as\n\t * if constructed by an object literal assigning to each of the following\n\t * properties the value of the corresponding internal property of this\n\t * NumberFormat object (see 11.4): locale, numberingSystem, style, currency,\n\t * currencyDisplay, minimumIntegerDigits, minimumFractionDigits,\n\t * maximumFractionDigits, minimumSignificantDigits, maximumSignificantDigits, and\n\t * useGrouping. Properties whose corresponding internal properties are not present\n\t * are not assigned.\n\t */\n\t/* 11.3.3 */defineProperty(Intl.NumberFormat.prototype, 'resolvedOptions', {\n\t    configurable: true,\n\t    writable: true,\n\t    value: function value() {\n\t        var prop = void 0,\n\t            descs = new Record(),\n\t            props = ['locale', 'numberingSystem', 'style', 'currency', 'currencyDisplay', 'minimumIntegerDigits', 'minimumFractionDigits', 'maximumFractionDigits', 'minimumSignificantDigits', 'maximumSignificantDigits', 'useGrouping'],\n\t            internal = this !== null && babelHelpers[\"typeof\"](this) === 'object' && getInternalProperties(this);\n\t\n\t        // Satisfy test 11.3_b\n\t        if (!internal || !internal['[[initializedNumberFormat]]']) throw new TypeError('`this` value for resolvedOptions() is not an initialized Intl.NumberFormat object.');\n\t\n\t        for (var i = 0, max = props.length; i < max; i++) {\n\t            if (hop.call(internal, prop = '[[' + props[i] + ']]')) descs[props[i]] = { value: internal[prop], writable: true, configurable: true, enumerable: true };\n\t        }\n\t\n\t        return objCreate({}, descs);\n\t    }\n\t});\n\t\n\t/* jslint esnext: true */\n\t\n\t// Match these datetime components in a CLDR pattern, except those in single quotes\n\tvar expDTComponents = /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvVxX]{1,4})(?=([^']*'[^']*')*[^']*$)/g;\n\t// trim patterns after transformations\n\tvar expPatternTrimmer = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n\t// Skip over patterns with these datetime components because we don't have data\n\t// to back them up:\n\t// timezone, weekday, amoung others\n\tvar unwantedDTCs = /[rqQASjJgwWIQq]/; // xXVO were removed from this list in favor of computing matches with timeZoneName values but printing as empty string\n\t\n\tvar dtKeys = [\"weekday\", \"era\", \"year\", \"month\", \"day\", \"weekday\", \"quarter\"];\n\tvar tmKeys = [\"hour\", \"minute\", \"second\", \"hour12\", \"timeZoneName\"];\n\t\n\tfunction isDateFormatOnly(obj) {\n\t    for (var i = 0; i < tmKeys.length; i += 1) {\n\t        if (obj.hasOwnProperty(tmKeys[i])) {\n\t            return false;\n\t        }\n\t    }\n\t    return true;\n\t}\n\t\n\tfunction isTimeFormatOnly(obj) {\n\t    for (var i = 0; i < dtKeys.length; i += 1) {\n\t        if (obj.hasOwnProperty(dtKeys[i])) {\n\t            return false;\n\t        }\n\t    }\n\t    return true;\n\t}\n\t\n\tfunction joinDateAndTimeFormats(dateFormatObj, timeFormatObj) {\n\t    var o = { _: {} };\n\t    for (var i = 0; i < dtKeys.length; i += 1) {\n\t        if (dateFormatObj[dtKeys[i]]) {\n\t            o[dtKeys[i]] = dateFormatObj[dtKeys[i]];\n\t        }\n\t        if (dateFormatObj._[dtKeys[i]]) {\n\t            o._[dtKeys[i]] = dateFormatObj._[dtKeys[i]];\n\t        }\n\t    }\n\t    for (var j = 0; j < tmKeys.length; j += 1) {\n\t        if (timeFormatObj[tmKeys[j]]) {\n\t            o[tmKeys[j]] = timeFormatObj[tmKeys[j]];\n\t        }\n\t        if (timeFormatObj._[tmKeys[j]]) {\n\t            o._[tmKeys[j]] = timeFormatObj._[tmKeys[j]];\n\t        }\n\t    }\n\t    return o;\n\t}\n\t\n\tfunction computeFinalPatterns(formatObj) {\n\t    // From http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns:\n\t    //  'In patterns, two single quotes represents a literal single quote, either\n\t    //   inside or outside single quotes. Text within single quotes is not\n\t    //   interpreted in any way (except for two adjacent single quotes).'\n\t    formatObj.pattern12 = formatObj.extendedPattern.replace(/'([^']*)'/g, function ($0, literal) {\n\t        return literal ? literal : \"'\";\n\t    });\n\t\n\t    // pattern 12 is always the default. we can produce the 24 by removing {ampm}\n\t    formatObj.pattern = formatObj.pattern12.replace('{ampm}', '').replace(expPatternTrimmer, '');\n\t    return formatObj;\n\t}\n\t\n\tfunction expDTComponentsMeta($0, formatObj) {\n\t    switch ($0.charAt(0)) {\n\t        // --- Era\n\t        case 'G':\n\t            formatObj.era = ['short', 'short', 'short', 'long', 'narrow'][$0.length - 1];\n\t            return '{era}';\n\t\n\t        // --- Year\n\t        case 'y':\n\t        case 'Y':\n\t        case 'u':\n\t        case 'U':\n\t        case 'r':\n\t            formatObj.year = $0.length === 2 ? '2-digit' : 'numeric';\n\t            return '{year}';\n\t\n\t        // --- Quarter (not supported in this polyfill)\n\t        case 'Q':\n\t        case 'q':\n\t            formatObj.quarter = ['numeric', '2-digit', 'short', 'long', 'narrow'][$0.length - 1];\n\t            return '{quarter}';\n\t\n\t        // --- Month\n\t        case 'M':\n\t        case 'L':\n\t            formatObj.month = ['numeric', '2-digit', 'short', 'long', 'narrow'][$0.length - 1];\n\t            return '{month}';\n\t\n\t        // --- Week (not supported in this polyfill)\n\t        case 'w':\n\t            // week of the year\n\t            formatObj.week = $0.length === 2 ? '2-digit' : 'numeric';\n\t            return '{weekday}';\n\t        case 'W':\n\t            // week of the month\n\t            formatObj.week = 'numeric';\n\t            return '{weekday}';\n\t\n\t        // --- Day\n\t        case 'd':\n\t            // day of the month\n\t            formatObj.day = $0.length === 2 ? '2-digit' : 'numeric';\n\t            return '{day}';\n\t        case 'D': // day of the year\n\t        case 'F': // day of the week\n\t        case 'g':\n\t            // 1..n: Modified Julian day\n\t            formatObj.day = 'numeric';\n\t            return '{day}';\n\t\n\t        // --- Week Day\n\t        case 'E':\n\t            // day of the week\n\t            formatObj.weekday = ['short', 'short', 'short', 'long', 'narrow', 'short'][$0.length - 1];\n\t            return '{weekday}';\n\t        case 'e':\n\t            // local day of the week\n\t            formatObj.weekday = ['numeric', '2-digit', 'short', 'long', 'narrow', 'short'][$0.length - 1];\n\t            return '{weekday}';\n\t        case 'c':\n\t            // stand alone local day of the week\n\t            formatObj.weekday = ['numeric', undefined, 'short', 'long', 'narrow', 'short'][$0.length - 1];\n\t            return '{weekday}';\n\t\n\t        // --- Period\n\t        case 'a': // AM, PM\n\t        case 'b': // am, pm, noon, midnight\n\t        case 'B':\n\t            // flexible day periods\n\t            formatObj.hour12 = true;\n\t            return '{ampm}';\n\t\n\t        // --- Hour\n\t        case 'h':\n\t        case 'H':\n\t            formatObj.hour = $0.length === 2 ? '2-digit' : 'numeric';\n\t            return '{hour}';\n\t        case 'k':\n\t        case 'K':\n\t            formatObj.hour12 = true; // 12-hour-cycle time formats (using h or K)\n\t            formatObj.hour = $0.length === 2 ? '2-digit' : 'numeric';\n\t            return '{hour}';\n\t\n\t        // --- Minute\n\t        case 'm':\n\t            formatObj.minute = $0.length === 2 ? '2-digit' : 'numeric';\n\t            return '{minute}';\n\t\n\t        // --- Second\n\t        case 's':\n\t            formatObj.second = $0.length === 2 ? '2-digit' : 'numeric';\n\t            return '{second}';\n\t        case 'S':\n\t        case 'A':\n\t            formatObj.second = 'numeric';\n\t            return '{second}';\n\t\n\t        // --- Timezone\n\t        case 'z': // 1..3, 4: specific non-location format\n\t        case 'Z': // 1..3, 4, 5: The ISO8601 varios formats\n\t        case 'O': // 1, 4: miliseconds in day short, long\n\t        case 'v': // 1, 4: generic non-location format\n\t        case 'V': // 1, 2, 3, 4: time zone ID or city\n\t        case 'X': // 1, 2, 3, 4: The ISO8601 varios formats\n\t        case 'x':\n\t            // 1, 2, 3, 4: The ISO8601 varios formats\n\t            // this polyfill only supports much, for now, we are just doing something dummy\n\t            formatObj.timeZoneName = $0.length < 4 ? 'short' : 'long';\n\t            return '{timeZoneName}';\n\t    }\n\t}\n\t\n\t/**\n\t * Converts the CLDR availableFormats into the objects and patterns required by\n\t * the ECMAScript Internationalization API specification.\n\t */\n\tfunction createDateTimeFormat(skeleton, pattern) {\n\t    // we ignore certain patterns that are unsupported to avoid this expensive op.\n\t    if (unwantedDTCs.test(pattern)) return undefined;\n\t\n\t    var formatObj = {\n\t        originalPattern: pattern,\n\t        _: {}\n\t    };\n\t\n\t    // Replace the pattern string with the one required by the specification, whilst\n\t    // at the same time evaluating it for the subsets and formats\n\t    formatObj.extendedPattern = pattern.replace(expDTComponents, function ($0) {\n\t        // See which symbol we're dealing with\n\t        return expDTComponentsMeta($0, formatObj._);\n\t    });\n\t\n\t    // Match the skeleton string with the one required by the specification\n\t    // this implementation is based on the Date Field Symbol Table:\n\t    // http://unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table\n\t    // Note: we are adding extra data to the formatObject even though this polyfill\n\t    //       might not support it.\n\t    skeleton.replace(expDTComponents, function ($0) {\n\t        // See which symbol we're dealing with\n\t        return expDTComponentsMeta($0, formatObj);\n\t    });\n\t\n\t    return computeFinalPatterns(formatObj);\n\t}\n\t\n\t/**\n\t * Processes DateTime formats from CLDR to an easier-to-parse format.\n\t * the result of this operation should be cached the first time a particular\n\t * calendar is analyzed.\n\t *\n\t * The specification requires we support at least the following subsets of\n\t * date/time components:\n\t *\n\t *   - 'weekday', 'year', 'month', 'day', 'hour', 'minute', 'second'\n\t *   - 'weekday', 'year', 'month', 'day'\n\t *   - 'year', 'month', 'day'\n\t *   - 'year', 'month'\n\t *   - 'month', 'day'\n\t *   - 'hour', 'minute', 'second'\n\t *   - 'hour', 'minute'\n\t *\n\t * We need to cherry pick at least these subsets from the CLDR data and convert\n\t * them into the pattern objects used in the ECMA-402 API.\n\t */\n\tfunction createDateTimeFormats(formats) {\n\t    var availableFormats = formats.availableFormats;\n\t    var timeFormats = formats.timeFormats;\n\t    var dateFormats = formats.dateFormats;\n\t    var result = [];\n\t    var skeleton = void 0,\n\t        pattern = void 0,\n\t        computed = void 0,\n\t        i = void 0,\n\t        j = void 0;\n\t    var timeRelatedFormats = [];\n\t    var dateRelatedFormats = [];\n\t\n\t    // Map available (custom) formats into a pattern for createDateTimeFormats\n\t    for (skeleton in availableFormats) {\n\t        if (availableFormats.hasOwnProperty(skeleton)) {\n\t            pattern = availableFormats[skeleton];\n\t            computed = createDateTimeFormat(skeleton, pattern);\n\t            if (computed) {\n\t                result.push(computed);\n\t                // in some cases, the format is only displaying date specific props\n\t                // or time specific props, in which case we need to also produce the\n\t                // combined formats.\n\t                if (isDateFormatOnly(computed)) {\n\t                    dateRelatedFormats.push(computed);\n\t                } else if (isTimeFormatOnly(computed)) {\n\t                    timeRelatedFormats.push(computed);\n\t                }\n\t            }\n\t        }\n\t    }\n\t\n\t    // Map time formats into a pattern for createDateTimeFormats\n\t    for (skeleton in timeFormats) {\n\t        if (timeFormats.hasOwnProperty(skeleton)) {\n\t            pattern = timeFormats[skeleton];\n\t            computed = createDateTimeFormat(skeleton, pattern);\n\t            if (computed) {\n\t                result.push(computed);\n\t                timeRelatedFormats.push(computed);\n\t            }\n\t        }\n\t    }\n\t\n\t    // Map date formats into a pattern for createDateTimeFormats\n\t    for (skeleton in dateFormats) {\n\t        if (dateFormats.hasOwnProperty(skeleton)) {\n\t            pattern = dateFormats[skeleton];\n\t            computed = createDateTimeFormat(skeleton, pattern);\n\t            if (computed) {\n\t                result.push(computed);\n\t                dateRelatedFormats.push(computed);\n\t            }\n\t        }\n\t    }\n\t\n\t    // combine custom time and custom date formats when they are orthogonals to complete the\n\t    // formats supported by CLDR.\n\t    // This Algo is based on section \"Missing Skeleton Fields\" from:\n\t    // http://unicode.org/reports/tr35/tr35-dates.html#availableFormats_appendItems\n\t    for (i = 0; i < timeRelatedFormats.length; i += 1) {\n\t        for (j = 0; j < dateRelatedFormats.length; j += 1) {\n\t            if (dateRelatedFormats[j].month === 'long') {\n\t                pattern = dateRelatedFormats[j].weekday ? formats.full : formats.long;\n\t            } else if (dateRelatedFormats[j].month === 'short') {\n\t                pattern = formats.medium;\n\t            } else {\n\t                pattern = formats.short;\n\t            }\n\t            computed = joinDateAndTimeFormats(dateRelatedFormats[j], timeRelatedFormats[i]);\n\t            computed.originalPattern = pattern;\n\t            computed.extendedPattern = pattern.replace('{0}', timeRelatedFormats[i].extendedPattern).replace('{1}', dateRelatedFormats[j].extendedPattern).replace(/^[,\\s]+|[,\\s]+$/gi, '');\n\t            result.push(computeFinalPatterns(computed));\n\t        }\n\t    }\n\t\n\t    return result;\n\t}\n\t\n\t// An object map of date component keys, saves using a regex later\n\tvar dateWidths = objCreate(null, { narrow: {}, short: {}, long: {} });\n\t\n\t/**\n\t * Returns a string for a date component, resolved using multiple inheritance as specified\n\t * as specified in the Unicode Technical Standard 35.\n\t */\n\tfunction resolveDateString(data, ca, component, width, key) {\n\t    // From http://www.unicode.org/reports/tr35/tr35.html#Multiple_Inheritance:\n\t    // 'In clearly specified instances, resources may inherit from within the same locale.\n\t    //  For example, ... the Buddhist calendar inherits from the Gregorian calendar.'\n\t    var obj = data[ca] && data[ca][component] ? data[ca][component] : data.gregory[component],\n\t\n\t\n\t    // \"sideways\" inheritance resolves strings when a key doesn't exist\n\t    alts = {\n\t        narrow: ['short', 'long'],\n\t        short: ['long', 'narrow'],\n\t        long: ['short', 'narrow']\n\t    },\n\t\n\t\n\t    //\n\t    resolved = hop.call(obj, width) ? obj[width] : hop.call(obj, alts[width][0]) ? obj[alts[width][0]] : obj[alts[width][1]];\n\t\n\t    // `key` wouldn't be specified for components 'dayPeriods'\n\t    return key !== null ? resolved[key] : resolved;\n\t}\n\t\n\t// Define the DateTimeFormat constructor internally so it cannot be tainted\n\tfunction DateTimeFormatConstructor() {\n\t    var locales = arguments[0];\n\t    var options = arguments[1];\n\t\n\t    if (!this || this === Intl) {\n\t        return new Intl.DateTimeFormat(locales, options);\n\t    }\n\t    return InitializeDateTimeFormat(toObject(this), locales, options);\n\t}\n\t\n\tdefineProperty(Intl, 'DateTimeFormat', {\n\t    configurable: true,\n\t    writable: true,\n\t    value: DateTimeFormatConstructor\n\t});\n\t\n\t// Must explicitly set prototypes as unwritable\n\tdefineProperty(DateTimeFormatConstructor, 'prototype', {\n\t    writable: false\n\t});\n\t\n\t/**\n\t * The abstract operation InitializeDateTimeFormat accepts the arguments dateTimeFormat\n\t * (which must be an object), locales, and options. It initializes dateTimeFormat as a\n\t * DateTimeFormat object.\n\t */\n\tfunction /* 12.1.1.1 */InitializeDateTimeFormat(dateTimeFormat, locales, options) {\n\t    // This will be a internal properties object if we're not already initialized\n\t    var internal = getInternalProperties(dateTimeFormat);\n\t\n\t    // Create an object whose props can be used to restore the values of RegExp props\n\t    var regexpState = createRegExpRestore();\n\t\n\t    // 1. If dateTimeFormat has an [[initializedIntlObject]] internal property with\n\t    //    value true, throw a TypeError exception.\n\t    if (internal['[[initializedIntlObject]]'] === true) throw new TypeError('`this` object has already been initialized as an Intl object');\n\t\n\t    // Need this to access the `internal` object\n\t    defineProperty(dateTimeFormat, '__getInternalProperties', {\n\t        value: function value() {\n\t            // NOTE: Non-standard, for internal use only\n\t            if (arguments[0] === secret) return internal;\n\t        }\n\t    });\n\t\n\t    // 2. Set the [[initializedIntlObject]] internal property of numberFormat to true.\n\t    internal['[[initializedIntlObject]]'] = true;\n\t\n\t    // 3. Let requestedLocales be the result of calling the CanonicalizeLocaleList\n\t    //    abstract operation (defined in 9.2.1) with argument locales.\n\t    var requestedLocales = CanonicalizeLocaleList(locales);\n\t\n\t    // 4. Let options be the result of calling the ToDateTimeOptions abstract\n\t    //    operation (defined below) with arguments options, \"any\", and \"date\".\n\t    options = ToDateTimeOptions(options, 'any', 'date');\n\t\n\t    // 5. Let opt be a new Record.\n\t    var opt = new Record();\n\t\n\t    // 6. Let matcher be the result of calling the GetOption abstract operation\n\t    //    (defined in 9.2.9) with arguments options, \"localeMatcher\", \"string\", a List\n\t    //    containing the two String values \"lookup\" and \"best fit\", and \"best fit\".\n\t    var matcher = GetOption(options, 'localeMatcher', 'string', new List('lookup', 'best fit'), 'best fit');\n\t\n\t    // 7. Set opt.[[localeMatcher]] to matcher.\n\t    opt['[[localeMatcher]]'] = matcher;\n\t\n\t    // 8. Let DateTimeFormat be the standard built-in object that is the initial\n\t    //    value of Intl.DateTimeFormat.\n\t    var DateTimeFormat = internals.DateTimeFormat; // This is what we *really* need\n\t\n\t    // 9. Let localeData be the value of the [[localeData]] internal property of\n\t    //    DateTimeFormat.\n\t    var localeData = DateTimeFormat['[[localeData]]'];\n\t\n\t    // 10. Let r be the result of calling the ResolveLocale abstract operation\n\t    //     (defined in 9.2.5) with the [[availableLocales]] internal property of\n\t    //      DateTimeFormat, requestedLocales, opt, the [[relevantExtensionKeys]]\n\t    //      internal property of DateTimeFormat, and localeData.\n\t    var r = ResolveLocale(DateTimeFormat['[[availableLocales]]'], requestedLocales, opt, DateTimeFormat['[[relevantExtensionKeys]]'], localeData);\n\t\n\t    // 11. Set the [[locale]] internal property of dateTimeFormat to the value of\n\t    //     r.[[locale]].\n\t    internal['[[locale]]'] = r['[[locale]]'];\n\t\n\t    // 12. Set the [[calendar]] internal property of dateTimeFormat to the value of\n\t    //     r.[[ca]].\n\t    internal['[[calendar]]'] = r['[[ca]]'];\n\t\n\t    // 13. Set the [[numberingSystem]] internal property of dateTimeFormat to the value of\n\t    //     r.[[nu]].\n\t    internal['[[numberingSystem]]'] = r['[[nu]]'];\n\t\n\t    // The specification doesn't tell us to do this, but it's helpful later on\n\t    internal['[[dataLocale]]'] = r['[[dataLocale]]'];\n\t\n\t    // 14. Let dataLocale be the value of r.[[dataLocale]].\n\t    var dataLocale = r['[[dataLocale]]'];\n\t\n\t    // 15. Let tz be the result of calling the [[Get]] internal method of options with\n\t    //     argument \"timeZone\".\n\t    var tz = options.timeZone;\n\t\n\t    // 16. If tz is not undefined, then\n\t    if (tz !== undefined) {\n\t        // a. Let tz be ToString(tz).\n\t        // b. Convert tz to upper case as described in 6.1.\n\t        //    NOTE: If an implementation accepts additional time zone values, as permitted\n\t        //          under certain conditions by the Conformance clause, different casing\n\t        //          rules apply.\n\t        tz = toLatinUpperCase(tz);\n\t\n\t        // c. If tz is not \"UTC\", then throw a RangeError exception.\n\t        // ###TODO: accept more time zones###\n\t        if (tz !== 'UTC') throw new RangeError('timeZone is not supported.');\n\t    }\n\t\n\t    // 17. Set the [[timeZone]] internal property of dateTimeFormat to tz.\n\t    internal['[[timeZone]]'] = tz;\n\t\n\t    // 18. Let opt be a new Record.\n\t    opt = new Record();\n\t\n\t    // 19. For each row of Table 3, except the header row, do:\n\t    for (var prop in dateTimeComponents) {\n\t        if (!hop.call(dateTimeComponents, prop)) continue;\n\t\n\t        // 20. Let prop be the name given in the Property column of the row.\n\t        // 21. Let value be the result of calling the GetOption abstract operation,\n\t        //     passing as argument options, the name given in the Property column of the\n\t        //     row, \"string\", a List containing the strings given in the Values column of\n\t        //     the row, and undefined.\n\t        var value = GetOption(options, prop, 'string', dateTimeComponents[prop]);\n\t\n\t        // 22. Set opt.[[<prop>]] to value.\n\t        opt['[[' + prop + ']]'] = value;\n\t    }\n\t\n\t    // Assigned a value below\n\t    var bestFormat = void 0;\n\t\n\t    // 23. Let dataLocaleData be the result of calling the [[Get]] internal method of\n\t    //     localeData with argument dataLocale.\n\t    var dataLocaleData = localeData[dataLocale];\n\t\n\t    // 24. Let formats be the result of calling the [[Get]] internal method of\n\t    //     dataLocaleData with argument \"formats\".\n\t    //     Note: we process the CLDR formats into the spec'd structure\n\t    var formats = ToDateTimeFormats(dataLocaleData.formats);\n\t\n\t    // 25. Let matcher be the result of calling the GetOption abstract operation with\n\t    //     arguments options, \"formatMatcher\", \"string\", a List containing the two String\n\t    //     values \"basic\" and \"best fit\", and \"best fit\".\n\t    matcher = GetOption(options, 'formatMatcher', 'string', new List('basic', 'best fit'), 'best fit');\n\t\n\t    // Optimization: caching the processed formats as a one time operation by\n\t    // replacing the initial structure from localeData\n\t    dataLocaleData.formats = formats;\n\t\n\t    // 26. If matcher is \"basic\", then\n\t    if (matcher === 'basic') {\n\t        // 27. Let bestFormat be the result of calling the BasicFormatMatcher abstract\n\t        //     operation (defined below) with opt and formats.\n\t        bestFormat = BasicFormatMatcher(opt, formats);\n\t\n\t        // 28. Else\n\t    } else {\n\t            {\n\t                // diverging\n\t                var _hr = GetOption(options, 'hour12', 'boolean' /*, undefined, undefined*/);\n\t                opt.hour12 = _hr === undefined ? dataLocaleData.hour12 : _hr;\n\t            }\n\t            // 29. Let bestFormat be the result of calling the BestFitFormatMatcher\n\t            //     abstract operation (defined below) with opt and formats.\n\t            bestFormat = BestFitFormatMatcher(opt, formats);\n\t        }\n\t\n\t    // 30. For each row in Table 3, except the header row, do\n\t    for (var _prop in dateTimeComponents) {\n\t        if (!hop.call(dateTimeComponents, _prop)) continue;\n\t\n\t        // a. Let prop be the name given in the Property column of the row.\n\t        // b. Let pDesc be the result of calling the [[GetOwnProperty]] internal method of\n\t        //    bestFormat with argument prop.\n\t        // c. If pDesc is not undefined, then\n\t        if (hop.call(bestFormat, _prop)) {\n\t            // i. Let p be the result of calling the [[Get]] internal method of bestFormat\n\t            //    with argument prop.\n\t            var p = bestFormat[_prop];\n\t            {\n\t                // diverging\n\t                p = bestFormat._ && hop.call(bestFormat._, _prop) ? bestFormat._[_prop] : p;\n\t            }\n\t\n\t            // ii. Set the [[<prop>]] internal property of dateTimeFormat to p.\n\t            internal['[[' + _prop + ']]'] = p;\n\t        }\n\t    }\n\t\n\t    var pattern = void 0; // Assigned a value below\n\t\n\t    // 31. Let hr12 be the result of calling the GetOption abstract operation with\n\t    //     arguments options, \"hour12\", \"boolean\", undefined, and undefined.\n\t    var hr12 = GetOption(options, 'hour12', 'boolean' /*, undefined, undefined*/);\n\t\n\t    // 32. If dateTimeFormat has an internal property [[hour]], then\n\t    if (internal['[[hour]]']) {\n\t        // a. If hr12 is undefined, then let hr12 be the result of calling the [[Get]]\n\t        //    internal method of dataLocaleData with argument \"hour12\".\n\t        hr12 = hr12 === undefined ? dataLocaleData.hour12 : hr12;\n\t\n\t        // b. Set the [[hour12]] internal property of dateTimeFormat to hr12.\n\t        internal['[[hour12]]'] = hr12;\n\t\n\t        // c. If hr12 is true, then\n\t        if (hr12 === true) {\n\t            // i. Let hourNo0 be the result of calling the [[Get]] internal method of\n\t            //    dataLocaleData with argument \"hourNo0\".\n\t            var hourNo0 = dataLocaleData.hourNo0;\n\t\n\t            // ii. Set the [[hourNo0]] internal property of dateTimeFormat to hourNo0.\n\t            internal['[[hourNo0]]'] = hourNo0;\n\t\n\t            // iii. Let pattern be the result of calling the [[Get]] internal method of\n\t            //      bestFormat with argument \"pattern12\".\n\t            pattern = bestFormat.pattern12;\n\t        }\n\t\n\t        // d. Else\n\t        else\n\t            // i. Let pattern be the result of calling the [[Get]] internal method of\n\t            //    bestFormat with argument \"pattern\".\n\t            pattern = bestFormat.pattern;\n\t    }\n\t\n\t    // 33. Else\n\t    else\n\t        // a. Let pattern be the result of calling the [[Get]] internal method of\n\t        //    bestFormat with argument \"pattern\".\n\t        pattern = bestFormat.pattern;\n\t\n\t    // 34. Set the [[pattern]] internal property of dateTimeFormat to pattern.\n\t    internal['[[pattern]]'] = pattern;\n\t\n\t    // 35. Set the [[boundFormat]] internal property of dateTimeFormat to undefined.\n\t    internal['[[boundFormat]]'] = undefined;\n\t\n\t    // 36. Set the [[initializedDateTimeFormat]] internal property of dateTimeFormat to\n\t    //     true.\n\t    internal['[[initializedDateTimeFormat]]'] = true;\n\t\n\t    // In ES3, we need to pre-bind the format() function\n\t    if (es3) dateTimeFormat.format = GetFormatDateTime.call(dateTimeFormat);\n\t\n\t    // Restore the RegExp properties\n\t    regexpState.exp.test(regexpState.input);\n\t\n\t    // Return the newly initialised object\n\t    return dateTimeFormat;\n\t}\n\t\n\t/**\n\t * Several DateTimeFormat algorithms use values from the following table, which provides\n\t * property names and allowable values for the components of date and time formats:\n\t */\n\tvar dateTimeComponents = {\n\t    weekday: [\"narrow\", \"short\", \"long\"],\n\t    era: [\"narrow\", \"short\", \"long\"],\n\t    year: [\"2-digit\", \"numeric\"],\n\t    month: [\"2-digit\", \"numeric\", \"narrow\", \"short\", \"long\"],\n\t    day: [\"2-digit\", \"numeric\"],\n\t    hour: [\"2-digit\", \"numeric\"],\n\t    minute: [\"2-digit\", \"numeric\"],\n\t    second: [\"2-digit\", \"numeric\"],\n\t    timeZoneName: [\"short\", \"long\"]\n\t};\n\t\n\t/**\n\t * When the ToDateTimeOptions abstract operation is called with arguments options,\n\t * required, and defaults, the following steps are taken:\n\t */\n\tfunction ToDateTimeFormats(formats) {\n\t    if (Object.prototype.toString.call(formats) === '[object Array]') {\n\t        return formats;\n\t    }\n\t    return createDateTimeFormats(formats);\n\t}\n\t\n\t/**\n\t * When the ToDateTimeOptions abstract operation is called with arguments options,\n\t * required, and defaults, the following steps are taken:\n\t */\n\tfunction ToDateTimeOptions(options, required, defaults) {\n\t    // 1. If options is undefined, then let options be null, else let options be\n\t    //    ToObject(options).\n\t    if (options === undefined) options = null;else {\n\t        // (#12) options needs to be a Record, but it also needs to inherit properties\n\t        var opt2 = toObject(options);\n\t        options = new Record();\n\t\n\t        for (var k in opt2) {\n\t            options[k] = opt2[k];\n\t        }\n\t    }\n\t\n\t    // 2. Let create be the standard built-in function object defined in ES5, 15.2.3.5.\n\t    var create = objCreate;\n\t\n\t    // 3. Let options be the result of calling the [[Call]] internal method of create with\n\t    //    undefined as the this value and an argument list containing the single item\n\t    //    options.\n\t    options = create(options);\n\t\n\t    // 4. Let needDefaults be true.\n\t    var needDefaults = true;\n\t\n\t    // 5. If required is \"date\" or \"any\", then\n\t    if (required === 'date' || required === 'any') {\n\t        // a. For each of the property names \"weekday\", \"year\", \"month\", \"day\":\n\t        // i. If the result of calling the [[Get]] internal method of options with the\n\t        //    property name is not undefined, then let needDefaults be false.\n\t        if (options.weekday !== undefined || options.year !== undefined || options.month !== undefined || options.day !== undefined) needDefaults = false;\n\t    }\n\t\n\t    // 6. If required is \"time\" or \"any\", then\n\t    if (required === 'time' || required === 'any') {\n\t        // a. For each of the property names \"hour\", \"minute\", \"second\":\n\t        // i. If the result of calling the [[Get]] internal method of options with the\n\t        //    property name is not undefined, then let needDefaults be false.\n\t        if (options.hour !== undefined || options.minute !== undefined || options.second !== undefined) needDefaults = false;\n\t    }\n\t\n\t    // 7. If needDefaults is true and defaults is either \"date\" or \"all\", then\n\t    if (needDefaults && (defaults === 'date' || defaults === 'all'))\n\t        // a. For each of the property names \"year\", \"month\", \"day\":\n\t        // i. Call the [[DefineOwnProperty]] internal method of options with the\n\t        //    property name, Property Descriptor {[[Value]]: \"numeric\", [[Writable]]:\n\t        //    true, [[Enumerable]]: true, [[Configurable]]: true}, and false.\n\t        options.year = options.month = options.day = 'numeric';\n\t\n\t    // 8. If needDefaults is true and defaults is either \"time\" or \"all\", then\n\t    if (needDefaults && (defaults === 'time' || defaults === 'all'))\n\t        // a. For each of the property names \"hour\", \"minute\", \"second\":\n\t        // i. Call the [[DefineOwnProperty]] internal method of options with the\n\t        //    property name, Property Descriptor {[[Value]]: \"numeric\", [[Writable]]:\n\t        //    true, [[Enumerable]]: true, [[Configurable]]: true}, and false.\n\t        options.hour = options.minute = options.second = 'numeric';\n\t\n\t    // 9. Return options.\n\t    return options;\n\t}\n\t\n\t/**\n\t * When the BasicFormatMatcher abstract operation is called with two arguments options and\n\t * formats, the following steps are taken:\n\t */\n\tfunction BasicFormatMatcher(options, formats) {\n\t    // 1. Let removalPenalty be 120.\n\t    var removalPenalty = 120;\n\t\n\t    // 2. Let additionPenalty be 20.\n\t    var additionPenalty = 20;\n\t\n\t    // 3. Let longLessPenalty be 8.\n\t    var longLessPenalty = 8;\n\t\n\t    // 4. Let longMorePenalty be 6.\n\t    var longMorePenalty = 6;\n\t\n\t    // 5. Let shortLessPenalty be 6.\n\t    var shortLessPenalty = 6;\n\t\n\t    // 6. Let shortMorePenalty be 3.\n\t    var shortMorePenalty = 3;\n\t\n\t    // 7. Let bestScore be -Infinity.\n\t    var bestScore = -Infinity;\n\t\n\t    // 8. Let bestFormat be undefined.\n\t    var bestFormat = void 0;\n\t\n\t    // 9. Let i be 0.\n\t    var i = 0;\n\t\n\t    // 10. Assert: formats is an Array object.\n\t\n\t    // 11. Let len be the result of calling the [[Get]] internal method of formats with argument \"length\".\n\t    var len = formats.length;\n\t\n\t    // 12. Repeat while i < len:\n\t    while (i < len) {\n\t        // a. Let format be the result of calling the [[Get]] internal method of formats with argument ToString(i).\n\t        var format = formats[i];\n\t\n\t        // b. Let score be 0.\n\t        var score = 0;\n\t\n\t        // c. For each property shown in Table 3:\n\t        for (var property in dateTimeComponents) {\n\t            if (!hop.call(dateTimeComponents, property)) continue;\n\t\n\t            // i. Let optionsProp be options.[[<property>]].\n\t            var optionsProp = options['[[' + property + ']]'];\n\t\n\t            // ii. Let formatPropDesc be the result of calling the [[GetOwnProperty]] internal method of format\n\t            //     with argument property.\n\t            // iii. If formatPropDesc is not undefined, then\n\t            //     1. Let formatProp be the result of calling the [[Get]] internal method of format with argument property.\n\t            var formatProp = hop.call(format, property) ? format[property] : undefined;\n\t\n\t            // iv. If optionsProp is undefined and formatProp is not undefined, then decrease score by\n\t            //     additionPenalty.\n\t            if (optionsProp === undefined && formatProp !== undefined) score -= additionPenalty;\n\t\n\t            // v. Else if optionsProp is not undefined and formatProp is undefined, then decrease score by\n\t            //    removalPenalty.\n\t            else if (optionsProp !== undefined && formatProp === undefined) score -= removalPenalty;\n\t\n\t                // vi. Else\n\t                else {\n\t                        // 1. Let values be the array [\"2-digit\", \"numeric\", \"narrow\", \"short\",\n\t                        //    \"long\"].\n\t                        var values = ['2-digit', 'numeric', 'narrow', 'short', 'long'];\n\t\n\t                        // 2. Let optionsPropIndex be the index of optionsProp within values.\n\t                        var optionsPropIndex = arrIndexOf.call(values, optionsProp);\n\t\n\t                        // 3. Let formatPropIndex be the index of formatProp within values.\n\t                        var formatPropIndex = arrIndexOf.call(values, formatProp);\n\t\n\t                        // 4. Let delta be max(min(formatPropIndex - optionsPropIndex, 2), -2).\n\t                        var delta = Math.max(Math.min(formatPropIndex - optionsPropIndex, 2), -2);\n\t\n\t                        // 5. If delta = 2, decrease score by longMorePenalty.\n\t                        if (delta === 2) score -= longMorePenalty;\n\t\n\t                        // 6. Else if delta = 1, decrease score by shortMorePenalty.\n\t                        else if (delta === 1) score -= shortMorePenalty;\n\t\n\t                            // 7. Else if delta = -1, decrease score by shortLessPenalty.\n\t                            else if (delta === -1) score -= shortLessPenalty;\n\t\n\t                                // 8. Else if delta = -2, decrease score by longLessPenalty.\n\t                                else if (delta === -2) score -= longLessPenalty;\n\t                    }\n\t        }\n\t\n\t        // d. If score > bestScore, then\n\t        if (score > bestScore) {\n\t            // i. Let bestScore be score.\n\t            bestScore = score;\n\t\n\t            // ii. Let bestFormat be format.\n\t            bestFormat = format;\n\t        }\n\t\n\t        // e. Increase i by 1.\n\t        i++;\n\t    }\n\t\n\t    // 13. Return bestFormat.\n\t    return bestFormat;\n\t}\n\t\n\t/**\n\t * When the BestFitFormatMatcher abstract operation is called with two arguments options\n\t * and formats, it performs implementation dependent steps, which should return a set of\n\t * component representations that a typical user of the selected locale would perceive as\n\t * at least as good as the one returned by BasicFormatMatcher.\n\t *\n\t * This polyfill defines the algorithm to be the same as BasicFormatMatcher,\n\t * with the addition of bonus points awarded where the requested format is of\n\t * the same data type as the potentially matching format.\n\t *\n\t * This algo relies on the concept of closest distance matching described here:\n\t * http://unicode.org/reports/tr35/tr35-dates.html#Matching_Skeletons\n\t * Typically a best match is found using a closest distance match, such as:\n\t *\n\t * Symbols requesting a best choice for the locale are replaced.\n\t *      j  one of {H, k, h, K}; C  one of {a, b, B}\n\t * -> Covered by cldr.js matching process\n\t *\n\t * For fields with symbols representing the same type (year, month, day, etc):\n\t *     Most symbols have a small distance from each other.\n\t *         M  L; E  c; a  b  B; H  k  h  K; ...\n\t *     -> Covered by cldr.js matching process\n\t *\n\t *     Width differences among fields, other than those marking text vs numeric, are given small distance from each other.\n\t *         MMM  MMMM\n\t *         MM  M\n\t *     Numeric and text fields are given a larger distance from each other.\n\t *         MMM  MM\n\t *     Symbols representing substantial differences (week of year vs week of month) are given much larger a distances from each other.\n\t *         d  D; ...\n\t *     Missing or extra fields cause a match to fail. (But see Missing Skeleton Fields).\n\t *\n\t *\n\t * For example,\n\t *\n\t *     { month: 'numeric', day: 'numeric' }\n\t *\n\t * should match\n\t *\n\t *     { month: '2-digit', day: '2-digit' }\n\t *\n\t * rather than\n\t *\n\t *     { month: 'short', day: 'numeric' }\n\t *\n\t * This makes sense because a user requesting a formatted date with numeric parts would\n\t * not expect to see the returned format containing narrow, short or long part names\n\t */\n\tfunction BestFitFormatMatcher(options, formats) {\n\t\n\t    // 1. Let removalPenalty be 120.\n\t    var removalPenalty = 120;\n\t\n\t    // 2. Let additionPenalty be 20.\n\t    var additionPenalty = 20;\n\t\n\t    // 3. Let longLessPenalty be 8.\n\t    var longLessPenalty = 8;\n\t\n\t    // 4. Let longMorePenalty be 6.\n\t    var longMorePenalty = 6;\n\t\n\t    // 5. Let shortLessPenalty be 6.\n\t    var shortLessPenalty = 6;\n\t\n\t    // 6. Let shortMorePenalty be 3.\n\t    var shortMorePenalty = 3;\n\t\n\t    var hour12Penalty = 1;\n\t\n\t    // 7. Let bestScore be -Infinity.\n\t    var bestScore = -Infinity;\n\t\n\t    // 8. Let bestFormat be undefined.\n\t    var bestFormat = void 0;\n\t\n\t    // 9. Let i be 0.\n\t    var i = 0;\n\t\n\t    // 10. Assert: formats is an Array object.\n\t\n\t    // 11. Let len be the result of calling the [[Get]] internal method of formats with argument \"length\".\n\t    var len = formats.length;\n\t\n\t    // 12. Repeat while i < len:\n\t    while (i < len) {\n\t        // a. Let format be the result of calling the [[Get]] internal method of formats with argument ToString(i).\n\t        var format = formats[i];\n\t\n\t        // b. Let score be 0.\n\t        var score = 0;\n\t\n\t        // c. For each property shown in Table 3:\n\t        for (var property in dateTimeComponents) {\n\t            if (!hop.call(dateTimeComponents, property)) continue;\n\t\n\t            // i. Let optionsProp be options.[[<property>]].\n\t            var optionsProp = options['[[' + property + ']]'];\n\t\n\t            // ii. Let formatPropDesc be the result of calling the [[GetOwnProperty]] internal method of format\n\t            //     with argument property.\n\t            // iii. If formatPropDesc is not undefined, then\n\t            //     1. Let formatProp be the result of calling the [[Get]] internal method of format with argument property.\n\t            var formatProp = hop.call(format, property) ? format[property] : undefined;\n\t\n\t            // iv. If optionsProp is undefined and formatProp is not undefined, then decrease score by\n\t            //     additionPenalty.\n\t            if (optionsProp === undefined && formatProp !== undefined) score -= additionPenalty;\n\t\n\t            // v. Else if optionsProp is not undefined and formatProp is undefined, then decrease score by\n\t            //    removalPenalty.\n\t            else if (optionsProp !== undefined && formatProp === undefined) score -= removalPenalty;\n\t\n\t                // vi. Else\n\t                else {\n\t                        // 1. Let values be the array [\"2-digit\", \"numeric\", \"narrow\", \"short\",\n\t                        //    \"long\"].\n\t                        var values = ['2-digit', 'numeric', 'narrow', 'short', 'long'];\n\t\n\t                        // 2. Let optionsPropIndex be the index of optionsProp within values.\n\t                        var optionsPropIndex = arrIndexOf.call(values, optionsProp);\n\t\n\t                        // 3. Let formatPropIndex be the index of formatProp within values.\n\t                        var formatPropIndex = arrIndexOf.call(values, formatProp);\n\t\n\t                        // 4. Let delta be max(min(formatPropIndex - optionsPropIndex, 2), -2).\n\t                        var delta = Math.max(Math.min(formatPropIndex - optionsPropIndex, 2), -2);\n\t\n\t                        {\n\t                            // diverging from spec\n\t                            // When the bestFit argument is true, subtract additional penalty where data types are not the same\n\t                            if (formatPropIndex <= 1 && optionsPropIndex >= 2 || formatPropIndex >= 2 && optionsPropIndex <= 1) {\n\t                                // 5. If delta = 2, decrease score by longMorePenalty.\n\t                                if (delta > 0) score -= longMorePenalty;else if (delta < 0) score -= longLessPenalty;\n\t                            } else {\n\t                                // 5. If delta = 2, decrease score by longMorePenalty.\n\t                                if (delta > 1) score -= shortMorePenalty;else if (delta < -1) score -= shortLessPenalty;\n\t                            }\n\t                        }\n\t                    }\n\t        }\n\t\n\t        {\n\t            // diverging to also take into consideration differences between 12 or 24 hours\n\t            // which is special for the best fit only.\n\t            if (format._.hour12 !== options.hour12) {\n\t                score -= hour12Penalty;\n\t            }\n\t        }\n\t\n\t        // d. If score > bestScore, then\n\t        if (score > bestScore) {\n\t            // i. Let bestScore be score.\n\t            bestScore = score;\n\t            // ii. Let bestFormat be format.\n\t            bestFormat = format;\n\t        }\n\t\n\t        // e. Increase i by 1.\n\t        i++;\n\t    }\n\t\n\t    // 13. Return bestFormat.\n\t    return bestFormat;\n\t}\n\t\n\t/* 12.2.3 */internals.DateTimeFormat = {\n\t    '[[availableLocales]]': [],\n\t    '[[relevantExtensionKeys]]': ['ca', 'nu'],\n\t    '[[localeData]]': {}\n\t};\n\t\n\t/**\n\t * When the supportedLocalesOf method of Intl.DateTimeFormat is called, the\n\t * following steps are taken:\n\t */\n\t/* 12.2.2 */\n\tdefineProperty(Intl.DateTimeFormat, 'supportedLocalesOf', {\n\t    configurable: true,\n\t    writable: true,\n\t    value: fnBind.call(function (locales) {\n\t        // Bound functions only have the `this` value altered if being used as a constructor,\n\t        // this lets us imitate a native function that has no constructor\n\t        if (!hop.call(this, '[[availableLocales]]')) throw new TypeError('supportedLocalesOf() is not a constructor');\n\t\n\t        // Create an object whose props can be used to restore the values of RegExp props\n\t        var regexpState = createRegExpRestore(),\n\t\n\t\n\t        // 1. If options is not provided, then let options be undefined.\n\t        options = arguments[1],\n\t\n\t\n\t        // 2. Let availableLocales be the value of the [[availableLocales]] internal\n\t        //    property of the standard built-in object that is the initial value of\n\t        //    Intl.NumberFormat.\n\t\n\t        availableLocales = this['[[availableLocales]]'],\n\t\n\t\n\t        // 3. Let requestedLocales be the result of calling the CanonicalizeLocaleList\n\t        //    abstract operation (defined in 9.2.1) with argument locales.\n\t        requestedLocales = CanonicalizeLocaleList(locales);\n\t\n\t        // Restore the RegExp properties\n\t        regexpState.exp.test(regexpState.input);\n\t\n\t        // 4. Return the result of calling the SupportedLocales abstract operation\n\t        //    (defined in 9.2.8) with arguments availableLocales, requestedLocales,\n\t        //    and options.\n\t        return SupportedLocales(availableLocales, requestedLocales, options);\n\t    }, internals.NumberFormat)\n\t});\n\t\n\t/**\n\t * This named accessor property returns a function that formats a number\n\t * according to the effective locale and the formatting options of this\n\t * DateTimeFormat object.\n\t */\n\t/* 12.3.2 */defineProperty(Intl.DateTimeFormat.prototype, 'format', {\n\t    configurable: true,\n\t    get: GetFormatDateTime\n\t});\n\t\n\tdefineProperty(Intl.DateTimeFormat.prototype, 'formatToParts', {\n\t    configurable: true,\n\t    get: GetFormatToPartsDateTime\n\t});\n\t\n\tfunction GetFormatDateTime() {\n\t    var internal = this !== null && babelHelpers[\"typeof\"](this) === 'object' && getInternalProperties(this);\n\t\n\t    // Satisfy test 12.3_b\n\t    if (!internal || !internal['[[initializedDateTimeFormat]]']) throw new TypeError('`this` value for format() is not an initialized Intl.DateTimeFormat object.');\n\t\n\t    // The value of the [[Get]] attribute is a function that takes the following\n\t    // steps:\n\t\n\t    // 1. If the [[boundFormat]] internal property of this DateTimeFormat object\n\t    //    is undefined, then:\n\t    if (internal['[[boundFormat]]'] === undefined) {\n\t        // a. Let F be a Function object, with internal properties set as\n\t        //    specified for built-in functions in ES5, 15, or successor, and the\n\t        //    length property set to 0, that takes the argument date and\n\t        //    performs the following steps:\n\t        var F = function F() {\n\t            //   i. If date is not provided or is undefined, then let x be the\n\t            //      result as if by the expression Date.now() where Date.now is\n\t            //      the standard built-in function defined in ES5, 15.9.4.4.\n\t            //  ii. Else let x be ToNumber(date).\n\t            // iii. Return the result of calling the FormatDateTime abstract\n\t            //      operation (defined below) with arguments this and x.\n\t            var x = Number(arguments.length === 0 ? Date.now() : arguments[0]);\n\t            return FormatDateTime(this, x);\n\t        };\n\t        // b. Let bind be the standard built-in function object defined in ES5,\n\t        //    15.3.4.5.\n\t        // c. Let bf be the result of calling the [[Call]] internal method of\n\t        //    bind with F as the this value and an argument list containing\n\t        //    the single item this.\n\t        var bf = fnBind.call(F, this);\n\t        // d. Set the [[boundFormat]] internal property of this NumberFormat\n\t        //    object to bf.\n\t        internal['[[boundFormat]]'] = bf;\n\t    }\n\t    // Return the value of the [[boundFormat]] internal property of this\n\t    // NumberFormat object.\n\t    return internal['[[boundFormat]]'];\n\t}\n\t\n\tfunction GetFormatToPartsDateTime() {\n\t    var internal = this !== null && babelHelpers[\"typeof\"](this) === 'object' && getInternalProperties(this);\n\t\n\t    if (!internal || !internal['[[initializedDateTimeFormat]]']) throw new TypeError('`this` value for formatToParts() is not an initialized Intl.DateTimeFormat object.');\n\t\n\t    if (internal['[[boundFormatToParts]]'] === undefined) {\n\t        var F = function F() {\n\t            var x = Number(arguments.length === 0 ? Date.now() : arguments[0]);\n\t            return FormatToPartsDateTime(this, x);\n\t        };\n\t        var bf = fnBind.call(F, this);\n\t        internal['[[boundFormatToParts]]'] = bf;\n\t    }\n\t    return internal['[[boundFormatToParts]]'];\n\t}\n\t\n\tfunction CreateDateTimeParts(dateTimeFormat, x) {\n\t    // 1. If x is not a finite Number, then throw a RangeError exception.\n\t    if (!isFinite(x)) throw new RangeError('Invalid valid date passed to format');\n\t\n\t    var internal = dateTimeFormat.__getInternalProperties(secret);\n\t\n\t    // Creating restore point for properties on the RegExp object... please wait\n\t    /* let regexpState = */createRegExpRestore(); // ###TODO: review this\n\t\n\t    // 2. Let locale be the value of the [[locale]] internal property of dateTimeFormat.\n\t    var locale = internal['[[locale]]'];\n\t\n\t    // 3. Let nf be the result of creating a new NumberFormat object as if by the\n\t    // expression new Intl.NumberFormat([locale], {useGrouping: false}) where\n\t    // Intl.NumberFormat is the standard built-in constructor defined in 11.1.3.\n\t    var nf = new Intl.NumberFormat([locale], { useGrouping: false });\n\t\n\t    // 4. Let nf2 be the result of creating a new NumberFormat object as if by the\n\t    // expression new Intl.NumberFormat([locale], {minimumIntegerDigits: 2, useGrouping:\n\t    // false}) where Intl.NumberFormat is the standard built-in constructor defined in\n\t    // 11.1.3.\n\t    var nf2 = new Intl.NumberFormat([locale], { minimumIntegerDigits: 2, useGrouping: false });\n\t\n\t    // 5. Let tm be the result of calling the ToLocalTime abstract operation (defined\n\t    // below) with x, the value of the [[calendar]] internal property of dateTimeFormat,\n\t    // and the value of the [[timeZone]] internal property of dateTimeFormat.\n\t    var tm = ToLocalTime(x, internal['[[calendar]]'], internal['[[timeZone]]']);\n\t\n\t    // 6. Let result be the value of the [[pattern]] internal property of dateTimeFormat.\n\t    var pattern = internal['[[pattern]]'];\n\t\n\t    // 7.\n\t    var result = new List();\n\t\n\t    // 8.\n\t    var index = 0;\n\t\n\t    // 9.\n\t    var beginIndex = pattern.indexOf('{');\n\t\n\t    // 10.\n\t    var endIndex = 0;\n\t\n\t    // Need the locale minus any extensions\n\t    var dataLocale = internal['[[dataLocale]]'];\n\t\n\t    // Need the calendar data from CLDR\n\t    var localeData = internals.DateTimeFormat['[[localeData]]'][dataLocale].calendars;\n\t    var ca = internal['[[calendar]]'];\n\t\n\t    // 11.\n\t    while (beginIndex !== -1) {\n\t        var fv = void 0;\n\t        // a.\n\t        endIndex = pattern.indexOf('}', beginIndex);\n\t        // b.\n\t        if (endIndex === -1) {\n\t            throw new Error('Unclosed pattern');\n\t        }\n\t        // c.\n\t        if (beginIndex > index) {\n\t            arrPush.call(result, {\n\t                type: 'literal',\n\t                value: pattern.substring(index, beginIndex)\n\t            });\n\t        }\n\t        // d.\n\t        var p = pattern.substring(beginIndex + 1, endIndex);\n\t        // e.\n\t        if (dateTimeComponents.hasOwnProperty(p)) {\n\t            //   i. Let f be the value of the [[<p>]] internal property of dateTimeFormat.\n\t            var f = internal['[[' + p + ']]'];\n\t            //  ii. Let v be the value of tm.[[<p>]].\n\t            var v = tm['[[' + p + ']]'];\n\t            // iii. If p is \"year\" and v  0, then let v be 1 - v.\n\t            if (p === 'year' && v <= 0) {\n\t                v = 1 - v;\n\t            }\n\t            //  iv. If p is \"month\", then increase v by 1.\n\t            else if (p === 'month') {\n\t                    v++;\n\t                }\n\t                //   v. If p is \"hour\" and the value of the [[hour12]] internal property of\n\t                //      dateTimeFormat is true, then\n\t                else if (p === 'hour' && internal['[[hour12]]'] === true) {\n\t                        // 1. Let v be v modulo 12.\n\t                        v = v % 12;\n\t                        // 2. If v is 0 and the value of the [[hourNo0]] internal property of\n\t                        //    dateTimeFormat is true, then let v be 12.\n\t                        if (v === 0 && internal['[[hourNo0]]'] === true) {\n\t                            v = 12;\n\t                        }\n\t                    }\n\t\n\t            //  vi. If f is \"numeric\", then\n\t            if (f === 'numeric') {\n\t                // 1. Let fv be the result of calling the FormatNumber abstract operation\n\t                //    (defined in 11.3.2) with arguments nf and v.\n\t                fv = FormatNumber(nf, v);\n\t            }\n\t            // vii. Else if f is \"2-digit\", then\n\t            else if (f === '2-digit') {\n\t                    // 1. Let fv be the result of calling the FormatNumber abstract operation\n\t                    //    with arguments nf2 and v.\n\t                    fv = FormatNumber(nf2, v);\n\t                    // 2. If the length of fv is greater than 2, let fv be the substring of fv\n\t                    //    containing the last two characters.\n\t                    if (fv.length > 2) {\n\t                        fv = fv.slice(-2);\n\t                    }\n\t                }\n\t                // viii. Else if f is \"narrow\", \"short\", or \"long\", then let fv be a String\n\t                //     value representing f in the desired form; the String value depends upon\n\t                //     the implementation and the effective locale and calendar of\n\t                //     dateTimeFormat. If p is \"month\", then the String value may also depend\n\t                //     on whether dateTimeFormat has a [[day]] internal property. If p is\n\t                //     \"timeZoneName\", then the String value may also depend on the value of\n\t                //     the [[inDST]] field of tm.\n\t                else if (f in dateWidths) {\n\t                        switch (p) {\n\t                            case 'month':\n\t                                fv = resolveDateString(localeData, ca, 'months', f, tm['[[' + p + ']]']);\n\t                                break;\n\t\n\t                            case 'weekday':\n\t                                try {\n\t                                    fv = resolveDateString(localeData, ca, 'days', f, tm['[[' + p + ']]']);\n\t                                    // fv = resolveDateString(ca.days, f)[tm['[['+ p +']]']];\n\t                                } catch (e) {\n\t                                    throw new Error('Could not find weekday data for locale ' + locale);\n\t                                }\n\t                                break;\n\t\n\t                            case 'timeZoneName':\n\t                                fv = ''; // ###TODO\n\t                                break;\n\t\n\t                            case 'era':\n\t                                try {\n\t                                    fv = resolveDateString(localeData, ca, 'eras', f, tm['[[' + p + ']]']);\n\t                                } catch (e) {\n\t                                    throw new Error('Could not find era data for locale ' + locale);\n\t                                }\n\t                                break;\n\t\n\t                            default:\n\t                                fv = tm['[[' + p + ']]'];\n\t                        }\n\t                    }\n\t            // ix\n\t            arrPush.call(result, {\n\t                type: p,\n\t                value: fv\n\t            });\n\t            // f.\n\t        } else if (p === 'ampm') {\n\t                // i.\n\t                var _v = tm['[[hour]]'];\n\t                // ii./iii.\n\t                fv = resolveDateString(localeData, ca, 'dayPeriods', _v > 11 ? 'pm' : 'am', null);\n\t                // iv.\n\t                arrPush.call(result, {\n\t                    type: 'dayPeriod',\n\t                    value: fv\n\t                });\n\t                // g.\n\t            } else {\n\t                    arrPush.call(result, {\n\t                        type: 'literal',\n\t                        value: pattern.substring(beginIndex, endIndex + 1)\n\t                    });\n\t                }\n\t        // h.\n\t        index = endIndex + 1;\n\t        // i.\n\t        beginIndex = pattern.indexOf('{', index);\n\t    }\n\t    // 12.\n\t    if (endIndex < pattern.length - 1) {\n\t        arrPush.call(result, {\n\t            type: 'literal',\n\t            value: pattern.substr(endIndex + 1)\n\t        });\n\t    }\n\t    // 13.\n\t    return result;\n\t}\n\t\n\t/**\n\t * When the FormatDateTime abstract operation is called with arguments dateTimeFormat\n\t * (which must be an object initialized as a DateTimeFormat) and x (which must be a Number\n\t * value), it returns a String value representing x (interpreted as a time value as\n\t * specified in ES5, 15.9.1.1) according to the effective locale and the formatting\n\t * options of dateTimeFormat.\n\t */\n\tfunction FormatDateTime(dateTimeFormat, x) {\n\t    var parts = CreateDateTimeParts(dateTimeFormat, x);\n\t    var result = '';\n\t\n\t    for (var i = 0; parts.length > i; i++) {\n\t        var part = parts[i];\n\t        result += part.value;\n\t    }\n\t    return result;\n\t}\n\t\n\tfunction FormatToPartsDateTime(dateTimeFormat, x) {\n\t    var parts = CreateDateTimeParts(dateTimeFormat, x);\n\t    var result = [];\n\t    for (var i = 0; parts.length > i; i++) {\n\t        var part = parts[i];\n\t        result.push({\n\t            type: part.type,\n\t            value: part.value\n\t        });\n\t    }\n\t    return result;\n\t}\n\t\n\t/**\n\t * When the ToLocalTime abstract operation is called with arguments date, calendar, and\n\t * timeZone, the following steps are taken:\n\t */\n\tfunction ToLocalTime(date, calendar, timeZone) {\n\t    // 1. Apply calendrical calculations on date for the given calendar and time zone to\n\t    //    produce weekday, era, year, month, day, hour, minute, second, and inDST values.\n\t    //    The calculations should use best available information about the specified\n\t    //    calendar and time zone. If the calendar is \"gregory\", then the calculations must\n\t    //    match the algorithms specified in ES5, 15.9.1, except that calculations are not\n\t    //    bound by the restrictions on the use of best available information on time zones\n\t    //    for local time zone adjustment and daylight saving time adjustment imposed by\n\t    //    ES5, 15.9.1.7 and 15.9.1.8.\n\t    // ###TODO###\n\t    var d = new Date(date),\n\t        m = 'get' + (timeZone || '');\n\t\n\t    // 2. Return a Record with fields [[weekday]], [[era]], [[year]], [[month]], [[day]],\n\t    //    [[hour]], [[minute]], [[second]], and [[inDST]], each with the corresponding\n\t    //    calculated value.\n\t    return new Record({\n\t        '[[weekday]]': d[m + 'Day'](),\n\t        '[[era]]': +(d[m + 'FullYear']() >= 0),\n\t        '[[year]]': d[m + 'FullYear'](),\n\t        '[[month]]': d[m + 'Month'](),\n\t        '[[day]]': d[m + 'Date'](),\n\t        '[[hour]]': d[m + 'Hours'](),\n\t        '[[minute]]': d[m + 'Minutes'](),\n\t        '[[second]]': d[m + 'Seconds'](),\n\t        '[[inDST]]': false });\n\t}\n\t\n\t/**\n\t * The function returns a new object whose properties and attributes are set as if\n\t * constructed by an object literal assigning to each of the following properties the\n\t * value of the corresponding internal property of this DateTimeFormat object (see 12.4):\n\t * locale, calendar, numberingSystem, timeZone, hour12, weekday, era, year, month, day,\n\t * hour, minute, second, and timeZoneName. Properties whose corresponding internal\n\t * properties are not present are not assigned.\n\t */\n\t/* 12.3.3 */ // ###TODO###\n\tdefineProperty(Intl.DateTimeFormat.prototype, 'resolvedOptions', {\n\t    writable: true,\n\t    configurable: true,\n\t    value: function value() {\n\t        var prop = void 0,\n\t            descs = new Record(),\n\t            props = ['locale', 'calendar', 'numberingSystem', 'timeZone', 'hour12', 'weekday', 'era', 'year', 'month', 'day', 'hour', 'minute', 'second', 'timeZoneName'],\n\t            internal = this !== null && babelHelpers[\"typeof\"](this) === 'object' && getInternalProperties(this);\n\t\n\t        // Satisfy test 12.3_b\n\t        if (!internal || !internal['[[initializedDateTimeFormat]]']) throw new TypeError('`this` value for resolvedOptions() is not an initialized Intl.DateTimeFormat object.');\n\t\n\t        for (var i = 0, max = props.length; i < max; i++) {\n\t            if (hop.call(internal, prop = '[[' + props[i] + ']]')) descs[props[i]] = { value: internal[prop], writable: true, configurable: true, enumerable: true };\n\t        }\n\t\n\t        return objCreate({}, descs);\n\t    }\n\t});\n\t\n\tvar ls = Intl.__localeSensitiveProtos = {\n\t    Number: {},\n\t    Date: {}\n\t};\n\t\n\t/**\n\t * When the toLocaleString method is called with optional arguments locales and options,\n\t * the following steps are taken:\n\t */\n\t/* 13.2.1 */ls.Number.toLocaleString = function () {\n\t    // Satisfy test 13.2.1_1\n\t    if (Object.prototype.toString.call(this) !== '[object Number]') throw new TypeError('`this` value must be a number for Number.prototype.toLocaleString()');\n\t\n\t    // 1. Let x be this Number value (as defined in ES5, 15.7.4).\n\t    // 2. If locales is not provided, then let locales be undefined.\n\t    // 3. If options is not provided, then let options be undefined.\n\t    // 4. Let numberFormat be the result of creating a new object as if by the\n\t    //    expression new Intl.NumberFormat(locales, options) where\n\t    //    Intl.NumberFormat is the standard built-in constructor defined in 11.1.3.\n\t    // 5. Return the result of calling the FormatNumber abstract operation\n\t    //    (defined in 11.3.2) with arguments numberFormat and x.\n\t    return FormatNumber(new NumberFormatConstructor(arguments[0], arguments[1]), this);\n\t};\n\t\n\t/**\n\t * When the toLocaleString method is called with optional arguments locales and options,\n\t * the following steps are taken:\n\t */\n\t/* 13.3.1 */ls.Date.toLocaleString = function () {\n\t    // Satisfy test 13.3.0_1\n\t    if (Object.prototype.toString.call(this) !== '[object Date]') throw new TypeError('`this` value must be a Date instance for Date.prototype.toLocaleString()');\n\t\n\t    // 1. Let x be this time value (as defined in ES5, 15.9.5).\n\t    var x = +this;\n\t\n\t    // 2. If x is NaN, then return \"Invalid Date\".\n\t    if (isNaN(x)) return 'Invalid Date';\n\t\n\t    // 3. If locales is not provided, then let locales be undefined.\n\t    var locales = arguments[0];\n\t\n\t    // 4. If options is not provided, then let options be undefined.\n\t    var options = arguments[1];\n\t\n\t    // 5. Let options be the result of calling the ToDateTimeOptions abstract\n\t    //    operation (defined in 12.1.1) with arguments options, \"any\", and \"all\".\n\t    options = ToDateTimeOptions(options, 'any', 'all');\n\t\n\t    // 6. Let dateTimeFormat be the result of creating a new object as if by the\n\t    //    expression new Intl.DateTimeFormat(locales, options) where\n\t    //    Intl.DateTimeFormat is the standard built-in constructor defined in 12.1.3.\n\t    var dateTimeFormat = new DateTimeFormatConstructor(locales, options);\n\t\n\t    // 7. Return the result of calling the FormatDateTime abstract operation (defined\n\t    //    in 12.3.2) with arguments dateTimeFormat and x.\n\t    return FormatDateTime(dateTimeFormat, x);\n\t};\n\t\n\t/**\n\t * When the toLocaleDateString method is called with optional arguments locales and\n\t * options, the following steps are taken:\n\t */\n\t/* 13.3.2 */ls.Date.toLocaleDateString = function () {\n\t    // Satisfy test 13.3.0_1\n\t    if (Object.prototype.toString.call(this) !== '[object Date]') throw new TypeError('`this` value must be a Date instance for Date.prototype.toLocaleDateString()');\n\t\n\t    // 1. Let x be this time value (as defined in ES5, 15.9.5).\n\t    var x = +this;\n\t\n\t    // 2. If x is NaN, then return \"Invalid Date\".\n\t    if (isNaN(x)) return 'Invalid Date';\n\t\n\t    // 3. If locales is not provided, then let locales be undefined.\n\t    var locales = arguments[0],\n\t\n\t\n\t    // 4. If options is not provided, then let options be undefined.\n\t    options = arguments[1];\n\t\n\t    // 5. Let options be the result of calling the ToDateTimeOptions abstract\n\t    //    operation (defined in 12.1.1) with arguments options, \"date\", and \"date\".\n\t    options = ToDateTimeOptions(options, 'date', 'date');\n\t\n\t    // 6. Let dateTimeFormat be the result of creating a new object as if by the\n\t    //    expression new Intl.DateTimeFormat(locales, options) where\n\t    //    Intl.DateTimeFormat is the standard built-in constructor defined in 12.1.3.\n\t    var dateTimeFormat = new DateTimeFormatConstructor(locales, options);\n\t\n\t    // 7. Return the result of calling the FormatDateTime abstract operation (defined\n\t    //    in 12.3.2) with arguments dateTimeFormat and x.\n\t    return FormatDateTime(dateTimeFormat, x);\n\t};\n\t\n\t/**\n\t * When the toLocaleTimeString method is called with optional arguments locales and\n\t * options, the following steps are taken:\n\t */\n\t/* 13.3.3 */ls.Date.toLocaleTimeString = function () {\n\t    // Satisfy test 13.3.0_1\n\t    if (Object.prototype.toString.call(this) !== '[object Date]') throw new TypeError('`this` value must be a Date instance for Date.prototype.toLocaleTimeString()');\n\t\n\t    // 1. Let x be this time value (as defined in ES5, 15.9.5).\n\t    var x = +this;\n\t\n\t    // 2. If x is NaN, then return \"Invalid Date\".\n\t    if (isNaN(x)) return 'Invalid Date';\n\t\n\t    // 3. If locales is not provided, then let locales be undefined.\n\t    var locales = arguments[0];\n\t\n\t    // 4. If options is not provided, then let options be undefined.\n\t    var options = arguments[1];\n\t\n\t    // 5. Let options be the result of calling the ToDateTimeOptions abstract\n\t    //    operation (defined in 12.1.1) with arguments options, \"time\", and \"time\".\n\t    options = ToDateTimeOptions(options, 'time', 'time');\n\t\n\t    // 6. Let dateTimeFormat be the result of creating a new object as if by the\n\t    //    expression new Intl.DateTimeFormat(locales, options) where\n\t    //    Intl.DateTimeFormat is the standard built-in constructor defined in 12.1.3.\n\t    var dateTimeFormat = new DateTimeFormatConstructor(locales, options);\n\t\n\t    // 7. Return the result of calling the FormatDateTime abstract operation (defined\n\t    //    in 12.3.2) with arguments dateTimeFormat and x.\n\t    return FormatDateTime(dateTimeFormat, x);\n\t};\n\t\n\tdefineProperty(Intl, '__applyLocaleSensitivePrototypes', {\n\t    writable: true,\n\t    configurable: true,\n\t    value: function value() {\n\t        defineProperty(Number.prototype, 'toLocaleString', { writable: true, configurable: true, value: ls.Number.toLocaleString });\n\t        // Need this here for IE 8, to avoid the _DontEnum_ bug\n\t        defineProperty(Date.prototype, 'toLocaleString', { writable: true, configurable: true, value: ls.Date.toLocaleString });\n\t\n\t        for (var k in ls.Date) {\n\t            if (hop.call(ls.Date, k)) defineProperty(Date.prototype, k, { writable: true, configurable: true, value: ls.Date[k] });\n\t        }\n\t    }\n\t});\n\t\n\t/**\n\t * Can't really ship a single script with data for hundreds of locales, so we provide\n\t * this __addLocaleData method as a means for the developer to add the data on an\n\t * as-needed basis\n\t */\n\tdefineProperty(Intl, '__addLocaleData', {\n\t    value: function value(data) {\n\t        if (!IsStructurallyValidLanguageTag(data.locale)) throw new Error(\"Object passed doesn't identify itself with a valid language tag\");\n\t\n\t        addLocaleData(data, data.locale);\n\t    }\n\t});\n\t\n\tfunction addLocaleData(data, tag) {\n\t    // Both NumberFormat and DateTimeFormat require number data, so throw if it isn't present\n\t    if (!data.number) throw new Error(\"Object passed doesn't contain locale data for Intl.NumberFormat\");\n\t\n\t    var locale = void 0,\n\t        locales = [tag],\n\t        parts = tag.split('-');\n\t\n\t    // Create fallbacks for locale data with scripts, e.g. Latn, Hans, Vaii, etc\n\t    if (parts.length > 2 && parts[1].length === 4) arrPush.call(locales, parts[0] + '-' + parts[2]);\n\t\n\t    while (locale = arrShift.call(locales)) {\n\t        // Add to NumberFormat internal properties as per 11.2.3\n\t        arrPush.call(internals.NumberFormat['[[availableLocales]]'], locale);\n\t        internals.NumberFormat['[[localeData]]'][locale] = data.number;\n\t\n\t        // ...and DateTimeFormat internal properties as per 12.2.3\n\t        if (data.date) {\n\t            data.date.nu = data.number.nu;\n\t            arrPush.call(internals.DateTimeFormat['[[availableLocales]]'], locale);\n\t            internals.DateTimeFormat['[[localeData]]'][locale] = data.date;\n\t        }\n\t    }\n\t\n\t    // If this is the first set of locale data added, make it the default\n\t    if (defaultLocale === undefined) setDefaultLocale(tag);\n\t}\n\t\n\tmodule.exports = Intl;\n\n/***/ },\n\n/***/ 119:\n/***/ function(module, exports) {\n\n\t/* (ignored) */\n\n/***/ },\n\n/***/ 164:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar asap = __webpack_require__(202);\n\t\n\tfunction noop() {}\n\t\n\t// States:\n\t//\n\t// 0 - pending\n\t// 1 - fulfilled with _value\n\t// 2 - rejected with _value\n\t// 3 - adopted the state of another promise, _value\n\t//\n\t// once the state is no longer pending (0) it is immutable\n\t\n\t// All `_` prefixed properties will be reduced to `_{random number}`\n\t// at build time to obfuscate them and discourage their use.\n\t// We don't use symbols or Object.defineProperty to fully hide them\n\t// because the performance isn't good enough.\n\t\n\t\n\t// to avoid using try/catch inside critical functions, we\n\t// extract them to here.\n\tvar LAST_ERROR = null;\n\tvar IS_ERROR = {};\n\tfunction getThen(obj) {\n\t  try {\n\t    return obj.then;\n\t  } catch (ex) {\n\t    LAST_ERROR = ex;\n\t    return IS_ERROR;\n\t  }\n\t}\n\t\n\tfunction tryCallOne(fn, a) {\n\t  try {\n\t    return fn(a);\n\t  } catch (ex) {\n\t    LAST_ERROR = ex;\n\t    return IS_ERROR;\n\t  }\n\t}\n\tfunction tryCallTwo(fn, a, b) {\n\t  try {\n\t    fn(a, b);\n\t  } catch (ex) {\n\t    LAST_ERROR = ex;\n\t    return IS_ERROR;\n\t  }\n\t}\n\t\n\tmodule.exports = Promise;\n\t\n\tfunction Promise(fn) {\n\t  if (typeof this !== 'object') {\n\t    throw new TypeError('Promises must be constructed via new');\n\t  }\n\t  if (typeof fn !== 'function') {\n\t    throw new TypeError('not a function');\n\t  }\n\t  this._45 = 0;\n\t  this._81 = 0;\n\t  this._65 = null;\n\t  this._54 = null;\n\t  if (fn === noop) return;\n\t  doResolve(fn, this);\n\t}\n\tPromise._10 = null;\n\tPromise._97 = null;\n\tPromise._61 = noop;\n\t\n\tPromise.prototype.then = function(onFulfilled, onRejected) {\n\t  if (this.constructor !== Promise) {\n\t    return safeThen(this, onFulfilled, onRejected);\n\t  }\n\t  var res = new Promise(noop);\n\t  handle(this, new Handler(onFulfilled, onRejected, res));\n\t  return res;\n\t};\n\t\n\tfunction safeThen(self, onFulfilled, onRejected) {\n\t  return new self.constructor(function (resolve, reject) {\n\t    var res = new Promise(noop);\n\t    res.then(resolve, reject);\n\t    handle(self, new Handler(onFulfilled, onRejected, res));\n\t  });\n\t};\n\tfunction handle(self, deferred) {\n\t  while (self._81 === 3) {\n\t    self = self._65;\n\t  }\n\t  if (Promise._10) {\n\t    Promise._10(self);\n\t  }\n\t  if (self._81 === 0) {\n\t    if (self._45 === 0) {\n\t      self._45 = 1;\n\t      self._54 = deferred;\n\t      return;\n\t    }\n\t    if (self._45 === 1) {\n\t      self._45 = 2;\n\t      self._54 = [self._54, deferred];\n\t      return;\n\t    }\n\t    self._54.push(deferred);\n\t    return;\n\t  }\n\t  handleResolved(self, deferred);\n\t}\n\t\n\tfunction handleResolved(self, deferred) {\n\t  asap(function() {\n\t    var cb = self._81 === 1 ? deferred.onFulfilled : deferred.onRejected;\n\t    if (cb === null) {\n\t      if (self._81 === 1) {\n\t        resolve(deferred.promise, self._65);\n\t      } else {\n\t        reject(deferred.promise, self._65);\n\t      }\n\t      return;\n\t    }\n\t    var ret = tryCallOne(cb, self._65);\n\t    if (ret === IS_ERROR) {\n\t      reject(deferred.promise, LAST_ERROR);\n\t    } else {\n\t      resolve(deferred.promise, ret);\n\t    }\n\t  });\n\t}\n\tfunction resolve(self, newValue) {\n\t  // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n\t  if (newValue === self) {\n\t    return reject(\n\t      self,\n\t      new TypeError('A promise cannot be resolved with itself.')\n\t    );\n\t  }\n\t  if (\n\t    newValue &&\n\t    (typeof newValue === 'object' || typeof newValue === 'function')\n\t  ) {\n\t    var then = getThen(newValue);\n\t    if (then === IS_ERROR) {\n\t      return reject(self, LAST_ERROR);\n\t    }\n\t    if (\n\t      then === self.then &&\n\t      newValue instanceof Promise\n\t    ) {\n\t      self._81 = 3;\n\t      self._65 = newValue;\n\t      finale(self);\n\t      return;\n\t    } else if (typeof then === 'function') {\n\t      doResolve(then.bind(newValue), self);\n\t      return;\n\t    }\n\t  }\n\t  self._81 = 1;\n\t  self._65 = newValue;\n\t  finale(self);\n\t}\n\t\n\tfunction reject(self, newValue) {\n\t  self._81 = 2;\n\t  self._65 = newValue;\n\t  if (Promise._97) {\n\t    Promise._97(self, newValue);\n\t  }\n\t  finale(self);\n\t}\n\tfunction finale(self) {\n\t  if (self._45 === 1) {\n\t    handle(self, self._54);\n\t    self._54 = null;\n\t  }\n\t  if (self._45 === 2) {\n\t    for (var i = 0; i < self._54.length; i++) {\n\t      handle(self, self._54[i]);\n\t    }\n\t    self._54 = null;\n\t  }\n\t}\n\t\n\tfunction Handler(onFulfilled, onRejected, promise){\n\t  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n\t  this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n\t  this.promise = promise;\n\t}\n\t\n\t/**\n\t * Take a potentially misbehaving resolver function and make sure\n\t * onFulfilled and onRejected are only called once.\n\t *\n\t * Makes no guarantees about asynchrony.\n\t */\n\tfunction doResolve(fn, promise) {\n\t  var done = false;\n\t  var res = tryCallTwo(fn, function (value) {\n\t    if (done) return;\n\t    done = true;\n\t    resolve(promise, value);\n\t  }, function (reason) {\n\t    if (done) return;\n\t    done = true;\n\t    reject(promise, reason);\n\t  })\n\t  if (!done && res === IS_ERROR) {\n\t    done = true;\n\t    reject(promise, LAST_ERROR);\n\t  }\n\t}\n\n\n/***/ },\n\n/***/ 202:\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {\"use strict\";\n\t\n\t// Use the fastest means possible to execute a task in its own turn, with\n\t// priority over other events including IO, animation, reflow, and redraw\n\t// events in browsers.\n\t//\n\t// An exception thrown by a task will permanently interrupt the processing of\n\t// subsequent tasks. The higher level `asap` function ensures that if an\n\t// exception is thrown by a task, that the task queue will continue flushing as\n\t// soon as possible, but if you use `rawAsap` directly, you are responsible to\n\t// either ensure that no exceptions are thrown from your task, or to manually\n\t// call `rawAsap.requestFlush` if an exception is thrown.\n\tmodule.exports = rawAsap;\n\tfunction rawAsap(task) {\n\t    if (!queue.length) {\n\t        requestFlush();\n\t        flushing = true;\n\t    }\n\t    // Equivalent to push, but avoids a function call.\n\t    queue[queue.length] = task;\n\t}\n\t\n\tvar queue = [];\n\t// Once a flush has been requested, no further calls to `requestFlush` are\n\t// necessary until the next `flush` completes.\n\tvar flushing = false;\n\t// `requestFlush` is an implementation-specific method that attempts to kick\n\t// off a `flush` event as quickly as possible. `flush` will attempt to exhaust\n\t// the event queue before yielding to the browser's own event loop.\n\tvar requestFlush;\n\t// The position of the next task to execute in the task queue. This is\n\t// preserved between calls to `flush` so that it can be resumed if\n\t// a task throws an exception.\n\tvar index = 0;\n\t// If a task schedules additional tasks recursively, the task queue can grow\n\t// unbounded. To prevent memory exhaustion, the task queue will periodically\n\t// truncate already-completed tasks.\n\tvar capacity = 1024;\n\t\n\t// The flush function processes all tasks that have been scheduled with\n\t// `rawAsap` unless and until one of those tasks throws an exception.\n\t// If a task throws an exception, `flush` ensures that its state will remain\n\t// consistent and will resume where it left off when called again.\n\t// However, `flush` does not make any arrangements to be called again if an\n\t// exception is thrown.\n\tfunction flush() {\n\t    while (index < queue.length) {\n\t        var currentIndex = index;\n\t        // Advance the index before calling the task. This ensures that we will\n\t        // begin flushing on the next task the task throws an error.\n\t        index = index + 1;\n\t        queue[currentIndex].call();\n\t        // Prevent leaking memory for long chains of recursive calls to `asap`.\n\t        // If we call `asap` within tasks scheduled by `asap`, the queue will\n\t        // grow, but to avoid an O(n) walk for every task we execute, we don't\n\t        // shift tasks off the queue after they have been executed.\n\t        // Instead, we periodically shift 1024 tasks off the queue.\n\t        if (index > capacity) {\n\t            // Manually shift all values starting at the index back to the\n\t            // beginning of the queue.\n\t            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {\n\t                queue[scan] = queue[scan + index];\n\t            }\n\t            queue.length -= index;\n\t            index = 0;\n\t        }\n\t    }\n\t    queue.length = 0;\n\t    index = 0;\n\t    flushing = false;\n\t}\n\t\n\t// `requestFlush` is implemented using a strategy based on data collected from\n\t// every available SauceLabs Selenium web driver worker at time of writing.\n\t// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593\n\t\n\t// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that\n\t// have WebKitMutationObserver but not un-prefixed MutationObserver.\n\t// Must use `global` instead of `window` to work in both frames and web\n\t// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.\n\tvar BrowserMutationObserver = global.MutationObserver || global.WebKitMutationObserver;\n\t\n\t// MutationObservers are desirable because they have high priority and work\n\t// reliably everywhere they are implemented.\n\t// They are implemented in all modern browsers.\n\t//\n\t// - Android 4-4.3\n\t// - Chrome 26-34\n\t// - Firefox 14-29\n\t// - Internet Explorer 11\n\t// - iPad Safari 6-7.1\n\t// - iPhone Safari 7-7.1\n\t// - Safari 6-7\n\tif (typeof BrowserMutationObserver === \"function\") {\n\t    requestFlush = makeRequestCallFromMutationObserver(flush);\n\t\n\t// MessageChannels are desirable because they give direct access to the HTML\n\t// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera\n\t// 11-12, and in web workers in many engines.\n\t// Although message channels yield to any queued rendering and IO tasks, they\n\t// would be better than imposing the 4ms delay of timers.\n\t// However, they do not work reliably in Internet Explorer or Safari.\n\t\n\t// Internet Explorer 10 is the only browser that has setImmediate but does\n\t// not have MutationObservers.\n\t// Although setImmediate yields to the browser's renderer, it would be\n\t// preferrable to falling back to setTimeout since it does not have\n\t// the minimum 4ms penalty.\n\t// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and\n\t// Desktop to a lesser extent) that renders both setImmediate and\n\t// MessageChannel useless for the purposes of ASAP.\n\t// https://github.com/kriskowal/q/issues/396\n\t\n\t// Timers are implemented universally.\n\t// We fall back to timers in workers in most engines, and in foreground\n\t// contexts in the following browsers.\n\t// However, note that even this simple case requires nuances to operate in a\n\t// broad spectrum of browsers.\n\t//\n\t// - Firefox 3-13\n\t// - Internet Explorer 6-9\n\t// - iPad Safari 4.3\n\t// - Lynx 2.8.7\n\t} else {\n\t    requestFlush = makeRequestCallFromTimer(flush);\n\t}\n\t\n\t// `requestFlush` requests that the high priority event queue be flushed as\n\t// soon as possible.\n\t// This is useful to prevent an error thrown in a task from stalling the event\n\t// queue if the exception handled by Node.jss\n\t// `process.on(\"uncaughtException\")` or by a domain.\n\trawAsap.requestFlush = requestFlush;\n\t\n\t// To request a high priority event, we induce a mutation observer by toggling\n\t// the text of a text node between \"1\" and \"-1\".\n\tfunction makeRequestCallFromMutationObserver(callback) {\n\t    var toggle = 1;\n\t    var observer = new BrowserMutationObserver(callback);\n\t    var node = document.createTextNode(\"\");\n\t    observer.observe(node, {characterData: true});\n\t    return function requestCall() {\n\t        toggle = -toggle;\n\t        node.data = toggle;\n\t    };\n\t}\n\t\n\t// The message channel technique was discovered by Malte Ubl and was the\n\t// original foundation for this library.\n\t// http://www.nonblocking.io/2011/06/windownexttick.html\n\t\n\t// Safari 6.0.5 (at least) intermittently fails to create message ports on a\n\t// page's first load. Thankfully, this version of Safari supports\n\t// MutationObservers, so we don't need to fall back in that case.\n\t\n\t// function makeRequestCallFromMessageChannel(callback) {\n\t//     var channel = new MessageChannel();\n\t//     channel.port1.onmessage = callback;\n\t//     return function requestCall() {\n\t//         channel.port2.postMessage(0);\n\t//     };\n\t// }\n\t\n\t// For reasons explained above, we are also unable to use `setImmediate`\n\t// under any circumstances.\n\t// Even if we were, there is another bug in Internet Explorer 10.\n\t// It is not sufficient to assign `setImmediate` to `requestFlush` because\n\t// `setImmediate` must be called *by name* and therefore must be wrapped in a\n\t// closure.\n\t// Never forget.\n\t\n\t// function makeRequestCallFromSetImmediate(callback) {\n\t//     return function requestCall() {\n\t//         setImmediate(callback);\n\t//     };\n\t// }\n\t\n\t// Safari 6.0 has a problem where timers will get lost while the user is\n\t// scrolling. This problem does not impact ASAP because Safari 6.0 supports\n\t// mutation observers, so that implementation is used instead.\n\t// However, if we ever elect to use timers in Safari, the prevalent work-around\n\t// is to add a scroll event listener that calls for a flush.\n\t\n\t// `setTimeout` does not call the passed callback if the delay is less than\n\t// approximately 7 in web workers in Firefox 8 through 18, and sometimes not\n\t// even then.\n\t\n\tfunction makeRequestCallFromTimer(callback) {\n\t    return function requestCall() {\n\t        // We dispatch a timeout with a specified delay of 0 for engines that\n\t        // can reliably accommodate that request. This will usually be snapped\n\t        // to a 4 milisecond delay, but once we're flushing, there's no delay\n\t        // between events.\n\t        var timeoutHandle = setTimeout(handleTimer, 0);\n\t        // However, since this timer gets frequently dropped in Firefox\n\t        // workers, we enlist an interval handle that will try to fire\n\t        // an event 20 times per second until it succeeds.\n\t        var intervalHandle = setInterval(handleTimer, 50);\n\t\n\t        function handleTimer() {\n\t            // Whichever timer succeeds will cancel both timers and\n\t            // execute the callback.\n\t            clearTimeout(timeoutHandle);\n\t            clearInterval(intervalHandle);\n\t            callback();\n\t        }\n\t    };\n\t}\n\t\n\t// This is for `asap.js` only.\n\t// Its name will be periodically randomized to break any code that depends on\n\t// its existence.\n\trawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;\n\t\n\t// ASAP was originally a nextTick shim included in Q. This was factored out\n\t// into this ASAP package. It was later adapted to RSVP which made further\n\t// amendments. These decisions, particularly to marginalize MessageChannel and\n\t// to capture the MutationObserver implementation in a closure, were integrated\n\t// back into ASAP proper.\n\t// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n\n/***/ 261:\n/***/ function(module, exports) {\n\n\t/*\n\t * Copyright 2015, Yahoo Inc.\n\t * Copyrights licensed under the New BSD License.\n\t * See the accompanying LICENSE file for terms.\n\t */\n\t'use strict';\n\t\n\tmodule.exports = areIntlLocalesSupported;\n\t\n\tfunction areIntlLocalesSupported(locales) {\n\t    if (typeof Intl === 'undefined') {\n\t        return false;\n\t    }\n\t\n\t    if (!locales) {\n\t        throw new Error('locales must be supplied.');\n\t    }\n\t\n\t    if (!Array.isArray(locales)) {\n\t        locales = [locales];\n\t    }\n\t\n\t    var intlConstructors = [\n\t        Intl.Collator,\n\t        Intl.DateTimeFormat,\n\t        Intl.NumberFormat\n\t    ].filter(function (intlConstructor) {\n\t        return intlConstructor;\n\t    });\n\t\n\t    if (intlConstructors.length === 0) {\n\t        return false;\n\t    }\n\t\n\t    return intlConstructors.every(function (intlConstructor) {\n\t        var supportedLocales = intlConstructor.supportedLocalesOf(locales);\n\t        return supportedLocales.length === locales.length;\n\t    });\n\t}\n\n\n/***/ },\n\n/***/ 383:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t//This file contains the ES6 extensions to the core Promises/A+ API\n\t\n\tvar Promise = __webpack_require__(164);\n\t\n\tmodule.exports = Promise;\n\t\n\t/* Static Functions */\n\t\n\tvar TRUE = valuePromise(true);\n\tvar FALSE = valuePromise(false);\n\tvar NULL = valuePromise(null);\n\tvar UNDEFINED = valuePromise(undefined);\n\tvar ZERO = valuePromise(0);\n\tvar EMPTYSTRING = valuePromise('');\n\t\n\tfunction valuePromise(value) {\n\t  var p = new Promise(Promise._61);\n\t  p._81 = 1;\n\t  p._65 = value;\n\t  return p;\n\t}\n\tPromise.resolve = function (value) {\n\t  if (value instanceof Promise) return value;\n\t\n\t  if (value === null) return NULL;\n\t  if (value === undefined) return UNDEFINED;\n\t  if (value === true) return TRUE;\n\t  if (value === false) return FALSE;\n\t  if (value === 0) return ZERO;\n\t  if (value === '') return EMPTYSTRING;\n\t\n\t  if (typeof value === 'object' || typeof value === 'function') {\n\t    try {\n\t      var then = value.then;\n\t      if (typeof then === 'function') {\n\t        return new Promise(then.bind(value));\n\t      }\n\t    } catch (ex) {\n\t      return new Promise(function (resolve, reject) {\n\t        reject(ex);\n\t      });\n\t    }\n\t  }\n\t  return valuePromise(value);\n\t};\n\t\n\tPromise.all = function (arr) {\n\t  var args = Array.prototype.slice.call(arr);\n\t\n\t  return new Promise(function (resolve, reject) {\n\t    if (args.length === 0) return resolve([]);\n\t    var remaining = args.length;\n\t    function res(i, val) {\n\t      if (val && (typeof val === 'object' || typeof val === 'function')) {\n\t        if (val instanceof Promise && val.then === Promise.prototype.then) {\n\t          while (val._81 === 3) {\n\t            val = val._65;\n\t          }\n\t          if (val._81 === 1) return res(i, val._65);\n\t          if (val._81 === 2) reject(val._65);\n\t          val.then(function (val) {\n\t            res(i, val);\n\t          }, reject);\n\t          return;\n\t        } else {\n\t          var then = val.then;\n\t          if (typeof then === 'function') {\n\t            var p = new Promise(then.bind(val));\n\t            p.then(function (val) {\n\t              res(i, val);\n\t            }, reject);\n\t            return;\n\t          }\n\t        }\n\t      }\n\t      args[i] = val;\n\t      if (--remaining === 0) {\n\t        resolve(args);\n\t      }\n\t    }\n\t    for (var i = 0; i < args.length; i++) {\n\t      res(i, args[i]);\n\t    }\n\t  });\n\t};\n\t\n\tPromise.reject = function (value) {\n\t  return new Promise(function (resolve, reject) {\n\t    reject(value);\n\t  });\n\t};\n\t\n\tPromise.race = function (values) {\n\t  return new Promise(function (resolve, reject) {\n\t    values.forEach(function(value){\n\t      Promise.resolve(value).then(resolve, reject);\n\t    });\n\t  });\n\t};\n\t\n\t/* Prototype Methods */\n\t\n\tPromise.prototype['catch'] = function (onRejected) {\n\t  return this.then(null, onRejected);\n\t};\n\n\n/***/ },\n\n/***/ 384:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar Promise = __webpack_require__(164);\n\t\n\tvar DEFAULT_WHITELIST = [\n\t  ReferenceError,\n\t  TypeError,\n\t  RangeError\n\t];\n\t\n\tvar enabled = false;\n\texports.disable = disable;\n\tfunction disable() {\n\t  enabled = false;\n\t  Promise._10 = null;\n\t  Promise._97 = null;\n\t}\n\t\n\texports.enable = enable;\n\tfunction enable(options) {\n\t  options = options || {};\n\t  if (enabled) disable();\n\t  enabled = true;\n\t  var id = 0;\n\t  var displayId = 0;\n\t  var rejections = {};\n\t  Promise._10 = function (promise) {\n\t    if (\n\t      promise._81 === 2 && // IS REJECTED\n\t      rejections[promise._72]\n\t    ) {\n\t      if (rejections[promise._72].logged) {\n\t        onHandled(promise._72);\n\t      } else {\n\t        clearTimeout(rejections[promise._72].timeout);\n\t      }\n\t      delete rejections[promise._72];\n\t    }\n\t  };\n\t  Promise._97 = function (promise, err) {\n\t    if (promise._45 === 0) { // not yet handled\n\t      promise._72 = id++;\n\t      rejections[promise._72] = {\n\t        displayId: null,\n\t        error: err,\n\t        timeout: setTimeout(\n\t          onUnhandled.bind(null, promise._72),\n\t          // For reference errors and type errors, this almost always\n\t          // means the programmer made a mistake, so log them after just\n\t          // 100ms\n\t          // otherwise, wait 2 seconds to see if they get handled\n\t          matchWhitelist(err, DEFAULT_WHITELIST)\n\t            ? 100\n\t            : 2000\n\t        ),\n\t        logged: false\n\t      };\n\t    }\n\t  };\n\t  function onUnhandled(id) {\n\t    if (\n\t      options.allRejections ||\n\t      matchWhitelist(\n\t        rejections[id].error,\n\t        options.whitelist || DEFAULT_WHITELIST\n\t      )\n\t    ) {\n\t      rejections[id].displayId = displayId++;\n\t      if (options.onUnhandled) {\n\t        rejections[id].logged = true;\n\t        options.onUnhandled(\n\t          rejections[id].displayId,\n\t          rejections[id].error\n\t        );\n\t      } else {\n\t        rejections[id].logged = true;\n\t        logError(\n\t          rejections[id].displayId,\n\t          rejections[id].error\n\t        );\n\t      }\n\t    }\n\t  }\n\t  function onHandled(id) {\n\t    if (rejections[id].logged) {\n\t      if (options.onHandled) {\n\t        options.onHandled(rejections[id].displayId, rejections[id].error);\n\t      } else if (!rejections[id].onUnhandled) {\n\t        console.warn(\n\t          'Promise Rejection Handled (id: ' + rejections[id].displayId + '):'\n\t        );\n\t        console.warn(\n\t          '  This means you can ignore any previous messages of the form \"Possible Unhandled Promise Rejection\" with id ' +\n\t          rejections[id].displayId + '.'\n\t        );\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tfunction logError(id, error) {\n\t  console.warn('Possible Unhandled Promise Rejection (id: ' + id + '):');\n\t  var errStr = (error && (error.stack || error)) + '';\n\t  errStr.split('\\n').forEach(function (line) {\n\t    console.warn('  ' + line);\n\t  });\n\t}\n\t\n\tfunction matchWhitelist(error, list) {\n\t  return list.some(function (cls) {\n\t    return error instanceof cls;\n\t  });\n\t}\n\n/***/ },\n\n/***/ 481:\n/***/ function(module, exports) {\n\n\t(function(self) {\n\t  'use strict';\n\t\n\t  if (self.fetch) {\n\t    return\n\t  }\n\t\n\t  var support = {\n\t    searchParams: 'URLSearchParams' in self,\n\t    iterable: 'Symbol' in self && 'iterator' in Symbol,\n\t    blob: 'FileReader' in self && 'Blob' in self && (function() {\n\t      try {\n\t        new Blob()\n\t        return true\n\t      } catch(e) {\n\t        return false\n\t      }\n\t    })(),\n\t    formData: 'FormData' in self,\n\t    arrayBuffer: 'ArrayBuffer' in self\n\t  }\n\t\n\t  function normalizeName(name) {\n\t    if (typeof name !== 'string') {\n\t      name = String(name)\n\t    }\n\t    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n\t      throw new TypeError('Invalid character in header field name')\n\t    }\n\t    return name.toLowerCase()\n\t  }\n\t\n\t  function normalizeValue(value) {\n\t    if (typeof value !== 'string') {\n\t      value = String(value)\n\t    }\n\t    return value\n\t  }\n\t\n\t  // Build a destructive iterator for the value list\n\t  function iteratorFor(items) {\n\t    var iterator = {\n\t      next: function() {\n\t        var value = items.shift()\n\t        return {done: value === undefined, value: value}\n\t      }\n\t    }\n\t\n\t    if (support.iterable) {\n\t      iterator[Symbol.iterator] = function() {\n\t        return iterator\n\t      }\n\t    }\n\t\n\t    return iterator\n\t  }\n\t\n\t  function Headers(headers) {\n\t    this.map = {}\n\t\n\t    if (headers instanceof Headers) {\n\t      headers.forEach(function(value, name) {\n\t        this.append(name, value)\n\t      }, this)\n\t\n\t    } else if (headers) {\n\t      Object.getOwnPropertyNames(headers).forEach(function(name) {\n\t        this.append(name, headers[name])\n\t      }, this)\n\t    }\n\t  }\n\t\n\t  Headers.prototype.append = function(name, value) {\n\t    name = normalizeName(name)\n\t    value = normalizeValue(value)\n\t    var list = this.map[name]\n\t    if (!list) {\n\t      list = []\n\t      this.map[name] = list\n\t    }\n\t    list.push(value)\n\t  }\n\t\n\t  Headers.prototype['delete'] = function(name) {\n\t    delete this.map[normalizeName(name)]\n\t  }\n\t\n\t  Headers.prototype.get = function(name) {\n\t    var values = this.map[normalizeName(name)]\n\t    return values ? values[0] : null\n\t  }\n\t\n\t  Headers.prototype.getAll = function(name) {\n\t    return this.map[normalizeName(name)] || []\n\t  }\n\t\n\t  Headers.prototype.has = function(name) {\n\t    return this.map.hasOwnProperty(normalizeName(name))\n\t  }\n\t\n\t  Headers.prototype.set = function(name, value) {\n\t    this.map[normalizeName(name)] = [normalizeValue(value)]\n\t  }\n\t\n\t  Headers.prototype.forEach = function(callback, thisArg) {\n\t    Object.getOwnPropertyNames(this.map).forEach(function(name) {\n\t      this.map[name].forEach(function(value) {\n\t        callback.call(thisArg, value, name, this)\n\t      }, this)\n\t    }, this)\n\t  }\n\t\n\t  Headers.prototype.keys = function() {\n\t    var items = []\n\t    this.forEach(function(value, name) { items.push(name) })\n\t    return iteratorFor(items)\n\t  }\n\t\n\t  Headers.prototype.values = function() {\n\t    var items = []\n\t    this.forEach(function(value) { items.push(value) })\n\t    return iteratorFor(items)\n\t  }\n\t\n\t  Headers.prototype.entries = function() {\n\t    var items = []\n\t    this.forEach(function(value, name) { items.push([name, value]) })\n\t    return iteratorFor(items)\n\t  }\n\t\n\t  if (support.iterable) {\n\t    Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n\t  }\n\t\n\t  function consumed(body) {\n\t    if (body.bodyUsed) {\n\t      return Promise.reject(new TypeError('Already read'))\n\t    }\n\t    body.bodyUsed = true\n\t  }\n\t\n\t  function fileReaderReady(reader) {\n\t    return new Promise(function(resolve, reject) {\n\t      reader.onload = function() {\n\t        resolve(reader.result)\n\t      }\n\t      reader.onerror = function() {\n\t        reject(reader.error)\n\t      }\n\t    })\n\t  }\n\t\n\t  function readBlobAsArrayBuffer(blob) {\n\t    var reader = new FileReader()\n\t    reader.readAsArrayBuffer(blob)\n\t    return fileReaderReady(reader)\n\t  }\n\t\n\t  function readBlobAsText(blob) {\n\t    var reader = new FileReader()\n\t    reader.readAsText(blob)\n\t    return fileReaderReady(reader)\n\t  }\n\t\n\t  function Body() {\n\t    this.bodyUsed = false\n\t\n\t    this._initBody = function(body) {\n\t      this._bodyInit = body\n\t      if (typeof body === 'string') {\n\t        this._bodyText = body\n\t      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n\t        this._bodyBlob = body\n\t      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n\t        this._bodyFormData = body\n\t      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n\t        this._bodyText = body.toString()\n\t      } else if (!body) {\n\t        this._bodyText = ''\n\t      } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {\n\t        // Only support ArrayBuffers for POST method.\n\t        // Receiving ArrayBuffers happens via Blobs, instead.\n\t      } else {\n\t        throw new Error('unsupported BodyInit type')\n\t      }\n\t\n\t      if (!this.headers.get('content-type')) {\n\t        if (typeof body === 'string') {\n\t          this.headers.set('content-type', 'text/plain;charset=UTF-8')\n\t        } else if (this._bodyBlob && this._bodyBlob.type) {\n\t          this.headers.set('content-type', this._bodyBlob.type)\n\t        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n\t          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n\t        }\n\t      }\n\t    }\n\t\n\t    if (support.blob) {\n\t      this.blob = function() {\n\t        var rejected = consumed(this)\n\t        if (rejected) {\n\t          return rejected\n\t        }\n\t\n\t        if (this._bodyBlob) {\n\t          return Promise.resolve(this._bodyBlob)\n\t        } else if (this._bodyFormData) {\n\t          throw new Error('could not read FormData body as blob')\n\t        } else {\n\t          return Promise.resolve(new Blob([this._bodyText]))\n\t        }\n\t      }\n\t\n\t      this.arrayBuffer = function() {\n\t        return this.blob().then(readBlobAsArrayBuffer)\n\t      }\n\t\n\t      this.text = function() {\n\t        var rejected = consumed(this)\n\t        if (rejected) {\n\t          return rejected\n\t        }\n\t\n\t        if (this._bodyBlob) {\n\t          return readBlobAsText(this._bodyBlob)\n\t        } else if (this._bodyFormData) {\n\t          throw new Error('could not read FormData body as text')\n\t        } else {\n\t          return Promise.resolve(this._bodyText)\n\t        }\n\t      }\n\t    } else {\n\t      this.text = function() {\n\t        var rejected = consumed(this)\n\t        return rejected ? rejected : Promise.resolve(this._bodyText)\n\t      }\n\t    }\n\t\n\t    if (support.formData) {\n\t      this.formData = function() {\n\t        return this.text().then(decode)\n\t      }\n\t    }\n\t\n\t    this.json = function() {\n\t      return this.text().then(JSON.parse)\n\t    }\n\t\n\t    return this\n\t  }\n\t\n\t  // HTTP methods whose capitalization should be normalized\n\t  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\t\n\t  function normalizeMethod(method) {\n\t    var upcased = method.toUpperCase()\n\t    return (methods.indexOf(upcased) > -1) ? upcased : method\n\t  }\n\t\n\t  function Request(input, options) {\n\t    options = options || {}\n\t    var body = options.body\n\t    if (Request.prototype.isPrototypeOf(input)) {\n\t      if (input.bodyUsed) {\n\t        throw new TypeError('Already read')\n\t      }\n\t      this.url = input.url\n\t      this.credentials = input.credentials\n\t      if (!options.headers) {\n\t        this.headers = new Headers(input.headers)\n\t      }\n\t      this.method = input.method\n\t      this.mode = input.mode\n\t      if (!body) {\n\t        body = input._bodyInit\n\t        input.bodyUsed = true\n\t      }\n\t    } else {\n\t      this.url = input\n\t    }\n\t\n\t    this.credentials = options.credentials || this.credentials || 'omit'\n\t    if (options.headers || !this.headers) {\n\t      this.headers = new Headers(options.headers)\n\t    }\n\t    this.method = normalizeMethod(options.method || this.method || 'GET')\n\t    this.mode = options.mode || this.mode || null\n\t    this.referrer = null\n\t\n\t    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n\t      throw new TypeError('Body not allowed for GET or HEAD requests')\n\t    }\n\t    this._initBody(body)\n\t  }\n\t\n\t  Request.prototype.clone = function() {\n\t    return new Request(this)\n\t  }\n\t\n\t  function decode(body) {\n\t    var form = new FormData()\n\t    body.trim().split('&').forEach(function(bytes) {\n\t      if (bytes) {\n\t        var split = bytes.split('=')\n\t        var name = split.shift().replace(/\\+/g, ' ')\n\t        var value = split.join('=').replace(/\\+/g, ' ')\n\t        form.append(decodeURIComponent(name), decodeURIComponent(value))\n\t      }\n\t    })\n\t    return form\n\t  }\n\t\n\t  function headers(xhr) {\n\t    var head = new Headers()\n\t    var pairs = (xhr.getAllResponseHeaders() || '').trim().split('\\n')\n\t    pairs.forEach(function(header) {\n\t      var split = header.trim().split(':')\n\t      var key = split.shift().trim()\n\t      var value = split.join(':').trim()\n\t      head.append(key, value)\n\t    })\n\t    return head\n\t  }\n\t\n\t  Body.call(Request.prototype)\n\t\n\t  function Response(bodyInit, options) {\n\t    if (!options) {\n\t      options = {}\n\t    }\n\t\n\t    this.type = 'default'\n\t    this.status = options.status\n\t    this.ok = this.status >= 200 && this.status < 300\n\t    this.statusText = options.statusText\n\t    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)\n\t    this.url = options.url || ''\n\t    this._initBody(bodyInit)\n\t  }\n\t\n\t  Body.call(Response.prototype)\n\t\n\t  Response.prototype.clone = function() {\n\t    return new Response(this._bodyInit, {\n\t      status: this.status,\n\t      statusText: this.statusText,\n\t      headers: new Headers(this.headers),\n\t      url: this.url\n\t    })\n\t  }\n\t\n\t  Response.error = function() {\n\t    var response = new Response(null, {status: 0, statusText: ''})\n\t    response.type = 'error'\n\t    return response\n\t  }\n\t\n\t  var redirectStatuses = [301, 302, 303, 307, 308]\n\t\n\t  Response.redirect = function(url, status) {\n\t    if (redirectStatuses.indexOf(status) === -1) {\n\t      throw new RangeError('Invalid status code')\n\t    }\n\t\n\t    return new Response(null, {status: status, headers: {location: url}})\n\t  }\n\t\n\t  self.Headers = Headers\n\t  self.Request = Request\n\t  self.Response = Response\n\t\n\t  self.fetch = function(input, init) {\n\t    return new Promise(function(resolve, reject) {\n\t      var request\n\t      if (Request.prototype.isPrototypeOf(input) && !init) {\n\t        request = input\n\t      } else {\n\t        request = new Request(input, init)\n\t      }\n\t\n\t      var xhr = new XMLHttpRequest()\n\t\n\t      function responseURL() {\n\t        if ('responseURL' in xhr) {\n\t          return xhr.responseURL\n\t        }\n\t\n\t        // Avoid security warnings on getResponseHeader when not allowed by CORS\n\t        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {\n\t          return xhr.getResponseHeader('X-Request-URL')\n\t        }\n\t\n\t        return\n\t      }\n\t\n\t      xhr.onload = function() {\n\t        var options = {\n\t          status: xhr.status,\n\t          statusText: xhr.statusText,\n\t          headers: headers(xhr),\n\t          url: responseURL()\n\t        }\n\t        var body = 'response' in xhr ? xhr.response : xhr.responseText\n\t        resolve(new Response(body, options))\n\t      }\n\t\n\t      xhr.onerror = function() {\n\t        reject(new TypeError('Network request failed'))\n\t      }\n\t\n\t      xhr.ontimeout = function() {\n\t        reject(new TypeError('Network request failed'))\n\t      }\n\t\n\t      xhr.open(request.method, request.url, true)\n\t\n\t      if (request.credentials === 'include') {\n\t        xhr.withCredentials = true\n\t      }\n\t\n\t      if ('responseType' in xhr && support.blob) {\n\t        xhr.responseType = 'blob'\n\t      }\n\t\n\t      request.headers.forEach(function(value, name) {\n\t        xhr.setRequestHeader(name, value)\n\t      })\n\t\n\t      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n\t    })\n\t  }\n\t  self.fetch.polyfill = true\n\t})(typeof self !== 'undefined' ? self : this);\n\n\n/***/ }\n\n/******/ });\n\n\n/** WEBPACK FOOTER **\n ** static/js/polyfills.e03f7ab3.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap e03f7ab37f5049c883bf\n **/","if (typeof Promise === 'undefined') {\n  // Rejection tracking prevents a common issue where React gets into an\n  // inconsistent state due to an error, but it gets swallowed by a Promise,\n  // and the user has no idea what causes React's erratic future behavior.\n  require('promise/lib/rejection-tracking').enable();\n  window.Promise = require('promise/lib/es6-extensions.js');\n}\n\nrequire('whatwg-fetch');\n\nconst areIntlLocalesSupported = require('intl-locales-supported');\nvar localesMyAppSupports = [\n  \"nb-NO\"\n];\nif (!global.Intl) {\n  global.Intl = require('intl');\n}\nelse {\n  // Determine if the built-in `Intl` has the locale data we need.\n  if (!areIntlLocalesSupported(localesMyAppSupports)) {\n    // `Intl` exists, but it doesn't have the data we need, so load the\n    // polyfill and replace the constructors we need with the polyfill's.\n    var IntlPolyfill    = require('intl');\n    Intl.NumberFormat   = IntlPolyfill.NumberFormat;\n    Intl.DateTimeFormat = IntlPolyfill.DateTimeFormat;\n  }\n}\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./config/polyfills.js\n ** module id = 0\n ** module chunks = 1\n **/","// Expose `IntlPolyfill` as global to add locale data into runtime later on.\nglobal.IntlPolyfill = require('./lib/core.js');\n\n// Require all locale data for `Intl`. This module will be\n// ignored when bundling for the browser with Browserify/Webpack.\nrequire('./locale-data/complete.js');\n\n// hack to export the polyfill as global Intl if needed\nif (!global.Intl) {\n    global.Intl = global.IntlPolyfill;\n    global.IntlPolyfill.__applyLocaleSensitivePrototypes();\n}\n\n// providing an idiomatic api for the nodejs version of this module\nmodule.exports = global.IntlPolyfill;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /home/vagrant/~/intl/index.js\n ** module id = 38\n ** module chunks = 1 2\n **/","'use strict';\n\nvar babelHelpers = {};\nbabelHelpers.typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj;\n};\nbabelHelpers;\n\nvar realDefineProp = function () {\n    var sentinel = {};\n    try {\n        Object.defineProperty(sentinel, 'a', {});\n        return 'a' in sentinel;\n    } catch (e) {\n        return false;\n    }\n}();\n\n// Need a workaround for getters in ES3\nvar es3 = !realDefineProp && !Object.prototype.__defineGetter__;\n\n// We use this a lot (and need it for proto-less objects)\nvar hop = Object.prototype.hasOwnProperty;\n\n// Naive defineProperty for compatibility\nvar defineProperty = realDefineProp ? Object.defineProperty : function (obj, name, desc) {\n    if ('get' in desc && obj.__defineGetter__) obj.__defineGetter__(name, desc.get);else if (!hop.call(obj, name) || 'value' in desc) obj[name] = desc.value;\n};\n\n// Array.prototype.indexOf, as good as we need it to be\nvar arrIndexOf = Array.prototype.indexOf || function (search) {\n    /*jshint validthis:true */\n    var t = this;\n    if (!t.length) return -1;\n\n    for (var i = arguments[1] || 0, max = t.length; i < max; i++) {\n        if (t[i] === search) return i;\n    }\n\n    return -1;\n};\n\n// Create an object with the specified prototype (2nd arg required for Record)\nvar objCreate = Object.create || function (proto, props) {\n    var obj = void 0;\n\n    function F() {}\n    F.prototype = proto;\n    obj = new F();\n\n    for (var k in props) {\n        if (hop.call(props, k)) defineProperty(obj, k, props[k]);\n    }\n\n    return obj;\n};\n\n// Snapshot some (hopefully still) native built-ins\nvar arrSlice = Array.prototype.slice;\nvar arrConcat = Array.prototype.concat;\nvar arrPush = Array.prototype.push;\nvar arrJoin = Array.prototype.join;\nvar arrShift = Array.prototype.shift;\n\n// Naive Function.prototype.bind for compatibility\nvar fnBind = Function.prototype.bind || function (thisObj) {\n    var fn = this,\n        args = arrSlice.call(arguments, 1);\n\n    // All our (presently) bound functions have either 1 or 0 arguments. By returning\n    // different function signatures, we can pass some tests in ES3 environments\n    if (fn.length === 1) {\n        return function () {\n            return fn.apply(thisObj, arrConcat.call(args, arrSlice.call(arguments)));\n        };\n    }\n    return function () {\n        return fn.apply(thisObj, arrConcat.call(args, arrSlice.call(arguments)));\n    };\n};\n\n// Object housing internal properties for constructors\nvar internals = objCreate(null);\n\n// Keep internal properties internal\nvar secret = Math.random();\n\n// Helper functions\n// ================\n\n/**\n * A function to deal with the inaccuracy of calculating log10 in pre-ES6\n * JavaScript environments. Math.log(num) / Math.LN10 was responsible for\n * causing issue #62.\n */\nfunction log10Floor(n) {\n    // ES6 provides the more accurate Math.log10\n    if (typeof Math.log10 === 'function') return Math.floor(Math.log10(n));\n\n    var x = Math.round(Math.log(n) * Math.LOG10E);\n    return x - (Number('1e' + x) > n);\n}\n\n/**\n * A map that doesn't contain Object in its prototype chain\n */\nfunction Record(obj) {\n    // Copy only own properties over unless this object is already a Record instance\n    for (var k in obj) {\n        if (obj instanceof Record || hop.call(obj, k)) defineProperty(this, k, { value: obj[k], enumerable: true, writable: true, configurable: true });\n    }\n}\nRecord.prototype = objCreate(null);\n\n/**\n * An ordered list\n */\nfunction List() {\n    defineProperty(this, 'length', { writable: true, value: 0 });\n\n    if (arguments.length) arrPush.apply(this, arrSlice.call(arguments));\n}\nList.prototype = objCreate(null);\n\n/**\n * Constructs a regular expression to restore tainted RegExp properties\n */\nfunction createRegExpRestore() {\n    var esc = /[.?*+^$[\\]\\\\(){}|-]/g,\n        lm = RegExp.lastMatch || '',\n        ml = RegExp.multiline ? 'm' : '',\n        ret = { input: RegExp.input },\n        reg = new List(),\n        has = false,\n        cap = {};\n\n    // Create a snapshot of all the 'captured' properties\n    for (var i = 1; i <= 9; i++) {\n        has = (cap['$' + i] = RegExp['$' + i]) || has;\n    } // Now we've snapshotted some properties, escape the lastMatch string\n    lm = lm.replace(esc, '\\\\$&');\n\n    // If any of the captured strings were non-empty, iterate over them all\n    if (has) {\n        for (var _i = 1; _i <= 9; _i++) {\n            var m = cap['$' + _i];\n\n            // If it's empty, add an empty capturing group\n            if (!m) lm = '()' + lm;\n\n            // Else find the string in lm and escape & wrap it to capture it\n            else {\n                    m = m.replace(esc, '\\\\$&');\n                    lm = lm.replace(m, '(' + m + ')');\n                }\n\n            // Push it to the reg and chop lm to make sure further groups come after\n            arrPush.call(reg, lm.slice(0, lm.indexOf('(') + 1));\n            lm = lm.slice(lm.indexOf('(') + 1);\n        }\n    }\n\n    // Create the regular expression that will reconstruct the RegExp properties\n    ret.exp = new RegExp(arrJoin.call(reg, '') + lm, ml);\n\n    return ret;\n}\n\n/**\n * Mimics ES5's abstract ToObject() function\n */\nfunction toObject(arg) {\n    if (arg === null) throw new TypeError('Cannot convert null or undefined to object');\n\n    return Object(arg);\n}\n\n/**\n * Returns \"internal\" properties for an object\n */\nfunction getInternalProperties(obj) {\n    if (hop.call(obj, '__getInternalProperties')) return obj.__getInternalProperties(secret);\n\n    return objCreate(null);\n}\n\n/**\n* Defines regular expressions for various operations related to the BCP 47 syntax,\n* as defined at http://tools.ietf.org/html/bcp47#section-2.1\n*/\n\n// extlang       = 3ALPHA              ; selected ISO 639 codes\n//                 *2(\"-\" 3ALPHA)      ; permanently reserved\nvar extlang = '[a-z]{3}(?:-[a-z]{3}){0,2}';\n\n// language      = 2*3ALPHA            ; shortest ISO 639 code\n//                 [\"-\" extlang]       ; sometimes followed by\n//                                     ; extended language subtags\n//               / 4ALPHA              ; or reserved for future use\n//               / 5*8ALPHA            ; or registered language subtag\nvar language = '(?:[a-z]{2,3}(?:-' + extlang + ')?|[a-z]{4}|[a-z]{5,8})';\n\n// script        = 4ALPHA              ; ISO 15924 code\nvar script = '[a-z]{4}';\n\n// region        = 2ALPHA              ; ISO 3166-1 code\n//               / 3DIGIT              ; UN M.49 code\nvar region = '(?:[a-z]{2}|\\\\d{3})';\n\n// variant       = 5*8alphanum         ; registered variants\n//               / (DIGIT 3alphanum)\nvar variant = '(?:[a-z0-9]{5,8}|\\\\d[a-z0-9]{3})';\n\n//                                     ; Single alphanumerics\n//                                     ; \"x\" reserved for private use\n// singleton     = DIGIT               ; 0 - 9\n//               / %x41-57             ; A - W\n//               / %x59-5A             ; Y - Z\n//               / %x61-77             ; a - w\n//               / %x79-7A             ; y - z\nvar singleton = '[0-9a-wy-z]';\n\n// extension     = singleton 1*(\"-\" (2*8alphanum))\nvar extension = singleton + '(?:-[a-z0-9]{2,8})+';\n\n// privateuse    = \"x\" 1*(\"-\" (1*8alphanum))\nvar privateuse = 'x(?:-[a-z0-9]{1,8})+';\n\n// irregular     = \"en-GB-oed\"         ; irregular tags do not match\n//               / \"i-ami\"             ; the 'langtag' production and\n//               / \"i-bnn\"             ; would not otherwise be\n//               / \"i-default\"         ; considered 'well-formed'\n//               / \"i-enochian\"        ; These tags are all valid,\n//               / \"i-hak\"             ; but most are deprecated\n//               / \"i-klingon\"         ; in favor of more modern\n//               / \"i-lux\"             ; subtags or subtag\n//               / \"i-mingo\"           ; combination\n//               / \"i-navajo\"\n//               / \"i-pwn\"\n//               / \"i-tao\"\n//               / \"i-tay\"\n//               / \"i-tsu\"\n//               / \"sgn-BE-FR\"\n//               / \"sgn-BE-NL\"\n//               / \"sgn-CH-DE\"\nvar irregular = '(?:en-GB-oed' + '|i-(?:ami|bnn|default|enochian|hak|klingon|lux|mingo|navajo|pwn|tao|tay|tsu)' + '|sgn-(?:BE-FR|BE-NL|CH-DE))';\n\n// regular       = \"art-lojban\"        ; these tags match the 'langtag'\n//               / \"cel-gaulish\"       ; production, but their subtags\n//               / \"no-bok\"            ; are not extended language\n//               / \"no-nyn\"            ; or variant subtags: their meaning\n//               / \"zh-guoyu\"          ; is defined by their registration\n//               / \"zh-hakka\"          ; and all of these are deprecated\n//               / \"zh-min\"            ; in favor of a more modern\n//               / \"zh-min-nan\"        ; subtag or sequence of subtags\n//               / \"zh-xiang\"\nvar regular = '(?:art-lojban|cel-gaulish|no-bok|no-nyn' + '|zh-(?:guoyu|hakka|min|min-nan|xiang))';\n\n// grandfathered = irregular           ; non-redundant tags registered\n//               / regular             ; during the RFC 3066 era\nvar grandfathered = '(?:' + irregular + '|' + regular + ')';\n\n// langtag       = language\n//                 [\"-\" script]\n//                 [\"-\" region]\n//                 *(\"-\" variant)\n//                 *(\"-\" extension)\n//                 [\"-\" privateuse]\nvar langtag = language + '(?:-' + script + ')?(?:-' + region + ')?(?:-' + variant + ')*(?:-' + extension + ')*(?:-' + privateuse + ')?';\n\n// Language-Tag  = langtag             ; normal language tags\n//               / privateuse          ; private use tag\n//               / grandfathered       ; grandfathered tags\nvar expBCP47Syntax = RegExp('^(?:' + langtag + '|' + privateuse + '|' + grandfathered + ')$', 'i');\n\n// Match duplicate variants in a language tag\nvar expVariantDupes = RegExp('^(?!x).*?-(' + variant + ')-(?:\\\\w{4,8}-(?!x-))*\\\\1\\\\b', 'i');\n\n// Match duplicate singletons in a language tag (except in private use)\nvar expSingletonDupes = RegExp('^(?!x).*?-(' + singleton + ')-(?:\\\\w+-(?!x-))*\\\\1\\\\b', 'i');\n\n// Match all extension sequences\nvar expExtSequences = RegExp('-' + extension, 'ig');\n\n// Default locale is the first-added locale data for us\nvar defaultLocale = void 0;\nfunction setDefaultLocale(locale) {\n    defaultLocale = locale;\n}\n\n// IANA Subtag Registry redundant tag and subtag maps\nvar redundantTags = {\n    tags: {\n        \"art-lojban\": \"jbo\",\n        \"i-ami\": \"ami\",\n        \"i-bnn\": \"bnn\",\n        \"i-hak\": \"hak\",\n        \"i-klingon\": \"tlh\",\n        \"i-lux\": \"lb\",\n        \"i-navajo\": \"nv\",\n        \"i-pwn\": \"pwn\",\n        \"i-tao\": \"tao\",\n        \"i-tay\": \"tay\",\n        \"i-tsu\": \"tsu\",\n        \"no-bok\": \"nb\",\n        \"no-nyn\": \"nn\",\n        \"sgn-BE-FR\": \"sfb\",\n        \"sgn-BE-NL\": \"vgt\",\n        \"sgn-CH-DE\": \"sgg\",\n        \"zh-guoyu\": \"cmn\",\n        \"zh-hakka\": \"hak\",\n        \"zh-min-nan\": \"nan\",\n        \"zh-xiang\": \"hsn\",\n        \"sgn-BR\": \"bzs\",\n        \"sgn-CO\": \"csn\",\n        \"sgn-DE\": \"gsg\",\n        \"sgn-DK\": \"dsl\",\n        \"sgn-ES\": \"ssp\",\n        \"sgn-FR\": \"fsl\",\n        \"sgn-GB\": \"bfi\",\n        \"sgn-GR\": \"gss\",\n        \"sgn-IE\": \"isg\",\n        \"sgn-IT\": \"ise\",\n        \"sgn-JP\": \"jsl\",\n        \"sgn-MX\": \"mfs\",\n        \"sgn-NI\": \"ncs\",\n        \"sgn-NL\": \"dse\",\n        \"sgn-NO\": \"nsl\",\n        \"sgn-PT\": \"psr\",\n        \"sgn-SE\": \"swl\",\n        \"sgn-US\": \"ase\",\n        \"sgn-ZA\": \"sfs\",\n        \"zh-cmn\": \"cmn\",\n        \"zh-cmn-Hans\": \"cmn-Hans\",\n        \"zh-cmn-Hant\": \"cmn-Hant\",\n        \"zh-gan\": \"gan\",\n        \"zh-wuu\": \"wuu\",\n        \"zh-yue\": \"yue\"\n    },\n    subtags: {\n        BU: \"MM\",\n        DD: \"DE\",\n        FX: \"FR\",\n        TP: \"TL\",\n        YD: \"YE\",\n        ZR: \"CD\",\n        heploc: \"alalc97\",\n        'in': \"id\",\n        iw: \"he\",\n        ji: \"yi\",\n        jw: \"jv\",\n        mo: \"ro\",\n        ayx: \"nun\",\n        bjd: \"drl\",\n        ccq: \"rki\",\n        cjr: \"mom\",\n        cka: \"cmr\",\n        cmk: \"xch\",\n        drh: \"khk\",\n        drw: \"prs\",\n        gav: \"dev\",\n        hrr: \"jal\",\n        ibi: \"opa\",\n        kgh: \"kml\",\n        lcq: \"ppr\",\n        mst: \"mry\",\n        myt: \"mry\",\n        sca: \"hle\",\n        tie: \"ras\",\n        tkk: \"twm\",\n        tlw: \"weo\",\n        tnf: \"prs\",\n        ybd: \"rki\",\n        yma: \"lrr\"\n    },\n    extLang: {\n        aao: [\"aao\", \"ar\"],\n        abh: [\"abh\", \"ar\"],\n        abv: [\"abv\", \"ar\"],\n        acm: [\"acm\", \"ar\"],\n        acq: [\"acq\", \"ar\"],\n        acw: [\"acw\", \"ar\"],\n        acx: [\"acx\", \"ar\"],\n        acy: [\"acy\", \"ar\"],\n        adf: [\"adf\", \"ar\"],\n        ads: [\"ads\", \"sgn\"],\n        aeb: [\"aeb\", \"ar\"],\n        aec: [\"aec\", \"ar\"],\n        aed: [\"aed\", \"sgn\"],\n        aen: [\"aen\", \"sgn\"],\n        afb: [\"afb\", \"ar\"],\n        afg: [\"afg\", \"sgn\"],\n        ajp: [\"ajp\", \"ar\"],\n        apc: [\"apc\", \"ar\"],\n        apd: [\"apd\", \"ar\"],\n        arb: [\"arb\", \"ar\"],\n        arq: [\"arq\", \"ar\"],\n        ars: [\"ars\", \"ar\"],\n        ary: [\"ary\", \"ar\"],\n        arz: [\"arz\", \"ar\"],\n        ase: [\"ase\", \"sgn\"],\n        asf: [\"asf\", \"sgn\"],\n        asp: [\"asp\", \"sgn\"],\n        asq: [\"asq\", \"sgn\"],\n        asw: [\"asw\", \"sgn\"],\n        auz: [\"auz\", \"ar\"],\n        avl: [\"avl\", \"ar\"],\n        ayh: [\"ayh\", \"ar\"],\n        ayl: [\"ayl\", \"ar\"],\n        ayn: [\"ayn\", \"ar\"],\n        ayp: [\"ayp\", \"ar\"],\n        bbz: [\"bbz\", \"ar\"],\n        bfi: [\"bfi\", \"sgn\"],\n        bfk: [\"bfk\", \"sgn\"],\n        bjn: [\"bjn\", \"ms\"],\n        bog: [\"bog\", \"sgn\"],\n        bqn: [\"bqn\", \"sgn\"],\n        bqy: [\"bqy\", \"sgn\"],\n        btj: [\"btj\", \"ms\"],\n        bve: [\"bve\", \"ms\"],\n        bvl: [\"bvl\", \"sgn\"],\n        bvu: [\"bvu\", \"ms\"],\n        bzs: [\"bzs\", \"sgn\"],\n        cdo: [\"cdo\", \"zh\"],\n        cds: [\"cds\", \"sgn\"],\n        cjy: [\"cjy\", \"zh\"],\n        cmn: [\"cmn\", \"zh\"],\n        coa: [\"coa\", \"ms\"],\n        cpx: [\"cpx\", \"zh\"],\n        csc: [\"csc\", \"sgn\"],\n        csd: [\"csd\", \"sgn\"],\n        cse: [\"cse\", \"sgn\"],\n        csf: [\"csf\", \"sgn\"],\n        csg: [\"csg\", \"sgn\"],\n        csl: [\"csl\", \"sgn\"],\n        csn: [\"csn\", \"sgn\"],\n        csq: [\"csq\", \"sgn\"],\n        csr: [\"csr\", \"sgn\"],\n        czh: [\"czh\", \"zh\"],\n        czo: [\"czo\", \"zh\"],\n        doq: [\"doq\", \"sgn\"],\n        dse: [\"dse\", \"sgn\"],\n        dsl: [\"dsl\", \"sgn\"],\n        dup: [\"dup\", \"ms\"],\n        ecs: [\"ecs\", \"sgn\"],\n        esl: [\"esl\", \"sgn\"],\n        esn: [\"esn\", \"sgn\"],\n        eso: [\"eso\", \"sgn\"],\n        eth: [\"eth\", \"sgn\"],\n        fcs: [\"fcs\", \"sgn\"],\n        fse: [\"fse\", \"sgn\"],\n        fsl: [\"fsl\", \"sgn\"],\n        fss: [\"fss\", \"sgn\"],\n        gan: [\"gan\", \"zh\"],\n        gds: [\"gds\", \"sgn\"],\n        gom: [\"gom\", \"kok\"],\n        gse: [\"gse\", \"sgn\"],\n        gsg: [\"gsg\", \"sgn\"],\n        gsm: [\"gsm\", \"sgn\"],\n        gss: [\"gss\", \"sgn\"],\n        gus: [\"gus\", \"sgn\"],\n        hab: [\"hab\", \"sgn\"],\n        haf: [\"haf\", \"sgn\"],\n        hak: [\"hak\", \"zh\"],\n        hds: [\"hds\", \"sgn\"],\n        hji: [\"hji\", \"ms\"],\n        hks: [\"hks\", \"sgn\"],\n        hos: [\"hos\", \"sgn\"],\n        hps: [\"hps\", \"sgn\"],\n        hsh: [\"hsh\", \"sgn\"],\n        hsl: [\"hsl\", \"sgn\"],\n        hsn: [\"hsn\", \"zh\"],\n        icl: [\"icl\", \"sgn\"],\n        ils: [\"ils\", \"sgn\"],\n        inl: [\"inl\", \"sgn\"],\n        ins: [\"ins\", \"sgn\"],\n        ise: [\"ise\", \"sgn\"],\n        isg: [\"isg\", \"sgn\"],\n        isr: [\"isr\", \"sgn\"],\n        jak: [\"jak\", \"ms\"],\n        jax: [\"jax\", \"ms\"],\n        jcs: [\"jcs\", \"sgn\"],\n        jhs: [\"jhs\", \"sgn\"],\n        jls: [\"jls\", \"sgn\"],\n        jos: [\"jos\", \"sgn\"],\n        jsl: [\"jsl\", \"sgn\"],\n        jus: [\"jus\", \"sgn\"],\n        kgi: [\"kgi\", \"sgn\"],\n        knn: [\"knn\", \"kok\"],\n        kvb: [\"kvb\", \"ms\"],\n        kvk: [\"kvk\", \"sgn\"],\n        kvr: [\"kvr\", \"ms\"],\n        kxd: [\"kxd\", \"ms\"],\n        lbs: [\"lbs\", \"sgn\"],\n        lce: [\"lce\", \"ms\"],\n        lcf: [\"lcf\", \"ms\"],\n        liw: [\"liw\", \"ms\"],\n        lls: [\"lls\", \"sgn\"],\n        lsg: [\"lsg\", \"sgn\"],\n        lsl: [\"lsl\", \"sgn\"],\n        lso: [\"lso\", \"sgn\"],\n        lsp: [\"lsp\", \"sgn\"],\n        lst: [\"lst\", \"sgn\"],\n        lsy: [\"lsy\", \"sgn\"],\n        ltg: [\"ltg\", \"lv\"],\n        lvs: [\"lvs\", \"lv\"],\n        lzh: [\"lzh\", \"zh\"],\n        max: [\"max\", \"ms\"],\n        mdl: [\"mdl\", \"sgn\"],\n        meo: [\"meo\", \"ms\"],\n        mfa: [\"mfa\", \"ms\"],\n        mfb: [\"mfb\", \"ms\"],\n        mfs: [\"mfs\", \"sgn\"],\n        min: [\"min\", \"ms\"],\n        mnp: [\"mnp\", \"zh\"],\n        mqg: [\"mqg\", \"ms\"],\n        mre: [\"mre\", \"sgn\"],\n        msd: [\"msd\", \"sgn\"],\n        msi: [\"msi\", \"ms\"],\n        msr: [\"msr\", \"sgn\"],\n        mui: [\"mui\", \"ms\"],\n        mzc: [\"mzc\", \"sgn\"],\n        mzg: [\"mzg\", \"sgn\"],\n        mzy: [\"mzy\", \"sgn\"],\n        nan: [\"nan\", \"zh\"],\n        nbs: [\"nbs\", \"sgn\"],\n        ncs: [\"ncs\", \"sgn\"],\n        nsi: [\"nsi\", \"sgn\"],\n        nsl: [\"nsl\", \"sgn\"],\n        nsp: [\"nsp\", \"sgn\"],\n        nsr: [\"nsr\", \"sgn\"],\n        nzs: [\"nzs\", \"sgn\"],\n        okl: [\"okl\", \"sgn\"],\n        orn: [\"orn\", \"ms\"],\n        ors: [\"ors\", \"ms\"],\n        pel: [\"pel\", \"ms\"],\n        pga: [\"pga\", \"ar\"],\n        pks: [\"pks\", \"sgn\"],\n        prl: [\"prl\", \"sgn\"],\n        prz: [\"prz\", \"sgn\"],\n        psc: [\"psc\", \"sgn\"],\n        psd: [\"psd\", \"sgn\"],\n        pse: [\"pse\", \"ms\"],\n        psg: [\"psg\", \"sgn\"],\n        psl: [\"psl\", \"sgn\"],\n        pso: [\"pso\", \"sgn\"],\n        psp: [\"psp\", \"sgn\"],\n        psr: [\"psr\", \"sgn\"],\n        pys: [\"pys\", \"sgn\"],\n        rms: [\"rms\", \"sgn\"],\n        rsi: [\"rsi\", \"sgn\"],\n        rsl: [\"rsl\", \"sgn\"],\n        sdl: [\"sdl\", \"sgn\"],\n        sfb: [\"sfb\", \"sgn\"],\n        sfs: [\"sfs\", \"sgn\"],\n        sgg: [\"sgg\", \"sgn\"],\n        sgx: [\"sgx\", \"sgn\"],\n        shu: [\"shu\", \"ar\"],\n        slf: [\"slf\", \"sgn\"],\n        sls: [\"sls\", \"sgn\"],\n        sqk: [\"sqk\", \"sgn\"],\n        sqs: [\"sqs\", \"sgn\"],\n        ssh: [\"ssh\", \"ar\"],\n        ssp: [\"ssp\", \"sgn\"],\n        ssr: [\"ssr\", \"sgn\"],\n        svk: [\"svk\", \"sgn\"],\n        swc: [\"swc\", \"sw\"],\n        swh: [\"swh\", \"sw\"],\n        swl: [\"swl\", \"sgn\"],\n        syy: [\"syy\", \"sgn\"],\n        tmw: [\"tmw\", \"ms\"],\n        tse: [\"tse\", \"sgn\"],\n        tsm: [\"tsm\", \"sgn\"],\n        tsq: [\"tsq\", \"sgn\"],\n        tss: [\"tss\", \"sgn\"],\n        tsy: [\"tsy\", \"sgn\"],\n        tza: [\"tza\", \"sgn\"],\n        ugn: [\"ugn\", \"sgn\"],\n        ugy: [\"ugy\", \"sgn\"],\n        ukl: [\"ukl\", \"sgn\"],\n        uks: [\"uks\", \"sgn\"],\n        urk: [\"urk\", \"ms\"],\n        uzn: [\"uzn\", \"uz\"],\n        uzs: [\"uzs\", \"uz\"],\n        vgt: [\"vgt\", \"sgn\"],\n        vkk: [\"vkk\", \"ms\"],\n        vkt: [\"vkt\", \"ms\"],\n        vsi: [\"vsi\", \"sgn\"],\n        vsl: [\"vsl\", \"sgn\"],\n        vsv: [\"vsv\", \"sgn\"],\n        wuu: [\"wuu\", \"zh\"],\n        xki: [\"xki\", \"sgn\"],\n        xml: [\"xml\", \"sgn\"],\n        xmm: [\"xmm\", \"ms\"],\n        xms: [\"xms\", \"sgn\"],\n        yds: [\"yds\", \"sgn\"],\n        ysl: [\"ysl\", \"sgn\"],\n        yue: [\"yue\", \"zh\"],\n        zib: [\"zib\", \"sgn\"],\n        zlm: [\"zlm\", \"ms\"],\n        zmi: [\"zmi\", \"ms\"],\n        zsl: [\"zsl\", \"sgn\"],\n        zsm: [\"zsm\", \"ms\"]\n    }\n};\n\n/**\n * Convert only a-z to uppercase as per section 6.1 of the spec\n */\nfunction toLatinUpperCase(str) {\n    var i = str.length;\n\n    while (i--) {\n        var ch = str.charAt(i);\n\n        if (ch >= \"a\" && ch <= \"z\") str = str.slice(0, i) + ch.toUpperCase() + str.slice(i + 1);\n    }\n\n    return str;\n}\n\n/**\n * The IsStructurallyValidLanguageTag abstract operation verifies that the locale\n * argument (which must be a String value)\n *\n * - represents a well-formed BCP 47 language tag as specified in RFC 5646 section\n *   2.1, or successor,\n * - does not include duplicate variant subtags, and\n * - does not include duplicate singleton subtags.\n *\n * The abstract operation returns true if locale can be generated from the ABNF\n * grammar in section 2.1 of the RFC, starting with Language-Tag, and does not\n * contain duplicate variant or singleton subtags (other than as a private use\n * subtag). It returns false otherwise. Terminal value characters in the grammar are\n * interpreted as the Unicode equivalents of the ASCII octet values given.\n */\nfunction /* 6.2.2 */IsStructurallyValidLanguageTag(locale) {\n    // represents a well-formed BCP 47 language tag as specified in RFC 5646\n    if (!expBCP47Syntax.test(locale)) return false;\n\n    // does not include duplicate variant subtags, and\n    if (expVariantDupes.test(locale)) return false;\n\n    // does not include duplicate singleton subtags.\n    if (expSingletonDupes.test(locale)) return false;\n\n    return true;\n}\n\n/**\n * The CanonicalizeLanguageTag abstract operation returns the canonical and case-\n * regularized form of the locale argument (which must be a String value that is\n * a structurally valid BCP 47 language tag as verified by the\n * IsStructurallyValidLanguageTag abstract operation). It takes the steps\n * specified in RFC 5646 section 4.5, or successor, to bring the language tag\n * into canonical form, and to regularize the case of the subtags, but does not\n * take the steps to bring a language tag into extlang form and to reorder\n * variant subtags.\n\n * The specifications for extensions to BCP 47 language tags, such as RFC 6067,\n * may include canonicalization rules for the extension subtag sequences they\n * define that go beyond the canonicalization rules of RFC 5646 section 4.5.\n * Implementations are allowed, but not required, to apply these additional rules.\n */\nfunction /* 6.2.3 */CanonicalizeLanguageTag(locale) {\n    var match = void 0,\n        parts = void 0;\n\n    // A language tag is in 'canonical form' when the tag is well-formed\n    // according to the rules in Sections 2.1 and 2.2\n\n    // Section 2.1 says all subtags use lowercase...\n    locale = locale.toLowerCase();\n\n    // ...with 2 exceptions: 'two-letter and four-letter subtags that neither\n    // appear at the start of the tag nor occur after singletons.  Such two-letter\n    // subtags are all uppercase (as in the tags \"en-CA-x-ca\" or \"sgn-BE-FR\") and\n    // four-letter subtags are titlecase (as in the tag \"az-Latn-x-latn\").\n    parts = locale.split('-');\n    for (var i = 1, max = parts.length; i < max; i++) {\n        // Two-letter subtags are all uppercase\n        if (parts[i].length === 2) parts[i] = parts[i].toUpperCase();\n\n        // Four-letter subtags are titlecase\n        else if (parts[i].length === 4) parts[i] = parts[i].charAt(0).toUpperCase() + parts[i].slice(1);\n\n            // Is it a singleton?\n            else if (parts[i].length === 1 && parts[i] !== 'x') break;\n    }\n    locale = arrJoin.call(parts, '-');\n\n    // The steps laid out in RFC 5646 section 4.5 are as follows:\n\n    // 1.  Extension sequences are ordered into case-insensitive ASCII order\n    //     by singleton subtag.\n    if ((match = locale.match(expExtSequences)) && match.length > 1) {\n        // The built-in sort() sorts by ASCII order, so use that\n        match.sort();\n\n        // Replace all extensions with the joined, sorted array\n        locale = locale.replace(RegExp('(?:' + expExtSequences.source + ')+', 'i'), arrJoin.call(match, ''));\n    }\n\n    // 2.  Redundant or grandfathered tags are replaced by their 'Preferred-\n    //     Value', if there is one.\n    if (hop.call(redundantTags.tags, locale)) locale = redundantTags.tags[locale];\n\n    // 3.  Subtags are replaced by their 'Preferred-Value', if there is one.\n    //     For extlangs, the original primary language subtag is also\n    //     replaced if there is a primary language subtag in the 'Preferred-\n    //     Value'.\n    parts = locale.split('-');\n\n    for (var _i = 1, _max = parts.length; _i < _max; _i++) {\n        if (hop.call(redundantTags.subtags, parts[_i])) parts[_i] = redundantTags.subtags[parts[_i]];else if (hop.call(redundantTags.extLang, parts[_i])) {\n            parts[_i] = redundantTags.extLang[parts[_i]][0];\n\n            // For extlang tags, the prefix needs to be removed if it is redundant\n            if (_i === 1 && redundantTags.extLang[parts[1]][1] === parts[0]) {\n                parts = arrSlice.call(parts, _i++);\n                _max -= 1;\n            }\n        }\n    }\n\n    return arrJoin.call(parts, '-');\n}\n\n/**\n * The DefaultLocale abstract operation returns a String value representing the\n * structurally valid (6.2.2) and canonicalized (6.2.3) BCP 47 language tag for the\n * host environments current locale.\n */\nfunction /* 6.2.4 */DefaultLocale() {\n    return defaultLocale;\n}\n\n// Sect 6.3 Currency Codes\n// =======================\n\nvar expCurrencyCode = /^[A-Z]{3}$/;\n\n/**\n * The IsWellFormedCurrencyCode abstract operation verifies that the currency argument\n * (after conversion to a String value) represents a well-formed 3-letter ISO currency\n * code. The following steps are taken:\n */\nfunction /* 6.3.1 */IsWellFormedCurrencyCode(currency) {\n    // 1. Let `c` be ToString(currency)\n    var c = String(currency);\n\n    // 2. Let `normalized` be the result of mapping c to upper case as described\n    //    in 6.1.\n    var normalized = toLatinUpperCase(c);\n\n    // 3. If the string length of normalized is not 3, return false.\n    // 4. If normalized contains any character that is not in the range \"A\" to \"Z\"\n    //    (U+0041 to U+005A), return false.\n    if (expCurrencyCode.test(normalized) === false) return false;\n\n    // 5. Return true\n    return true;\n}\n\nvar expUnicodeExSeq = /-u(?:-[0-9a-z]{2,8})+/gi; // See `extension` below\n\nfunction /* 9.2.1 */CanonicalizeLocaleList(locales) {\n    // The abstract operation CanonicalizeLocaleList takes the following steps:\n\n    // 1. If locales is undefined, then a. Return a new empty List\n    if (locales === undefined) return new List();\n\n    // 2. Let seen be a new empty List.\n    var seen = new List();\n\n    // 3. If locales is a String value, then\n    //    a. Let locales be a new array created as if by the expression new\n    //    Array(locales) where Array is the standard built-in constructor with\n    //    that name and locales is the value of locales.\n    locales = typeof locales === 'string' ? [locales] : locales;\n\n    // 4. Let O be ToObject(locales).\n    var O = toObject(locales);\n\n    // 5. Let lenValue be the result of calling the [[Get]] internal method of\n    //    O with the argument \"length\".\n    // 6. Let len be ToUint32(lenValue).\n    var len = O.length;\n\n    // 7. Let k be 0.\n    var k = 0;\n\n    // 8. Repeat, while k < len\n    while (k < len) {\n        // a. Let Pk be ToString(k).\n        var Pk = String(k);\n\n        // b. Let kPresent be the result of calling the [[HasProperty]] internal\n        //    method of O with argument Pk.\n        var kPresent = Pk in O;\n\n        // c. If kPresent is true, then\n        if (kPresent) {\n            // i. Let kValue be the result of calling the [[Get]] internal\n            //     method of O with argument Pk.\n            var kValue = O[Pk];\n\n            // ii. If the type of kValue is not String or Object, then throw a\n            //     TypeError exception.\n            if (kValue === null || typeof kValue !== 'string' && (typeof kValue === \"undefined\" ? \"undefined\" : babelHelpers[\"typeof\"](kValue)) !== 'object') throw new TypeError('String or Object type expected');\n\n            // iii. Let tag be ToString(kValue).\n            var tag = String(kValue);\n\n            // iv. If the result of calling the abstract operation\n            //     IsStructurallyValidLanguageTag (defined in 6.2.2), passing tag as\n            //     the argument, is false, then throw a RangeError exception.\n            if (!IsStructurallyValidLanguageTag(tag)) throw new RangeError(\"'\" + tag + \"' is not a structurally valid language tag\");\n\n            // v. Let tag be the result of calling the abstract operation\n            //    CanonicalizeLanguageTag (defined in 6.2.3), passing tag as the\n            //    argument.\n            tag = CanonicalizeLanguageTag(tag);\n\n            // vi. If tag is not an element of seen, then append tag as the last\n            //     element of seen.\n            if (arrIndexOf.call(seen, tag) === -1) arrPush.call(seen, tag);\n        }\n\n        // d. Increase k by 1.\n        k++;\n    }\n\n    // 9. Return seen.\n    return seen;\n}\n\n/**\n * The BestAvailableLocale abstract operation compares the provided argument\n * locale, which must be a String value with a structurally valid and\n * canonicalized BCP 47 language tag, against the locales in availableLocales and\n * returns either the longest non-empty prefix of locale that is an element of\n * availableLocales, or undefined if there is no such element. It uses the\n * fallback mechanism of RFC 4647, section 3.4. The following steps are taken:\n */\nfunction /* 9.2.2 */BestAvailableLocale(availableLocales, locale) {\n    // 1. Let candidate be locale\n    var candidate = locale;\n\n    // 2. Repeat\n    while (candidate) {\n        // a. If availableLocales contains an element equal to candidate, then return\n        // candidate.\n        if (arrIndexOf.call(availableLocales, candidate) > -1) return candidate;\n\n        // b. Let pos be the character index of the last occurrence of \"-\"\n        // (U+002D) within candidate. If that character does not occur, return\n        // undefined.\n        var pos = candidate.lastIndexOf('-');\n\n        if (pos < 0) return;\n\n        // c. If pos  2 and the character \"-\" occurs at index pos-2 of candidate,\n        //    then decrease pos by 2.\n        if (pos >= 2 && candidate.charAt(pos - 2) === '-') pos -= 2;\n\n        // d. Let candidate be the substring of candidate from position 0, inclusive,\n        //    to position pos, exclusive.\n        candidate = candidate.substring(0, pos);\n    }\n}\n\n/**\n * The LookupMatcher abstract operation compares requestedLocales, which must be\n * a List as returned by CanonicalizeLocaleList, against the locales in\n * availableLocales and determines the best available language to meet the\n * request. The following steps are taken:\n */\nfunction /* 9.2.3 */LookupMatcher(availableLocales, requestedLocales) {\n    // 1. Let i be 0.\n    var i = 0;\n\n    // 2. Let len be the number of elements in requestedLocales.\n    var len = requestedLocales.length;\n\n    // 3. Let availableLocale be undefined.\n    var availableLocale = void 0;\n\n    var locale = void 0,\n        noExtensionsLocale = void 0;\n\n    // 4. Repeat while i < len and availableLocale is undefined:\n    while (i < len && !availableLocale) {\n        // a. Let locale be the element of requestedLocales at 0-origined list\n        //    position i.\n        locale = requestedLocales[i];\n\n        // b. Let noExtensionsLocale be the String value that is locale with all\n        //    Unicode locale extension sequences removed.\n        noExtensionsLocale = String(locale).replace(expUnicodeExSeq, '');\n\n        // c. Let availableLocale be the result of calling the\n        //    BestAvailableLocale abstract operation (defined in 9.2.2) with\n        //    arguments availableLocales and noExtensionsLocale.\n        availableLocale = BestAvailableLocale(availableLocales, noExtensionsLocale);\n\n        // d. Increase i by 1.\n        i++;\n    }\n\n    // 5. Let result be a new Record.\n    var result = new Record();\n\n    // 6. If availableLocale is not undefined, then\n    if (availableLocale !== undefined) {\n        // a. Set result.[[locale]] to availableLocale.\n        result['[[locale]]'] = availableLocale;\n\n        // b. If locale and noExtensionsLocale are not the same String value, then\n        if (String(locale) !== String(noExtensionsLocale)) {\n            // i. Let extension be the String value consisting of the first\n            //    substring of locale that is a Unicode locale extension sequence.\n            var extension = locale.match(expUnicodeExSeq)[0];\n\n            // ii. Let extensionIndex be the character position of the initial\n            //     \"-\" of the first Unicode locale extension sequence within locale.\n            var extensionIndex = locale.indexOf('-u-');\n\n            // iii. Set result.[[extension]] to extension.\n            result['[[extension]]'] = extension;\n\n            // iv. Set result.[[extensionIndex]] to extensionIndex.\n            result['[[extensionIndex]]'] = extensionIndex;\n        }\n    }\n    // 7. Else\n    else\n        // a. Set result.[[locale]] to the value returned by the DefaultLocale abstract\n        //    operation (defined in 6.2.4).\n        result['[[locale]]'] = DefaultLocale();\n\n    // 8. Return result\n    return result;\n}\n\n/**\n * The BestFitMatcher abstract operation compares requestedLocales, which must be\n * a List as returned by CanonicalizeLocaleList, against the locales in\n * availableLocales and determines the best available language to meet the\n * request. The algorithm is implementation dependent, but should produce results\n * that a typical user of the requested locales would perceive as at least as\n * good as those produced by the LookupMatcher abstract operation. Options\n * specified through Unicode locale extension sequences must be ignored by the\n * algorithm. Information about such subsequences is returned separately.\n * The abstract operation returns a record with a [[locale]] field, whose value\n * is the language tag of the selected locale, which must be an element of\n * availableLocales. If the language tag of the request locale that led to the\n * selected locale contained a Unicode locale extension sequence, then the\n * returned record also contains an [[extension]] field whose value is the first\n * Unicode locale extension sequence, and an [[extensionIndex]] field whose value\n * is the index of the first Unicode locale extension sequence within the request\n * locale language tag.\n */\nfunction /* 9.2.4 */BestFitMatcher(availableLocales, requestedLocales) {\n    return LookupMatcher(availableLocales, requestedLocales);\n}\n\n/**\n * The ResolveLocale abstract operation compares a BCP 47 language priority list\n * requestedLocales against the locales in availableLocales and determines the\n * best available language to meet the request. availableLocales and\n * requestedLocales must be provided as List values, options as a Record.\n */\nfunction /* 9.2.5 */ResolveLocale(availableLocales, requestedLocales, options, relevantExtensionKeys, localeData) {\n    if (availableLocales.length === 0) {\n        throw new ReferenceError('No locale data has been provided for this object yet.');\n    }\n\n    // The following steps are taken:\n    // 1. Let matcher be the value of options.[[localeMatcher]].\n    var matcher = options['[[localeMatcher]]'];\n\n    var r = void 0;\n\n    // 2. If matcher is \"lookup\", then\n    if (matcher === 'lookup')\n        // a. Let r be the result of calling the LookupMatcher abstract operation\n        //    (defined in 9.2.3) with arguments availableLocales and\n        //    requestedLocales.\n        r = LookupMatcher(availableLocales, requestedLocales);\n\n        // 3. Else\n    else\n        // a. Let r be the result of calling the BestFitMatcher abstract\n        //    operation (defined in 9.2.4) with arguments availableLocales and\n        //    requestedLocales.\n        r = BestFitMatcher(availableLocales, requestedLocales);\n\n    // 4. Let foundLocale be the value of r.[[locale]].\n    var foundLocale = r['[[locale]]'];\n\n    var extensionSubtags = void 0,\n        extensionSubtagsLength = void 0;\n\n    // 5. If r has an [[extension]] field, then\n    if (hop.call(r, '[[extension]]')) {\n        // a. Let extension be the value of r.[[extension]].\n        var extension = r['[[extension]]'];\n        // b. Let split be the standard built-in function object defined in ES5,\n        //    15.5.4.14.\n        var split = String.prototype.split;\n        // c. Let extensionSubtags be the result of calling the [[Call]] internal\n        //    method of split with extension as the this value and an argument\n        //    list containing the single item \"-\".\n        extensionSubtags = split.call(extension, '-');\n        // d. Let extensionSubtagsLength be the result of calling the [[Get]]\n        //    internal method of extensionSubtags with argument \"length\".\n        extensionSubtagsLength = extensionSubtags.length;\n    }\n\n    // 6. Let result be a new Record.\n    var result = new Record();\n\n    // 7. Set result.[[dataLocale]] to foundLocale.\n    result['[[dataLocale]]'] = foundLocale;\n\n    // 8. Let supportedExtension be \"-u\".\n    var supportedExtension = '-u';\n    // 9. Let i be 0.\n    var i = 0;\n    // 10. Let len be the result of calling the [[Get]] internal method of\n    //     relevantExtensionKeys with argument \"length\".\n    var len = relevantExtensionKeys.length;\n\n    // 11 Repeat while i < len:\n    while (i < len) {\n        // a. Let key be the result of calling the [[Get]] internal method of\n        //    relevantExtensionKeys with argument ToString(i).\n        var key = relevantExtensionKeys[i];\n        // b. Let foundLocaleData be the result of calling the [[Get]] internal\n        //    method of localeData with the argument foundLocale.\n        var foundLocaleData = localeData[foundLocale];\n        // c. Let keyLocaleData be the result of calling the [[Get]] internal\n        //    method of foundLocaleData with the argument key.\n        var keyLocaleData = foundLocaleData[key];\n        // d. Let value be the result of calling the [[Get]] internal method of\n        //    keyLocaleData with argument \"0\".\n        var value = keyLocaleData['0'];\n        // e. Let supportedExtensionAddition be \"\".\n        var supportedExtensionAddition = '';\n        // f. Let indexOf be the standard built-in function object defined in\n        //    ES5, 15.4.4.14.\n        var indexOf = arrIndexOf;\n\n        // g. If extensionSubtags is not undefined, then\n        if (extensionSubtags !== undefined) {\n            // i. Let keyPos be the result of calling the [[Call]] internal\n            //    method of indexOf with extensionSubtags as the this value and\n            // an argument list containing the single item key.\n            var keyPos = indexOf.call(extensionSubtags, key);\n\n            // ii. If keyPos  -1, then\n            if (keyPos !== -1) {\n                // 1. If keyPos + 1 < extensionSubtagsLength and the length of the\n                //    result of calling the [[Get]] internal method of\n                //    extensionSubtags with argument ToString(keyPos +1) is greater\n                //    than 2, then\n                if (keyPos + 1 < extensionSubtagsLength && extensionSubtags[keyPos + 1].length > 2) {\n                    // a. Let requestedValue be the result of calling the [[Get]]\n                    //    internal method of extensionSubtags with argument\n                    //    ToString(keyPos + 1).\n                    var requestedValue = extensionSubtags[keyPos + 1];\n                    // b. Let valuePos be the result of calling the [[Call]]\n                    //    internal method of indexOf with keyLocaleData as the\n                    //    this value and an argument list containing the single\n                    //    item requestedValue.\n                    var valuePos = indexOf.call(keyLocaleData, requestedValue);\n\n                    // c. If valuePos  -1, then\n                    if (valuePos !== -1) {\n                        // i. Let value be requestedValue.\n                        value = requestedValue,\n                        // ii. Let supportedExtensionAddition be the\n                        //     concatenation of \"-\", key, \"-\", and value.\n                        supportedExtensionAddition = '-' + key + '-' + value;\n                    }\n                }\n                // 2. Else\n                else {\n                        // a. Let valuePos be the result of calling the [[Call]]\n                        // internal method of indexOf with keyLocaleData as the this\n                        // value and an argument list containing the single item\n                        // \"true\".\n                        var _valuePos = indexOf(keyLocaleData, 'true');\n\n                        // b. If valuePos  -1, then\n                        if (_valuePos !== -1)\n                            // i. Let value be \"true\".\n                            value = 'true';\n                    }\n            }\n        }\n        // h. If options has a field [[<key>]], then\n        if (hop.call(options, '[[' + key + ']]')) {\n            // i. Let optionsValue be the value of options.[[<key>]].\n            var optionsValue = options['[[' + key + ']]'];\n\n            // ii. If the result of calling the [[Call]] internal method of indexOf\n            //     with keyLocaleData as the this value and an argument list\n            //     containing the single item optionsValue is not -1, then\n            if (indexOf.call(keyLocaleData, optionsValue) !== -1) {\n                // 1. If optionsValue is not equal to value, then\n                if (optionsValue !== value) {\n                    // a. Let value be optionsValue.\n                    value = optionsValue;\n                    // b. Let supportedExtensionAddition be \"\".\n                    supportedExtensionAddition = '';\n                }\n            }\n        }\n        // i. Set result.[[<key>]] to value.\n        result['[[' + key + ']]'] = value;\n\n        // j. Append supportedExtensionAddition to supportedExtension.\n        supportedExtension += supportedExtensionAddition;\n\n        // k. Increase i by 1.\n        i++;\n    }\n    // 12. If the length of supportedExtension is greater than 2, then\n    if (supportedExtension.length > 2) {\n        // a.\n        var privateIndex = foundLocale.indexOf(\"-x-\");\n        // b.\n        if (privateIndex === -1) {\n            // i.\n            foundLocale = foundLocale + supportedExtension;\n        }\n        // c.\n        else {\n                // i.\n                var preExtension = foundLocale.substring(0, privateIndex);\n                // ii.\n                var postExtension = foundLocale.substring(privateIndex);\n                // iii.\n                foundLocale = preExtension + supportedExtension + postExtension;\n            }\n        // d. asserting - skipping\n        // e.\n        foundLocale = CanonicalizeLanguageTag(foundLocale);\n    }\n    // 13. Set result.[[locale]] to foundLocale.\n    result['[[locale]]'] = foundLocale;\n\n    // 14. Return result.\n    return result;\n}\n\n/**\n * The LookupSupportedLocales abstract operation returns the subset of the\n * provided BCP 47 language priority list requestedLocales for which\n * availableLocales has a matching locale when using the BCP 47 Lookup algorithm.\n * Locales appear in the same order in the returned list as in requestedLocales.\n * The following steps are taken:\n */\nfunction /* 9.2.6 */LookupSupportedLocales(availableLocales, requestedLocales) {\n    // 1. Let len be the number of elements in requestedLocales.\n    var len = requestedLocales.length;\n    // 2. Let subset be a new empty List.\n    var subset = new List();\n    // 3. Let k be 0.\n    var k = 0;\n\n    // 4. Repeat while k < len\n    while (k < len) {\n        // a. Let locale be the element of requestedLocales at 0-origined list\n        //    position k.\n        var locale = requestedLocales[k];\n        // b. Let noExtensionsLocale be the String value that is locale with all\n        //    Unicode locale extension sequences removed.\n        var noExtensionsLocale = String(locale).replace(expUnicodeExSeq, '');\n        // c. Let availableLocale be the result of calling the\n        //    BestAvailableLocale abstract operation (defined in 9.2.2) with\n        //    arguments availableLocales and noExtensionsLocale.\n        var availableLocale = BestAvailableLocale(availableLocales, noExtensionsLocale);\n\n        // d. If availableLocale is not undefined, then append locale to the end of\n        //    subset.\n        if (availableLocale !== undefined) arrPush.call(subset, locale);\n\n        // e. Increment k by 1.\n        k++;\n    }\n\n    // 5. Let subsetArray be a new Array object whose elements are the same\n    //    values in the same order as the elements of subset.\n    var subsetArray = arrSlice.call(subset);\n\n    // 6. Return subsetArray.\n    return subsetArray;\n}\n\n/**\n * The BestFitSupportedLocales abstract operation returns the subset of the\n * provided BCP 47 language priority list requestedLocales for which\n * availableLocales has a matching locale when using the Best Fit Matcher\n * algorithm. Locales appear in the same order in the returned list as in\n * requestedLocales. The steps taken are implementation dependent.\n */\nfunction /*9.2.7 */BestFitSupportedLocales(availableLocales, requestedLocales) {\n    // ###TODO: implement this function as described by the specification###\n    return LookupSupportedLocales(availableLocales, requestedLocales);\n}\n\n/**\n * The SupportedLocales abstract operation returns the subset of the provided BCP\n * 47 language priority list requestedLocales for which availableLocales has a\n * matching locale. Two algorithms are available to match the locales: the Lookup\n * algorithm described in RFC 4647 section 3.4, and an implementation dependent\n * best-fit algorithm. Locales appear in the same order in the returned list as\n * in requestedLocales. The following steps are taken:\n */\nfunction /*9.2.8 */SupportedLocales(availableLocales, requestedLocales, options) {\n    var matcher = void 0,\n        subset = void 0;\n\n    // 1. If options is not undefined, then\n    if (options !== undefined) {\n        // a. Let options be ToObject(options).\n        options = new Record(toObject(options));\n        // b. Let matcher be the result of calling the [[Get]] internal method of\n        //    options with argument \"localeMatcher\".\n        matcher = options.localeMatcher;\n\n        // c. If matcher is not undefined, then\n        if (matcher !== undefined) {\n            // i. Let matcher be ToString(matcher).\n            matcher = String(matcher);\n\n            // ii. If matcher is not \"lookup\" or \"best fit\", then throw a RangeError\n            //     exception.\n            if (matcher !== 'lookup' && matcher !== 'best fit') throw new RangeError('matcher should be \"lookup\" or \"best fit\"');\n        }\n    }\n    // 2. If matcher is undefined or \"best fit\", then\n    if (matcher === undefined || matcher === 'best fit')\n        // a. Let subset be the result of calling the BestFitSupportedLocales\n        //    abstract operation (defined in 9.2.7) with arguments\n        //    availableLocales and requestedLocales.\n        subset = BestFitSupportedLocales(availableLocales, requestedLocales);\n        // 3. Else\n    else\n        // a. Let subset be the result of calling the LookupSupportedLocales\n        //    abstract operation (defined in 9.2.6) with arguments\n        //    availableLocales and requestedLocales.\n        subset = LookupSupportedLocales(availableLocales, requestedLocales);\n\n    // 4. For each named own property name P of subset,\n    for (var P in subset) {\n        if (!hop.call(subset, P)) continue;\n\n        // a. Let desc be the result of calling the [[GetOwnProperty]] internal\n        //    method of subset with P.\n        // b. Set desc.[[Writable]] to false.\n        // c. Set desc.[[Configurable]] to false.\n        // d. Call the [[DefineOwnProperty]] internal method of subset with P, desc,\n        //    and true as arguments.\n        defineProperty(subset, P, {\n            writable: false, configurable: false, value: subset[P]\n        });\n    }\n    // \"Freeze\" the array so no new elements can be added\n    defineProperty(subset, 'length', { writable: false });\n\n    // 5. Return subset\n    return subset;\n}\n\n/**\n * The GetOption abstract operation extracts the value of the property named\n * property from the provided options object, converts it to the required type,\n * checks whether it is one of a List of allowed values, and fills in a fallback\n * value if necessary.\n */\nfunction /*9.2.9 */GetOption(options, property, type, values, fallback) {\n    // 1. Let value be the result of calling the [[Get]] internal method of\n    //    options with argument property.\n    var value = options[property];\n\n    // 2. If value is not undefined, then\n    if (value !== undefined) {\n        // a. Assert: type is \"boolean\" or \"string\".\n        // b. If type is \"boolean\", then let value be ToBoolean(value).\n        // c. If type is \"string\", then let value be ToString(value).\n        value = type === 'boolean' ? Boolean(value) : type === 'string' ? String(value) : value;\n\n        // d. If values is not undefined, then\n        if (values !== undefined) {\n            // i. If values does not contain an element equal to value, then throw a\n            //    RangeError exception.\n            if (arrIndexOf.call(values, value) === -1) throw new RangeError(\"'\" + value + \"' is not an allowed value for `\" + property + '`');\n        }\n\n        // e. Return value.\n        return value;\n    }\n    // Else return fallback.\n    return fallback;\n}\n\n/**\n * The GetNumberOption abstract operation extracts a property value from the\n * provided options object, converts it to a Number value, checks whether it is\n * in the allowed range, and fills in a fallback value if necessary.\n */\nfunction /* 9.2.10 */GetNumberOption(options, property, minimum, maximum, fallback) {\n    // 1. Let value be the result of calling the [[Get]] internal method of\n    //    options with argument property.\n    var value = options[property];\n\n    // 2. If value is not undefined, then\n    if (value !== undefined) {\n        // a. Let value be ToNumber(value).\n        value = Number(value);\n\n        // b. If value is NaN or less than minimum or greater than maximum, throw a\n        //    RangeError exception.\n        if (isNaN(value) || value < minimum || value > maximum) throw new RangeError('Value is not a number or outside accepted range');\n\n        // c. Return floor(value).\n        return Math.floor(value);\n    }\n    // 3. Else return fallback.\n    return fallback;\n}\n\n// 8 The Intl Object\nvar Intl = {};\n\n// 8.2 Function Properties of the Intl Object\n\n// 8.2.1\n// @spec[tc39/ecma402/master/spec/intl.html]\n// @clause[sec-intl.getcanonicallocales]\nIntl.getCanonicalLocales = function (locales) {\n    // 1. Let ll be ? CanonicalizeLocaleList(locales).\n    var ll = CanonicalizeLocaleList(locales);\n    // 2. Return CreateArrayFromList(ll).\n    {\n        var result = [];\n        for (var code in ll) {\n            result.push(ll[code]);\n        }\n        return result;\n    }\n};\n\n// Currency minor units output from get-4217 grunt task, formatted\nvar currencyMinorUnits = {\n    BHD: 3, BYR: 0, XOF: 0, BIF: 0, XAF: 0, CLF: 4, CLP: 0, KMF: 0, DJF: 0,\n    XPF: 0, GNF: 0, ISK: 0, IQD: 3, JPY: 0, JOD: 3, KRW: 0, KWD: 3, LYD: 3,\n    OMR: 3, PYG: 0, RWF: 0, TND: 3, UGX: 0, UYI: 0, VUV: 0, VND: 0\n};\n\n// Define the NumberFormat constructor internally so it cannot be tainted\nfunction NumberFormatConstructor() {\n    var locales = arguments[0];\n    var options = arguments[1];\n\n    if (!this || this === Intl) {\n        return new Intl.NumberFormat(locales, options);\n    }\n\n    return InitializeNumberFormat(toObject(this), locales, options);\n}\n\ndefineProperty(Intl, 'NumberFormat', {\n    configurable: true,\n    writable: true,\n    value: NumberFormatConstructor\n});\n\n// Must explicitly set prototypes as unwritable\ndefineProperty(Intl.NumberFormat, 'prototype', {\n    writable: false\n});\n\n/**\n * The abstract operation InitializeNumberFormat accepts the arguments\n * numberFormat (which must be an object), locales, and options. It initializes\n * numberFormat as a NumberFormat object.\n */\nfunction /*11.1.1.1 */InitializeNumberFormat(numberFormat, locales, options) {\n    // This will be a internal properties object if we're not already initialized\n    var internal = getInternalProperties(numberFormat);\n\n    // Create an object whose props can be used to restore the values of RegExp props\n    var regexpState = createRegExpRestore();\n\n    // 1. If numberFormat has an [[initializedIntlObject]] internal property with\n    // value true, throw a TypeError exception.\n    if (internal['[[initializedIntlObject]]'] === true) throw new TypeError('`this` object has already been initialized as an Intl object');\n\n    // Need this to access the `internal` object\n    defineProperty(numberFormat, '__getInternalProperties', {\n        value: function value() {\n            // NOTE: Non-standard, for internal use only\n            if (arguments[0] === secret) return internal;\n        }\n    });\n\n    // 2. Set the [[initializedIntlObject]] internal property of numberFormat to true.\n    internal['[[initializedIntlObject]]'] = true;\n\n    // 3. Let requestedLocales be the result of calling the CanonicalizeLocaleList\n    //    abstract operation (defined in 9.2.1) with argument locales.\n    var requestedLocales = CanonicalizeLocaleList(locales);\n\n    // 4. If options is undefined, then\n    if (options === undefined)\n        // a. Let options be the result of creating a new object as if by the\n        // expression new Object() where Object is the standard built-in constructor\n        // with that name.\n        options = {};\n\n        // 5. Else\n    else\n        // a. Let options be ToObject(options).\n        options = toObject(options);\n\n    // 6. Let opt be a new Record.\n    var opt = new Record(),\n\n\n    // 7. Let matcher be the result of calling the GetOption abstract operation\n    //    (defined in 9.2.9) with the arguments options, \"localeMatcher\", \"string\",\n    //    a List containing the two String values \"lookup\" and \"best fit\", and\n    //    \"best fit\".\n    matcher = GetOption(options, 'localeMatcher', 'string', new List('lookup', 'best fit'), 'best fit');\n\n    // 8. Set opt.[[localeMatcher]] to matcher.\n    opt['[[localeMatcher]]'] = matcher;\n\n    // 9. Let NumberFormat be the standard built-in object that is the initial value\n    //    of Intl.NumberFormat.\n    // 10. Let localeData be the value of the [[localeData]] internal property of\n    //     NumberFormat.\n    var localeData = internals.NumberFormat['[[localeData]]'];\n\n    // 11. Let r be the result of calling the ResolveLocale abstract operation\n    //     (defined in 9.2.5) with the [[availableLocales]] internal property of\n    //     NumberFormat, requestedLocales, opt, the [[relevantExtensionKeys]]\n    //     internal property of NumberFormat, and localeData.\n    var r = ResolveLocale(internals.NumberFormat['[[availableLocales]]'], requestedLocales, opt, internals.NumberFormat['[[relevantExtensionKeys]]'], localeData);\n\n    // 12. Set the [[locale]] internal property of numberFormat to the value of\n    //     r.[[locale]].\n    internal['[[locale]]'] = r['[[locale]]'];\n\n    // 13. Set the [[numberingSystem]] internal property of numberFormat to the value\n    //     of r.[[nu]].\n    internal['[[numberingSystem]]'] = r['[[nu]]'];\n\n    // The specification doesn't tell us to do this, but it's helpful later on\n    internal['[[dataLocale]]'] = r['[[dataLocale]]'];\n\n    // 14. Let dataLocale be the value of r.[[dataLocale]].\n    var dataLocale = r['[[dataLocale]]'];\n\n    // 15. Let s be the result of calling the GetOption abstract operation with the\n    //     arguments options, \"style\", \"string\", a List containing the three String\n    //     values \"decimal\", \"percent\", and \"currency\", and \"decimal\".\n    var s = GetOption(options, 'style', 'string', new List('decimal', 'percent', 'currency'), 'decimal');\n\n    // 16. Set the [[style]] internal property of numberFormat to s.\n    internal['[[style]]'] = s;\n\n    // 17. Let c be the result of calling the GetOption abstract operation with the\n    //     arguments options, \"currency\", \"string\", undefined, and undefined.\n    var c = GetOption(options, 'currency', 'string');\n\n    // 18. If c is not undefined and the result of calling the\n    //     IsWellFormedCurrencyCode abstract operation (defined in 6.3.1) with\n    //     argument c is false, then throw a RangeError exception.\n    if (c !== undefined && !IsWellFormedCurrencyCode(c)) throw new RangeError(\"'\" + c + \"' is not a valid currency code\");\n\n    // 19. If s is \"currency\" and c is undefined, throw a TypeError exception.\n    if (s === 'currency' && c === undefined) throw new TypeError('Currency code is required when style is currency');\n\n    var cDigits = void 0;\n\n    // 20. If s is \"currency\", then\n    if (s === 'currency') {\n        // a. Let c be the result of converting c to upper case as specified in 6.1.\n        c = c.toUpperCase();\n\n        // b. Set the [[currency]] internal property of numberFormat to c.\n        internal['[[currency]]'] = c;\n\n        // c. Let cDigits be the result of calling the CurrencyDigits abstract\n        //    operation (defined below) with argument c.\n        cDigits = CurrencyDigits(c);\n    }\n\n    // 21. Let cd be the result of calling the GetOption abstract operation with the\n    //     arguments options, \"currencyDisplay\", \"string\", a List containing the\n    //     three String values \"code\", \"symbol\", and \"name\", and \"symbol\".\n    var cd = GetOption(options, 'currencyDisplay', 'string', new List('code', 'symbol', 'name'), 'symbol');\n\n    // 22. If s is \"currency\", then set the [[currencyDisplay]] internal property of\n    //     numberFormat to cd.\n    if (s === 'currency') internal['[[currencyDisplay]]'] = cd;\n\n    // 23. Let mnid be the result of calling the GetNumberOption abstract operation\n    //     (defined in 9.2.10) with arguments options, \"minimumIntegerDigits\", 1, 21,\n    //     and 1.\n    var mnid = GetNumberOption(options, 'minimumIntegerDigits', 1, 21, 1);\n\n    // 24. Set the [[minimumIntegerDigits]] internal property of numberFormat to mnid.\n    internal['[[minimumIntegerDigits]]'] = mnid;\n\n    // 25. If s is \"currency\", then let mnfdDefault be cDigits; else let mnfdDefault\n    //     be 0.\n    var mnfdDefault = s === 'currency' ? cDigits : 0;\n\n    // 26. Let mnfd be the result of calling the GetNumberOption abstract operation\n    //     with arguments options, \"minimumFractionDigits\", 0, 20, and mnfdDefault.\n    var mnfd = GetNumberOption(options, 'minimumFractionDigits', 0, 20, mnfdDefault);\n\n    // 27. Set the [[minimumFractionDigits]] internal property of numberFormat to mnfd.\n    internal['[[minimumFractionDigits]]'] = mnfd;\n\n    // 28. If s is \"currency\", then let mxfdDefault be max(mnfd, cDigits); else if s\n    //     is \"percent\", then let mxfdDefault be max(mnfd, 0); else let mxfdDefault\n    //     be max(mnfd, 3).\n    var mxfdDefault = s === 'currency' ? Math.max(mnfd, cDigits) : s === 'percent' ? Math.max(mnfd, 0) : Math.max(mnfd, 3);\n\n    // 29. Let mxfd be the result of calling the GetNumberOption abstract operation\n    //     with arguments options, \"maximumFractionDigits\", mnfd, 20, and mxfdDefault.\n    var mxfd = GetNumberOption(options, 'maximumFractionDigits', mnfd, 20, mxfdDefault);\n\n    // 30. Set the [[maximumFractionDigits]] internal property of numberFormat to mxfd.\n    internal['[[maximumFractionDigits]]'] = mxfd;\n\n    // 31. Let mnsd be the result of calling the [[Get]] internal method of options\n    //     with argument \"minimumSignificantDigits\".\n    var mnsd = options.minimumSignificantDigits;\n\n    // 32. Let mxsd be the result of calling the [[Get]] internal method of options\n    //     with argument \"maximumSignificantDigits\".\n    var mxsd = options.maximumSignificantDigits;\n\n    // 33. If mnsd is not undefined or mxsd is not undefined, then:\n    if (mnsd !== undefined || mxsd !== undefined) {\n        // a. Let mnsd be the result of calling the GetNumberOption abstract\n        //    operation with arguments options, \"minimumSignificantDigits\", 1, 21,\n        //    and 1.\n        mnsd = GetNumberOption(options, 'minimumSignificantDigits', 1, 21, 1);\n\n        // b. Let mxsd be the result of calling the GetNumberOption abstract\n        //     operation with arguments options, \"maximumSignificantDigits\", mnsd,\n        //     21, and 21.\n        mxsd = GetNumberOption(options, 'maximumSignificantDigits', mnsd, 21, 21);\n\n        // c. Set the [[minimumSignificantDigits]] internal property of numberFormat\n        //    to mnsd, and the [[maximumSignificantDigits]] internal property of\n        //    numberFormat to mxsd.\n        internal['[[minimumSignificantDigits]]'] = mnsd;\n        internal['[[maximumSignificantDigits]]'] = mxsd;\n    }\n    // 34. Let g be the result of calling the GetOption abstract operation with the\n    //     arguments options, \"useGrouping\", \"boolean\", undefined, and true.\n    var g = GetOption(options, 'useGrouping', 'boolean', undefined, true);\n\n    // 35. Set the [[useGrouping]] internal property of numberFormat to g.\n    internal['[[useGrouping]]'] = g;\n\n    // 36. Let dataLocaleData be the result of calling the [[Get]] internal method of\n    //     localeData with argument dataLocale.\n    var dataLocaleData = localeData[dataLocale];\n\n    // 37. Let patterns be the result of calling the [[Get]] internal method of\n    //     dataLocaleData with argument \"patterns\".\n    var patterns = dataLocaleData.patterns;\n\n    // 38. Assert: patterns is an object (see 11.2.3)\n\n    // 39. Let stylePatterns be the result of calling the [[Get]] internal method of\n    //     patterns with argument s.\n    var stylePatterns = patterns[s];\n\n    // 40. Set the [[positivePattern]] internal property of numberFormat to the\n    //     result of calling the [[Get]] internal method of stylePatterns with the\n    //     argument \"positivePattern\".\n    internal['[[positivePattern]]'] = stylePatterns.positivePattern;\n\n    // 41. Set the [[negativePattern]] internal property of numberFormat to the\n    //     result of calling the [[Get]] internal method of stylePatterns with the\n    //     argument \"negativePattern\".\n    internal['[[negativePattern]]'] = stylePatterns.negativePattern;\n\n    // 42. Set the [[boundFormat]] internal property of numberFormat to undefined.\n    internal['[[boundFormat]]'] = undefined;\n\n    // 43. Set the [[initializedNumberFormat]] internal property of numberFormat to\n    //     true.\n    internal['[[initializedNumberFormat]]'] = true;\n\n    // In ES3, we need to pre-bind the format() function\n    if (es3) numberFormat.format = GetFormatNumber.call(numberFormat);\n\n    // Restore the RegExp properties\n    regexpState.exp.test(regexpState.input);\n\n    // Return the newly initialised object\n    return numberFormat;\n}\n\nfunction CurrencyDigits(currency) {\n    // When the CurrencyDigits abstract operation is called with an argument currency\n    // (which must be an upper case String value), the following steps are taken:\n\n    // 1. If the ISO 4217 currency and funds code list contains currency as an\n    // alphabetic code, then return the minor unit value corresponding to the\n    // currency from the list; else return 2.\n    return currencyMinorUnits[currency] !== undefined ? currencyMinorUnits[currency] : 2;\n}\n\n/* 11.2.3 */internals.NumberFormat = {\n    '[[availableLocales]]': [],\n    '[[relevantExtensionKeys]]': ['nu'],\n    '[[localeData]]': {}\n};\n\n/**\n * When the supportedLocalesOf method of Intl.NumberFormat is called, the\n * following steps are taken:\n */\n/* 11.2.2 */\ndefineProperty(Intl.NumberFormat, 'supportedLocalesOf', {\n    configurable: true,\n    writable: true,\n    value: fnBind.call(function (locales) {\n        // Bound functions only have the `this` value altered if being used as a constructor,\n        // this lets us imitate a native function that has no constructor\n        if (!hop.call(this, '[[availableLocales]]')) throw new TypeError('supportedLocalesOf() is not a constructor');\n\n        // Create an object whose props can be used to restore the values of RegExp props\n        var regexpState = createRegExpRestore(),\n\n\n        // 1. If options is not provided, then let options be undefined.\n        options = arguments[1],\n\n\n        // 2. Let availableLocales be the value of the [[availableLocales]] internal\n        //    property of the standard built-in object that is the initial value of\n        //    Intl.NumberFormat.\n\n        availableLocales = this['[[availableLocales]]'],\n\n\n        // 3. Let requestedLocales be the result of calling the CanonicalizeLocaleList\n        //    abstract operation (defined in 9.2.1) with argument locales.\n        requestedLocales = CanonicalizeLocaleList(locales);\n\n        // Restore the RegExp properties\n        regexpState.exp.test(regexpState.input);\n\n        // 4. Return the result of calling the SupportedLocales abstract operation\n        //    (defined in 9.2.8) with arguments availableLocales, requestedLocales,\n        //    and options.\n        return SupportedLocales(availableLocales, requestedLocales, options);\n    }, internals.NumberFormat)\n});\n\n/**\n * This named accessor property returns a function that formats a number\n * according to the effective locale and the formatting options of this\n * NumberFormat object.\n */\n/* 11.3.2 */defineProperty(Intl.NumberFormat.prototype, 'format', {\n    configurable: true,\n    get: GetFormatNumber\n});\n\nfunction GetFormatNumber() {\n    var internal = this !== null && babelHelpers[\"typeof\"](this) === 'object' && getInternalProperties(this);\n\n    // Satisfy test 11.3_b\n    if (!internal || !internal['[[initializedNumberFormat]]']) throw new TypeError('`this` value for format() is not an initialized Intl.NumberFormat object.');\n\n    // The value of the [[Get]] attribute is a function that takes the following\n    // steps:\n\n    // 1. If the [[boundFormat]] internal property of this NumberFormat object\n    //    is undefined, then:\n    if (internal['[[boundFormat]]'] === undefined) {\n        // a. Let F be a Function object, with internal properties set as\n        //    specified for built-in functions in ES5, 15, or successor, and the\n        //    length property set to 1, that takes the argument value and\n        //    performs the following steps:\n        var F = function F(value) {\n            // i. If value is not provided, then let value be undefined.\n            // ii. Let x be ToNumber(value).\n            // iii. Return the result of calling the FormatNumber abstract\n            //      operation (defined below) with arguments this and x.\n            return FormatNumber(this, /* x = */Number(value));\n        };\n\n        // b. Let bind be the standard built-in function object defined in ES5,\n        //    15.3.4.5.\n        // c. Let bf be the result of calling the [[Call]] internal method of\n        //    bind with F as the this value and an argument list containing\n        //    the single item this.\n        var bf = fnBind.call(F, this);\n\n        // d. Set the [[boundFormat]] internal property of this NumberFormat\n        //    object to bf.\n        internal['[[boundFormat]]'] = bf;\n    }\n    // Return the value of the [[boundFormat]] internal property of this\n    // NumberFormat object.\n    return internal['[[boundFormat]]'];\n}\n\nIntl.NumberFormat.prototype.formatToParts = function (value) {\n    var internal = this !== null && babelHelpers[\"typeof\"](this) === 'object' && getInternalProperties(this);\n    if (!internal || !internal['[[initializedNumberFormat]]']) throw new TypeError('`this` value for formatToParts() is not an initialized Intl.NumberFormat object.');\n\n    var x = Number(value);\n    return FormatNumberToParts(this, x);\n};\n\n/*\n * @spec[stasm/ecma402/number-format-to-parts/spec/numberformat.html]\n * @clause[sec-formatnumbertoparts]\n */\nfunction FormatNumberToParts(numberFormat, x) {\n    // 1. Let parts be ? PartitionNumberPattern(numberFormat, x).\n    var parts = PartitionNumberPattern(numberFormat, x);\n    // 2. Let result be ArrayCreate(0).\n    var result = [];\n    // 3. Let n be 0.\n    var n = 0;\n    // 4. For each part in parts, do:\n    for (var i = 0; parts.length > i; i++) {\n        var part = parts[i];\n        // a. Let O be ObjectCreate(%ObjectPrototype%).\n        var O = {};\n        // a. Perform ? CreateDataPropertyOrThrow(O, \"type\", part.[[type]]).\n        O.type = part['[[type]]'];\n        // a. Perform ? CreateDataPropertyOrThrow(O, \"value\", part.[[value]]).\n        O.value = part['[[value]]'];\n        // a. Perform ? CreateDataPropertyOrThrow(result, ? ToString(n), O).\n        result[n] = O;\n        // a. Increment n by 1.\n        n += 1;\n    }\n    // 5. Return result.\n    return result;\n}\n\n/*\n * @spec[stasm/ecma402/number-format-to-parts/spec/numberformat.html]\n * @clause[sec-partitionnumberpattern]\n */\nfunction PartitionNumberPattern(numberFormat, x) {\n\n    var internal = getInternalProperties(numberFormat),\n        locale = internal['[[dataLocale]]'],\n        nums = internal['[[numberingSystem]]'],\n        data = internals.NumberFormat['[[localeData]]'][locale],\n        ild = data.symbols[nums] || data.symbols.latn,\n        pattern = void 0;\n\n    // 1. If x is not NaN and x < 0, then:\n    if (!isNaN(x) && x < 0) {\n        // a. Let x be -x.\n        x = -x;\n        // a. Let pattern be the value of numberFormat.[[negativePattern]].\n        pattern = internal['[[negativePattern]]'];\n    }\n    // 2. Else,\n    else {\n            // a. Let pattern be the value of numberFormat.[[positivePattern]].\n            pattern = internal['[[positivePattern]]'];\n        }\n    // 3. Let result be a new empty List.\n    var result = new List();\n    // 4. Let beginIndex be Call(%StringProto_indexOf%, pattern, \"{\", 0).\n    var beginIndex = pattern.indexOf('{', 0);\n    // 5. Let endIndex be 0.\n    var endIndex = 0;\n    // 6. Let nextIndex be 0.\n    var nextIndex = 0;\n    // 7. Let length be the number of code units in pattern.\n    var length = pattern.length;\n    // 8. Repeat while beginIndex is an integer index into pattern:\n    while (beginIndex > -1 && beginIndex < length) {\n        // a. Set endIndex to Call(%StringProto_indexOf%, pattern, \"}\", beginIndex)\n        endIndex = pattern.indexOf('}', beginIndex);\n        // a. If endIndex = -1, throw new Error exception.\n        if (endIndex === -1) throw new Error();\n        // a. If beginIndex is greater than nextIndex, then:\n        if (beginIndex > nextIndex) {\n            // i. Let literal be a substring of pattern from position nextIndex, inclusive, to position beginIndex, exclusive.\n            var literal = pattern.substring(nextIndex, beginIndex);\n            // ii. Add new part record { [[type]]: \"literal\", [[value]]: literal } as a new element of the list result.\n            arrPush.call(result, { '[[type]]': 'literal', '[[value]]': literal });\n        }\n        // a. Let p be the substring of pattern from position beginIndex, exclusive, to position endIndex, exclusive.\n        var p = pattern.substring(beginIndex + 1, endIndex);\n        // a. If p is equal \"number\", then:\n        if (p === \"number\") {\n            // i. If x is NaN,\n            if (isNaN(x)) {\n                // 1. Let n be an ILD String value indicating the NaN value.\n                var n = ild.nan;\n                // 2. Add new part record { [[type]]: \"nan\", [[value]]: n } as a new element of the list result.\n                arrPush.call(result, { '[[type]]': 'nan', '[[value]]': n });\n            }\n            // ii. Else if isFinite(x) is false,\n            else if (!isFinite(x)) {\n                    // 1. Let n be an ILD String value indicating infinity.\n                    var _n = ild.infinity;\n                    // 2. Add new part record { [[type]]: \"infinity\", [[value]]: n } as a new element of the list result.\n                    arrPush.call(result, { '[[type]]': 'infinity', '[[value]]': _n });\n                }\n                // iii. Else,\n                else {\n                        // 1. If the value of numberFormat.[[style]] is \"percent\" and isFinite(x), let x be 100  x.\n                        if (internal['[[style]]'] === 'percent' && isFinite(x)) x *= 100;\n\n                        var _n2 = void 0;\n                        // 2. If the numberFormat.[[minimumSignificantDigits]] and numberFormat.[[maximumSignificantDigits]] are present, then\n                        if (hop.call(internal, '[[minimumSignificantDigits]]') && hop.call(internal, '[[maximumSignificantDigits]]')) {\n                            // a. Let n be ToRawPrecision(x, numberFormat.[[minimumSignificantDigits]], numberFormat.[[maximumSignificantDigits]]).\n                            _n2 = ToRawPrecision(x, internal['[[minimumSignificantDigits]]'], internal['[[maximumSignificantDigits]]']);\n                        }\n                        // 3. Else,\n                        else {\n                                // a. Let n be ToRawFixed(x, numberFormat.[[minimumIntegerDigits]], numberFormat.[[minimumFractionDigits]], numberFormat.[[maximumFractionDigits]]).\n                                _n2 = ToRawFixed(x, internal['[[minimumIntegerDigits]]'], internal['[[minimumFractionDigits]]'], internal['[[maximumFractionDigits]]']);\n                            }\n                        // 4. If the value of the numberFormat.[[numberingSystem]] matches one of the values in the \"Numbering System\" column of Table 2 below, then\n                        if (numSys[nums]) {\n                            (function () {\n                                // a. Let digits be an array whose 10 String valued elements are the UTF-16 string representations of the 10 digits specified in the \"Digits\" column of the matching row in Table 2.\n                                var digits = numSys[nums];\n                                // a. Replace each digit in n with the value of digits[digit].\n                                _n2 = String(_n2).replace(/\\d/g, function (digit) {\n                                    return digits[digit];\n                                });\n                            })();\n                        }\n                        // 5. Else use an implementation dependent algorithm to map n to the appropriate representation of n in the given numbering system.\n                        else _n2 = String(_n2); // ###TODO###\n\n                        var integer = void 0;\n                        var fraction = void 0;\n                        // 6. Let decimalSepIndex be Call(%StringProto_indexOf%, n, \".\", 0).\n                        var decimalSepIndex = _n2.indexOf('.', 0);\n                        // 7. If decimalSepIndex > 0, then:\n                        if (decimalSepIndex > 0) {\n                            // a. Let integer be the substring of n from position 0, inclusive, to position decimalSepIndex, exclusive.\n                            integer = _n2.substring(0, decimalSepIndex);\n                            // a. Let fraction be the substring of n from position decimalSepIndex, exclusive, to the end of n.\n                            fraction = _n2.substring(decimalSepIndex + 1, decimalSepIndex.length);\n                        }\n                        // 8. Else:\n                        else {\n                                // a. Let integer be n.\n                                integer = _n2;\n                                // a. Let fraction be undefined.\n                                fraction = undefined;\n                            }\n                        // 9. If the value of the numberFormat.[[useGrouping]] is true,\n                        if (internal['[[useGrouping]]'] === true) {\n                            // a. Let groupSepSymbol be the ILND String representing the grouping separator.\n                            var groupSepSymbol = ild.group;\n                            // a. Let groups be a List whose elements are, in left to right order, the substrings defined by ILND set of locations within the integer.\n                            var groups = [];\n                            // ----> implementation:\n                            // Primary group represents the group closest to the decimal\n                            var pgSize = data.patterns.primaryGroupSize || 3;\n                            // Secondary group is every other group\n                            var sgSize = data.patterns.secondaryGroupSize || pgSize;\n                            // Group only if necessary\n                            if (integer.length > pgSize) {\n                                // Index of the primary grouping separator\n                                var end = integer.length - pgSize;\n                                // Starting index for our loop\n                                var idx = end % sgSize;\n                                var start = integer.slice(0, idx);\n                                if (start.length) arrPush.call(groups, start);\n                                // Loop to separate into secondary grouping digits\n                                while (idx < end) {\n                                    arrPush.call(groups, integer.slice(idx, idx + sgSize));\n                                    idx += sgSize;\n                                }\n                                // Add the primary grouping digits\n                                arrPush.call(groups, integer.slice(end));\n                            } else {\n                                arrPush.call(groups, integer);\n                            }\n                            // a. Assert: The number of elements in groups List is greater than 0.\n                            if (groups.length === 0) throw new Error();\n                            // a. Repeat, while groups List is not empty:\n                            while (groups.length) {\n                                // i. Remove the first element from groups and let integerGroup be the value of that element.\n                                var integerGroup = arrShift.call(groups);\n                                // ii. Add new part record { [[type]]: \"integer\", [[value]]: integerGroup } as a new element of the list result.\n                                arrPush.call(result, { '[[type]]': 'integer', '[[value]]': integerGroup });\n                                // iii. If groups List is not empty, then:\n                                if (groups.length) {\n                                    // 1. Add new part record { [[type]]: \"group\", [[value]]: groupSepSymbol } as a new element of the list result.\n                                    arrPush.call(result, { '[[type]]': 'group', '[[value]]': groupSepSymbol });\n                                }\n                            }\n                        }\n                        // 10. Else,\n                        else {\n                                // a. Add new part record { [[type]]: \"integer\", [[value]]: integer } as a new element of the list result.\n                                arrPush.call(result, { '[[type]]': 'integer', '[[value]]': integer });\n                            }\n                        // 11. If fraction is not undefined, then:\n                        if (fraction !== undefined) {\n                            // a. Let decimalSepSymbol be the ILND String representing the decimal separator.\n                            var decimalSepSymbol = ild.decimal;\n                            // a. Add new part record { [[type]]: \"decimal\", [[value]]: decimalSepSymbol } as a new element of the list result.\n                            arrPush.call(result, { '[[type]]': 'decimal', '[[value]]': decimalSepSymbol });\n                            // a. Add new part record { [[type]]: \"fraction\", [[value]]: fraction } as a new element of the list result.\n                            arrPush.call(result, { '[[type]]': 'fraction', '[[value]]': fraction });\n                        }\n                    }\n        }\n        // a. Else if p is equal \"plusSign\", then:\n        else if (p === \"plusSign\") {\n                // i. Let plusSignSymbol be the ILND String representing the plus sign.\n                var plusSignSymbol = ild.plusSign;\n                // ii. Add new part record { [[type]]: \"plusSign\", [[value]]: plusSignSymbol } as a new element of the list result.\n                arrPush.call(result, { '[[type]]': 'plusSign', '[[value]]': plusSignSymbol });\n            }\n            // a. Else if p is equal \"minusSign\", then:\n            else if (p === \"minusSign\") {\n                    // i. Let minusSignSymbol be the ILND String representing the minus sign.\n                    var minusSignSymbol = ild.minusSign;\n                    // ii. Add new part record { [[type]]: \"minusSign\", [[value]]: minusSignSymbol } as a new element of the list result.\n                    arrPush.call(result, { '[[type]]': 'minusSign', '[[value]]': minusSignSymbol });\n                }\n                // a. Else if p is equal \"percentSign\" and numberFormat.[[style]] is \"percent\", then:\n                else if (p === \"percentSign\" && internal['[[style]]'] === \"percent\") {\n                        // i. Let percentSignSymbol be the ILND String representing the percent sign.\n                        var percentSignSymbol = ild.percentSign;\n                        // ii. Add new part record { [[type]]: \"percentSign\", [[value]]: percentSignSymbol } as a new element of the list result.\n                        arrPush.call(result, { '[[type]]': 'literal', '[[value]]': percentSignSymbol });\n                    }\n                    // a. Else if p is equal \"currency\" and numberFormat.[[style]] is \"currency\", then:\n                    else if (p === \"currency\" && internal['[[style]]'] === \"currency\") {\n                            // i. Let currency be the value of numberFormat.[[currency]].\n                            var currency = internal['[[currency]]'];\n\n                            var cd = void 0;\n\n                            // ii. If numberFormat.[[currencyDisplay]] is \"code\", then\n                            if (internal['[[currencyDisplay]]'] === \"code\") {\n                                // 1. Let cd be currency.\n                                cd = currency;\n                            }\n                            // iii. Else if numberFormat.[[currencyDisplay]] is \"symbol\", then\n                            else if (internal['[[currencyDisplay]]'] === \"symbol\") {\n                                    // 1. Let cd be an ILD string representing currency in short form. If the implementation does not have such a representation of currency, use currency itself.\n                                    cd = data.currencies[currency] || currency;\n                                }\n                                // iv. Else if numberFormat.[[currencyDisplay]] is \"name\", then\n                                else if (internal['[[currencyDisplay]]'] === \"name\") {\n                                        // 1. Let cd be an ILD string representing currency in long form. If the implementation does not have such a representation of currency, then use currency itself.\n                                        cd = currency;\n                                    }\n                            // v. Add new part record { [[type]]: \"currency\", [[value]]: cd } as a new element of the list result.\n                            arrPush.call(result, { '[[type]]': 'currency', '[[value]]': cd });\n                        }\n                        // a. Else,\n                        else {\n                                // i. Let literal be the substring of pattern from position beginIndex, inclusive, to position endIndex, inclusive.\n                                var _literal = pattern.substring(beginIndex, endIndex);\n                                // ii. Add new part record { [[type]]: \"literal\", [[value]]: literal } as a new element of the list result.\n                                arrPush.call(result, { '[[type]]': 'literal', '[[value]]': _literal });\n                            }\n        // a. Set nextIndex to endIndex + 1.\n        nextIndex = endIndex + 1;\n        // a. Set beginIndex to Call(%StringProto_indexOf%, pattern, \"{\", nextIndex)\n        beginIndex = pattern.indexOf('{', nextIndex);\n    }\n    // 9. If nextIndex is less than length, then:\n    if (nextIndex < length) {\n        // a. Let literal be the substring of pattern from position nextIndex, inclusive, to position length, exclusive.\n        var _literal2 = pattern.substring(nextIndex, length);\n        // a. Add new part record { [[type]]: \"literal\", [[value]]: literal } as a new element of the list result.\n        arrPush.call(result, { '[[type]]': 'literal', '[[value]]': _literal2 });\n    }\n    // 10. Return result.\n    return result;\n}\n\n/*\n * @spec[stasm/ecma402/number-format-to-parts/spec/numberformat.html]\n * @clause[sec-formatnumber]\n */\nfunction FormatNumber(numberFormat, x) {\n    // 1. Let parts be ? PartitionNumberPattern(numberFormat, x).\n    var parts = PartitionNumberPattern(numberFormat, x);\n    // 2. Let result be an empty String.\n    var result = '';\n    // 3. For each part in parts, do:\n    for (var i = 0; parts.length > i; i++) {\n        var part = parts[i];\n        // a. Set result to a String value produced by concatenating result and part.[[value]].\n        result += part['[[value]]'];\n    }\n    // 4. Return result.\n    return result;\n}\n\n/**\n * When the ToRawPrecision abstract operation is called with arguments x (which\n * must be a finite non-negative number), minPrecision, and maxPrecision (both\n * must be integers between 1 and 21) the following steps are taken:\n */\nfunction ToRawPrecision(x, minPrecision, maxPrecision) {\n    // 1. Let p be maxPrecision.\n    var p = maxPrecision;\n\n    var m = void 0,\n        e = void 0;\n\n    // 2. If x = 0, then\n    if (x === 0) {\n        // a. Let m be the String consisting of p occurrences of the character \"0\".\n        m = arrJoin.call(Array(p + 1), '0');\n        // b. Let e be 0.\n        e = 0;\n    }\n    // 3. Else\n    else {\n            // a. Let e and n be integers such that 10  n < 10 and for which the\n            //    exact mathematical value of n  10  x is as close to zero as\n            //    possible. If there are two such sets of e and n, pick the e and n for\n            //    which n  10 is larger.\n            e = log10Floor(Math.abs(x));\n\n            // Easier to get to m from here\n            var f = Math.round(Math.exp(Math.abs(e - p + 1) * Math.LN10));\n\n            // b. Let m be the String consisting of the digits of the decimal\n            //    representation of n (in order, with no leading zeroes)\n            m = String(Math.round(e - p + 1 < 0 ? x * f : x / f));\n        }\n\n    // 4. If e  p, then\n    if (e >= p)\n        // a. Return the concatenation of m and e-p+1 occurrences of the character \"0\".\n        return m + arrJoin.call(Array(e - p + 1 + 1), '0');\n\n        // 5. If e = p-1, then\n    else if (e === p - 1)\n            // a. Return m.\n            return m;\n\n            // 6. If e  0, then\n        else if (e >= 0)\n                // a. Let m be the concatenation of the first e+1 characters of m, the character\n                //    \".\", and the remaining p(e+1) characters of m.\n                m = m.slice(0, e + 1) + '.' + m.slice(e + 1);\n\n                // 7. If e < 0, then\n            else if (e < 0)\n                    // a. Let m be the concatenation of the String \"0.\", (e+1) occurrences of the\n                    //    character \"0\", and the string m.\n                    m = '0.' + arrJoin.call(Array(-(e + 1) + 1), '0') + m;\n\n    // 8. If m contains the character \".\", and maxPrecision > minPrecision, then\n    if (m.indexOf(\".\") >= 0 && maxPrecision > minPrecision) {\n        // a. Let cut be maxPrecision  minPrecision.\n        var cut = maxPrecision - minPrecision;\n\n        // b. Repeat while cut > 0 and the last character of m is \"0\":\n        while (cut > 0 && m.charAt(m.length - 1) === '0') {\n            //  i. Remove the last character from m.\n            m = m.slice(0, -1);\n\n            //  ii. Decrease cut by 1.\n            cut--;\n        }\n\n        // c. If the last character of m is \".\", then\n        if (m.charAt(m.length - 1) === '.')\n            //    i. Remove the last character from m.\n            m = m.slice(0, -1);\n    }\n    // 9. Return m.\n    return m;\n}\n\n/**\n * @spec[tc39/ecma402/master/spec/numberformat.html]\n * @clause[sec-torawfixed]\n * When the ToRawFixed abstract operation is called with arguments x (which must\n * be a finite non-negative number), minInteger (which must be an integer between\n * 1 and 21), minFraction, and maxFraction (which must be integers between 0 and\n * 20) the following steps are taken:\n */\nfunction ToRawFixed(x, minInteger, minFraction, maxFraction) {\n    // 1. Let f be maxFraction.\n    var f = maxFraction;\n    // 2. Let n be an integer for which the exact mathematical value of n  10f  x is as close to zero as possible. If there are two such n, pick the larger n.\n    var n = Math.pow(10, f) * x; // diverging...\n    // 3. If n = 0, let m be the String \"0\". Otherwise, let m be the String consisting of the digits of the decimal representation of n (in order, with no leading zeroes).\n    var m = n === 0 ? \"0\" : n.toFixed(0); // divering...\n\n    {\n        // this diversion is needed to take into consideration big numbers, e.g.:\n        // 1.2344501e+37 -> 12344501000000000000000000000000000000\n        var idx = void 0;\n        var exp = (idx = m.indexOf('e')) > -1 ? m.slice(idx + 1) : 0;\n        if (exp) {\n            m = m.slice(0, idx).replace('.', '');\n            m += arrJoin.call(Array(exp - (m.length - 1) + 1), '0');\n        }\n    }\n\n    var int = void 0;\n    // 4. If f  0, then\n    if (f !== 0) {\n        // a. Let k be the number of characters in m.\n        var k = m.length;\n        // a. If k  f, then\n        if (k <= f) {\n            // i. Let z be the String consisting of f+1k occurrences of the character \"0\".\n            var z = arrJoin.call(Array(f + 1 - k + 1), '0');\n            // ii. Let m be the concatenation of Strings z and m.\n            m = z + m;\n            // iii. Let k be f+1.\n            k = f + 1;\n        }\n        // a. Let a be the first kf characters of m, and let b be the remaining f characters of m.\n        var a = m.substring(0, k - f),\n            b = m.substring(k - f, m.length);\n        // a. Let m be the concatenation of the three Strings a, \".\", and b.\n        m = a + \".\" + b;\n        // a. Let int be the number of characters in a.\n        int = a.length;\n    }\n    // 5. Else, let int be the number of characters in m.\n    else int = m.length;\n    // 6. Let cut be maxFraction  minFraction.\n    var cut = maxFraction - minFraction;\n    // 7. Repeat while cut > 0 and the last character of m is \"0\":\n    while (cut > 0 && m.slice(-1) === \"0\") {\n        // a. Remove the last character from m.\n        m = m.slice(0, -1);\n        // a. Decrease cut by 1.\n        cut--;\n    }\n    // 8. If the last character of m is \".\", then\n    if (m.slice(-1) === \".\") {\n        // a. Remove the last character from m.\n        m = m.slice(0, -1);\n    }\n    // 9. If int < minInteger, then\n    if (int < minInteger) {\n        // a. Let z be the String consisting of minIntegerint occurrences of the character \"0\".\n        var _z = arrJoin.call(Array(minInteger - int + 1), '0');\n        // a. Let m be the concatenation of Strings z and m.\n        m = _z + m;\n    }\n    // 10. Return m.\n    return m;\n}\n\n// Sect 11.3.2 Table 2, Numbering systems\n// ======================================\nvar numSys = {\n    arab: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    arabext: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    bali: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    beng: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    deva: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    fullwide: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    gujr: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    guru: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    hanidec: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    khmr: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    knda: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    laoo: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    latn: [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"],\n    limb: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    mlym: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    mong: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    mymr: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    orya: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    tamldec: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    telu: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    thai: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"],\n    tibt: [\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"]\n};\n\n/**\n * This function provides access to the locale and formatting options computed\n * during initialization of the object.\n *\n * The function returns a new object whose properties and attributes are set as\n * if constructed by an object literal assigning to each of the following\n * properties the value of the corresponding internal property of this\n * NumberFormat object (see 11.4): locale, numberingSystem, style, currency,\n * currencyDisplay, minimumIntegerDigits, minimumFractionDigits,\n * maximumFractionDigits, minimumSignificantDigits, maximumSignificantDigits, and\n * useGrouping. Properties whose corresponding internal properties are not present\n * are not assigned.\n */\n/* 11.3.3 */defineProperty(Intl.NumberFormat.prototype, 'resolvedOptions', {\n    configurable: true,\n    writable: true,\n    value: function value() {\n        var prop = void 0,\n            descs = new Record(),\n            props = ['locale', 'numberingSystem', 'style', 'currency', 'currencyDisplay', 'minimumIntegerDigits', 'minimumFractionDigits', 'maximumFractionDigits', 'minimumSignificantDigits', 'maximumSignificantDigits', 'useGrouping'],\n            internal = this !== null && babelHelpers[\"typeof\"](this) === 'object' && getInternalProperties(this);\n\n        // Satisfy test 11.3_b\n        if (!internal || !internal['[[initializedNumberFormat]]']) throw new TypeError('`this` value for resolvedOptions() is not an initialized Intl.NumberFormat object.');\n\n        for (var i = 0, max = props.length; i < max; i++) {\n            if (hop.call(internal, prop = '[[' + props[i] + ']]')) descs[props[i]] = { value: internal[prop], writable: true, configurable: true, enumerable: true };\n        }\n\n        return objCreate({}, descs);\n    }\n});\n\n/* jslint esnext: true */\n\n// Match these datetime components in a CLDR pattern, except those in single quotes\nvar expDTComponents = /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvVxX]{1,4})(?=([^']*'[^']*')*[^']*$)/g;\n// trim patterns after transformations\nvar expPatternTrimmer = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n// Skip over patterns with these datetime components because we don't have data\n// to back them up:\n// timezone, weekday, amoung others\nvar unwantedDTCs = /[rqQASjJgwWIQq]/; // xXVO were removed from this list in favor of computing matches with timeZoneName values but printing as empty string\n\nvar dtKeys = [\"weekday\", \"era\", \"year\", \"month\", \"day\", \"weekday\", \"quarter\"];\nvar tmKeys = [\"hour\", \"minute\", \"second\", \"hour12\", \"timeZoneName\"];\n\nfunction isDateFormatOnly(obj) {\n    for (var i = 0; i < tmKeys.length; i += 1) {\n        if (obj.hasOwnProperty(tmKeys[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction isTimeFormatOnly(obj) {\n    for (var i = 0; i < dtKeys.length; i += 1) {\n        if (obj.hasOwnProperty(dtKeys[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction joinDateAndTimeFormats(dateFormatObj, timeFormatObj) {\n    var o = { _: {} };\n    for (var i = 0; i < dtKeys.length; i += 1) {\n        if (dateFormatObj[dtKeys[i]]) {\n            o[dtKeys[i]] = dateFormatObj[dtKeys[i]];\n        }\n        if (dateFormatObj._[dtKeys[i]]) {\n            o._[dtKeys[i]] = dateFormatObj._[dtKeys[i]];\n        }\n    }\n    for (var j = 0; j < tmKeys.length; j += 1) {\n        if (timeFormatObj[tmKeys[j]]) {\n            o[tmKeys[j]] = timeFormatObj[tmKeys[j]];\n        }\n        if (timeFormatObj._[tmKeys[j]]) {\n            o._[tmKeys[j]] = timeFormatObj._[tmKeys[j]];\n        }\n    }\n    return o;\n}\n\nfunction computeFinalPatterns(formatObj) {\n    // From http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns:\n    //  'In patterns, two single quotes represents a literal single quote, either\n    //   inside or outside single quotes. Text within single quotes is not\n    //   interpreted in any way (except for two adjacent single quotes).'\n    formatObj.pattern12 = formatObj.extendedPattern.replace(/'([^']*)'/g, function ($0, literal) {\n        return literal ? literal : \"'\";\n    });\n\n    // pattern 12 is always the default. we can produce the 24 by removing {ampm}\n    formatObj.pattern = formatObj.pattern12.replace('{ampm}', '').replace(expPatternTrimmer, '');\n    return formatObj;\n}\n\nfunction expDTComponentsMeta($0, formatObj) {\n    switch ($0.charAt(0)) {\n        // --- Era\n        case 'G':\n            formatObj.era = ['short', 'short', 'short', 'long', 'narrow'][$0.length - 1];\n            return '{era}';\n\n        // --- Year\n        case 'y':\n        case 'Y':\n        case 'u':\n        case 'U':\n        case 'r':\n            formatObj.year = $0.length === 2 ? '2-digit' : 'numeric';\n            return '{year}';\n\n        // --- Quarter (not supported in this polyfill)\n        case 'Q':\n        case 'q':\n            formatObj.quarter = ['numeric', '2-digit', 'short', 'long', 'narrow'][$0.length - 1];\n            return '{quarter}';\n\n        // --- Month\n        case 'M':\n        case 'L':\n            formatObj.month = ['numeric', '2-digit', 'short', 'long', 'narrow'][$0.length - 1];\n            return '{month}';\n\n        // --- Week (not supported in this polyfill)\n        case 'w':\n            // week of the year\n            formatObj.week = $0.length === 2 ? '2-digit' : 'numeric';\n            return '{weekday}';\n        case 'W':\n            // week of the month\n            formatObj.week = 'numeric';\n            return '{weekday}';\n\n        // --- Day\n        case 'd':\n            // day of the month\n            formatObj.day = $0.length === 2 ? '2-digit' : 'numeric';\n            return '{day}';\n        case 'D': // day of the year\n        case 'F': // day of the week\n        case 'g':\n            // 1..n: Modified Julian day\n            formatObj.day = 'numeric';\n            return '{day}';\n\n        // --- Week Day\n        case 'E':\n            // day of the week\n            formatObj.weekday = ['short', 'short', 'short', 'long', 'narrow', 'short'][$0.length - 1];\n            return '{weekday}';\n        case 'e':\n            // local day of the week\n            formatObj.weekday = ['numeric', '2-digit', 'short', 'long', 'narrow', 'short'][$0.length - 1];\n            return '{weekday}';\n        case 'c':\n            // stand alone local day of the week\n            formatObj.weekday = ['numeric', undefined, 'short', 'long', 'narrow', 'short'][$0.length - 1];\n            return '{weekday}';\n\n        // --- Period\n        case 'a': // AM, PM\n        case 'b': // am, pm, noon, midnight\n        case 'B':\n            // flexible day periods\n            formatObj.hour12 = true;\n            return '{ampm}';\n\n        // --- Hour\n        case 'h':\n        case 'H':\n            formatObj.hour = $0.length === 2 ? '2-digit' : 'numeric';\n            return '{hour}';\n        case 'k':\n        case 'K':\n            formatObj.hour12 = true; // 12-hour-cycle time formats (using h or K)\n            formatObj.hour = $0.length === 2 ? '2-digit' : 'numeric';\n            return '{hour}';\n\n        // --- Minute\n        case 'm':\n            formatObj.minute = $0.length === 2 ? '2-digit' : 'numeric';\n            return '{minute}';\n\n        // --- Second\n        case 's':\n            formatObj.second = $0.length === 2 ? '2-digit' : 'numeric';\n            return '{second}';\n        case 'S':\n        case 'A':\n            formatObj.second = 'numeric';\n            return '{second}';\n\n        // --- Timezone\n        case 'z': // 1..3, 4: specific non-location format\n        case 'Z': // 1..3, 4, 5: The ISO8601 varios formats\n        case 'O': // 1, 4: miliseconds in day short, long\n        case 'v': // 1, 4: generic non-location format\n        case 'V': // 1, 2, 3, 4: time zone ID or city\n        case 'X': // 1, 2, 3, 4: The ISO8601 varios formats\n        case 'x':\n            // 1, 2, 3, 4: The ISO8601 varios formats\n            // this polyfill only supports much, for now, we are just doing something dummy\n            formatObj.timeZoneName = $0.length < 4 ? 'short' : 'long';\n            return '{timeZoneName}';\n    }\n}\n\n/**\n * Converts the CLDR availableFormats into the objects and patterns required by\n * the ECMAScript Internationalization API specification.\n */\nfunction createDateTimeFormat(skeleton, pattern) {\n    // we ignore certain patterns that are unsupported to avoid this expensive op.\n    if (unwantedDTCs.test(pattern)) return undefined;\n\n    var formatObj = {\n        originalPattern: pattern,\n        _: {}\n    };\n\n    // Replace the pattern string with the one required by the specification, whilst\n    // at the same time evaluating it for the subsets and formats\n    formatObj.extendedPattern = pattern.replace(expDTComponents, function ($0) {\n        // See which symbol we're dealing with\n        return expDTComponentsMeta($0, formatObj._);\n    });\n\n    // Match the skeleton string with the one required by the specification\n    // this implementation is based on the Date Field Symbol Table:\n    // http://unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table\n    // Note: we are adding extra data to the formatObject even though this polyfill\n    //       might not support it.\n    skeleton.replace(expDTComponents, function ($0) {\n        // See which symbol we're dealing with\n        return expDTComponentsMeta($0, formatObj);\n    });\n\n    return computeFinalPatterns(formatObj);\n}\n\n/**\n * Processes DateTime formats from CLDR to an easier-to-parse format.\n * the result of this operation should be cached the first time a particular\n * calendar is analyzed.\n *\n * The specification requires we support at least the following subsets of\n * date/time components:\n *\n *   - 'weekday', 'year', 'month', 'day', 'hour', 'minute', 'second'\n *   - 'weekday', 'year', 'month', 'day'\n *   - 'year', 'month', 'day'\n *   - 'year', 'month'\n *   - 'month', 'day'\n *   - 'hour', 'minute', 'second'\n *   - 'hour', 'minute'\n *\n * We need to cherry pick at least these subsets from the CLDR data and convert\n * them into the pattern objects used in the ECMA-402 API.\n */\nfunction createDateTimeFormats(formats) {\n    var availableFormats = formats.availableFormats;\n    var timeFormats = formats.timeFormats;\n    var dateFormats = formats.dateFormats;\n    var result = [];\n    var skeleton = void 0,\n        pattern = void 0,\n        computed = void 0,\n        i = void 0,\n        j = void 0;\n    var timeRelatedFormats = [];\n    var dateRelatedFormats = [];\n\n    // Map available (custom) formats into a pattern for createDateTimeFormats\n    for (skeleton in availableFormats) {\n        if (availableFormats.hasOwnProperty(skeleton)) {\n            pattern = availableFormats[skeleton];\n            computed = createDateTimeFormat(skeleton, pattern);\n            if (computed) {\n                result.push(computed);\n                // in some cases, the format is only displaying date specific props\n                // or time specific props, in which case we need to also produce the\n                // combined formats.\n                if (isDateFormatOnly(computed)) {\n                    dateRelatedFormats.push(computed);\n                } else if (isTimeFormatOnly(computed)) {\n                    timeRelatedFormats.push(computed);\n                }\n            }\n        }\n    }\n\n    // Map time formats into a pattern for createDateTimeFormats\n    for (skeleton in timeFormats) {\n        if (timeFormats.hasOwnProperty(skeleton)) {\n            pattern = timeFormats[skeleton];\n            computed = createDateTimeFormat(skeleton, pattern);\n            if (computed) {\n                result.push(computed);\n                timeRelatedFormats.push(computed);\n            }\n        }\n    }\n\n    // Map date formats into a pattern for createDateTimeFormats\n    for (skeleton in dateFormats) {\n        if (dateFormats.hasOwnProperty(skeleton)) {\n            pattern = dateFormats[skeleton];\n            computed = createDateTimeFormat(skeleton, pattern);\n            if (computed) {\n                result.push(computed);\n                dateRelatedFormats.push(computed);\n            }\n        }\n    }\n\n    // combine custom time and custom date formats when they are orthogonals to complete the\n    // formats supported by CLDR.\n    // This Algo is based on section \"Missing Skeleton Fields\" from:\n    // http://unicode.org/reports/tr35/tr35-dates.html#availableFormats_appendItems\n    for (i = 0; i < timeRelatedFormats.length; i += 1) {\n        for (j = 0; j < dateRelatedFormats.length; j += 1) {\n            if (dateRelatedFormats[j].month === 'long') {\n                pattern = dateRelatedFormats[j].weekday ? formats.full : formats.long;\n            } else if (dateRelatedFormats[j].month === 'short') {\n                pattern = formats.medium;\n            } else {\n                pattern = formats.short;\n            }\n            computed = joinDateAndTimeFormats(dateRelatedFormats[j], timeRelatedFormats[i]);\n            computed.originalPattern = pattern;\n            computed.extendedPattern = pattern.replace('{0}', timeRelatedFormats[i].extendedPattern).replace('{1}', dateRelatedFormats[j].extendedPattern).replace(/^[,\\s]+|[,\\s]+$/gi, '');\n            result.push(computeFinalPatterns(computed));\n        }\n    }\n\n    return result;\n}\n\n// An object map of date component keys, saves using a regex later\nvar dateWidths = objCreate(null, { narrow: {}, short: {}, long: {} });\n\n/**\n * Returns a string for a date component, resolved using multiple inheritance as specified\n * as specified in the Unicode Technical Standard 35.\n */\nfunction resolveDateString(data, ca, component, width, key) {\n    // From http://www.unicode.org/reports/tr35/tr35.html#Multiple_Inheritance:\n    // 'In clearly specified instances, resources may inherit from within the same locale.\n    //  For example, ... the Buddhist calendar inherits from the Gregorian calendar.'\n    var obj = data[ca] && data[ca][component] ? data[ca][component] : data.gregory[component],\n\n\n    // \"sideways\" inheritance resolves strings when a key doesn't exist\n    alts = {\n        narrow: ['short', 'long'],\n        short: ['long', 'narrow'],\n        long: ['short', 'narrow']\n    },\n\n\n    //\n    resolved = hop.call(obj, width) ? obj[width] : hop.call(obj, alts[width][0]) ? obj[alts[width][0]] : obj[alts[width][1]];\n\n    // `key` wouldn't be specified for components 'dayPeriods'\n    return key !== null ? resolved[key] : resolved;\n}\n\n// Define the DateTimeFormat constructor internally so it cannot be tainted\nfunction DateTimeFormatConstructor() {\n    var locales = arguments[0];\n    var options = arguments[1];\n\n    if (!this || this === Intl) {\n        return new Intl.DateTimeFormat(locales, options);\n    }\n    return InitializeDateTimeFormat(toObject(this), locales, options);\n}\n\ndefineProperty(Intl, 'DateTimeFormat', {\n    configurable: true,\n    writable: true,\n    value: DateTimeFormatConstructor\n});\n\n// Must explicitly set prototypes as unwritable\ndefineProperty(DateTimeFormatConstructor, 'prototype', {\n    writable: false\n});\n\n/**\n * The abstract operation InitializeDateTimeFormat accepts the arguments dateTimeFormat\n * (which must be an object), locales, and options. It initializes dateTimeFormat as a\n * DateTimeFormat object.\n */\nfunction /* 12.1.1.1 */InitializeDateTimeFormat(dateTimeFormat, locales, options) {\n    // This will be a internal properties object if we're not already initialized\n    var internal = getInternalProperties(dateTimeFormat);\n\n    // Create an object whose props can be used to restore the values of RegExp props\n    var regexpState = createRegExpRestore();\n\n    // 1. If dateTimeFormat has an [[initializedIntlObject]] internal property with\n    //    value true, throw a TypeError exception.\n    if (internal['[[initializedIntlObject]]'] === true) throw new TypeError('`this` object has already been initialized as an Intl object');\n\n    // Need this to access the `internal` object\n    defineProperty(dateTimeFormat, '__getInternalProperties', {\n        value: function value() {\n            // NOTE: Non-standard, for internal use only\n            if (arguments[0] === secret) return internal;\n        }\n    });\n\n    // 2. Set the [[initializedIntlObject]] internal property of numberFormat to true.\n    internal['[[initializedIntlObject]]'] = true;\n\n    // 3. Let requestedLocales be the result of calling the CanonicalizeLocaleList\n    //    abstract operation (defined in 9.2.1) with argument locales.\n    var requestedLocales = CanonicalizeLocaleList(locales);\n\n    // 4. Let options be the result of calling the ToDateTimeOptions abstract\n    //    operation (defined below) with arguments options, \"any\", and \"date\".\n    options = ToDateTimeOptions(options, 'any', 'date');\n\n    // 5. Let opt be a new Record.\n    var opt = new Record();\n\n    // 6. Let matcher be the result of calling the GetOption abstract operation\n    //    (defined in 9.2.9) with arguments options, \"localeMatcher\", \"string\", a List\n    //    containing the two String values \"lookup\" and \"best fit\", and \"best fit\".\n    var matcher = GetOption(options, 'localeMatcher', 'string', new List('lookup', 'best fit'), 'best fit');\n\n    // 7. Set opt.[[localeMatcher]] to matcher.\n    opt['[[localeMatcher]]'] = matcher;\n\n    // 8. Let DateTimeFormat be the standard built-in object that is the initial\n    //    value of Intl.DateTimeFormat.\n    var DateTimeFormat = internals.DateTimeFormat; // This is what we *really* need\n\n    // 9. Let localeData be the value of the [[localeData]] internal property of\n    //    DateTimeFormat.\n    var localeData = DateTimeFormat['[[localeData]]'];\n\n    // 10. Let r be the result of calling the ResolveLocale abstract operation\n    //     (defined in 9.2.5) with the [[availableLocales]] internal property of\n    //      DateTimeFormat, requestedLocales, opt, the [[relevantExtensionKeys]]\n    //      internal property of DateTimeFormat, and localeData.\n    var r = ResolveLocale(DateTimeFormat['[[availableLocales]]'], requestedLocales, opt, DateTimeFormat['[[relevantExtensionKeys]]'], localeData);\n\n    // 11. Set the [[locale]] internal property of dateTimeFormat to the value of\n    //     r.[[locale]].\n    internal['[[locale]]'] = r['[[locale]]'];\n\n    // 12. Set the [[calendar]] internal property of dateTimeFormat to the value of\n    //     r.[[ca]].\n    internal['[[calendar]]'] = r['[[ca]]'];\n\n    // 13. Set the [[numberingSystem]] internal property of dateTimeFormat to the value of\n    //     r.[[nu]].\n    internal['[[numberingSystem]]'] = r['[[nu]]'];\n\n    // The specification doesn't tell us to do this, but it's helpful later on\n    internal['[[dataLocale]]'] = r['[[dataLocale]]'];\n\n    // 14. Let dataLocale be the value of r.[[dataLocale]].\n    var dataLocale = r['[[dataLocale]]'];\n\n    // 15. Let tz be the result of calling the [[Get]] internal method of options with\n    //     argument \"timeZone\".\n    var tz = options.timeZone;\n\n    // 16. If tz is not undefined, then\n    if (tz !== undefined) {\n        // a. Let tz be ToString(tz).\n        // b. Convert tz to upper case as described in 6.1.\n        //    NOTE: If an implementation accepts additional time zone values, as permitted\n        //          under certain conditions by the Conformance clause, different casing\n        //          rules apply.\n        tz = toLatinUpperCase(tz);\n\n        // c. If tz is not \"UTC\", then throw a RangeError exception.\n        // ###TODO: accept more time zones###\n        if (tz !== 'UTC') throw new RangeError('timeZone is not supported.');\n    }\n\n    // 17. Set the [[timeZone]] internal property of dateTimeFormat to tz.\n    internal['[[timeZone]]'] = tz;\n\n    // 18. Let opt be a new Record.\n    opt = new Record();\n\n    // 19. For each row of Table 3, except the header row, do:\n    for (var prop in dateTimeComponents) {\n        if (!hop.call(dateTimeComponents, prop)) continue;\n\n        // 20. Let prop be the name given in the Property column of the row.\n        // 21. Let value be the result of calling the GetOption abstract operation,\n        //     passing as argument options, the name given in the Property column of the\n        //     row, \"string\", a List containing the strings given in the Values column of\n        //     the row, and undefined.\n        var value = GetOption(options, prop, 'string', dateTimeComponents[prop]);\n\n        // 22. Set opt.[[<prop>]] to value.\n        opt['[[' + prop + ']]'] = value;\n    }\n\n    // Assigned a value below\n    var bestFormat = void 0;\n\n    // 23. Let dataLocaleData be the result of calling the [[Get]] internal method of\n    //     localeData with argument dataLocale.\n    var dataLocaleData = localeData[dataLocale];\n\n    // 24. Let formats be the result of calling the [[Get]] internal method of\n    //     dataLocaleData with argument \"formats\".\n    //     Note: we process the CLDR formats into the spec'd structure\n    var formats = ToDateTimeFormats(dataLocaleData.formats);\n\n    // 25. Let matcher be the result of calling the GetOption abstract operation with\n    //     arguments options, \"formatMatcher\", \"string\", a List containing the two String\n    //     values \"basic\" and \"best fit\", and \"best fit\".\n    matcher = GetOption(options, 'formatMatcher', 'string', new List('basic', 'best fit'), 'best fit');\n\n    // Optimization: caching the processed formats as a one time operation by\n    // replacing the initial structure from localeData\n    dataLocaleData.formats = formats;\n\n    // 26. If matcher is \"basic\", then\n    if (matcher === 'basic') {\n        // 27. Let bestFormat be the result of calling the BasicFormatMatcher abstract\n        //     operation (defined below) with opt and formats.\n        bestFormat = BasicFormatMatcher(opt, formats);\n\n        // 28. Else\n    } else {\n            {\n                // diverging\n                var _hr = GetOption(options, 'hour12', 'boolean' /*, undefined, undefined*/);\n                opt.hour12 = _hr === undefined ? dataLocaleData.hour12 : _hr;\n            }\n            // 29. Let bestFormat be the result of calling the BestFitFormatMatcher\n            //     abstract operation (defined below) with opt and formats.\n            bestFormat = BestFitFormatMatcher(opt, formats);\n        }\n\n    // 30. For each row in Table 3, except the header row, do\n    for (var _prop in dateTimeComponents) {\n        if (!hop.call(dateTimeComponents, _prop)) continue;\n\n        // a. Let prop be the name given in the Property column of the row.\n        // b. Let pDesc be the result of calling the [[GetOwnProperty]] internal method of\n        //    bestFormat with argument prop.\n        // c. If pDesc is not undefined, then\n        if (hop.call(bestFormat, _prop)) {\n            // i. Let p be the result of calling the [[Get]] internal method of bestFormat\n            //    with argument prop.\n            var p = bestFormat[_prop];\n            {\n                // diverging\n                p = bestFormat._ && hop.call(bestFormat._, _prop) ? bestFormat._[_prop] : p;\n            }\n\n            // ii. Set the [[<prop>]] internal property of dateTimeFormat to p.\n            internal['[[' + _prop + ']]'] = p;\n        }\n    }\n\n    var pattern = void 0; // Assigned a value below\n\n    // 31. Let hr12 be the result of calling the GetOption abstract operation with\n    //     arguments options, \"hour12\", \"boolean\", undefined, and undefined.\n    var hr12 = GetOption(options, 'hour12', 'boolean' /*, undefined, undefined*/);\n\n    // 32. If dateTimeFormat has an internal property [[hour]], then\n    if (internal['[[hour]]']) {\n        // a. If hr12 is undefined, then let hr12 be the result of calling the [[Get]]\n        //    internal method of dataLocaleData with argument \"hour12\".\n        hr12 = hr12 === undefined ? dataLocaleData.hour12 : hr12;\n\n        // b. Set the [[hour12]] internal property of dateTimeFormat to hr12.\n        internal['[[hour12]]'] = hr12;\n\n        // c. If hr12 is true, then\n        if (hr12 === true) {\n            // i. Let hourNo0 be the result of calling the [[Get]] internal method of\n            //    dataLocaleData with argument \"hourNo0\".\n            var hourNo0 = dataLocaleData.hourNo0;\n\n            // ii. Set the [[hourNo0]] internal property of dateTimeFormat to hourNo0.\n            internal['[[hourNo0]]'] = hourNo0;\n\n            // iii. Let pattern be the result of calling the [[Get]] internal method of\n            //      bestFormat with argument \"pattern12\".\n            pattern = bestFormat.pattern12;\n        }\n\n        // d. Else\n        else\n            // i. Let pattern be the result of calling the [[Get]] internal method of\n            //    bestFormat with argument \"pattern\".\n            pattern = bestFormat.pattern;\n    }\n\n    // 33. Else\n    else\n        // a. Let pattern be the result of calling the [[Get]] internal method of\n        //    bestFormat with argument \"pattern\".\n        pattern = bestFormat.pattern;\n\n    // 34. Set the [[pattern]] internal property of dateTimeFormat to pattern.\n    internal['[[pattern]]'] = pattern;\n\n    // 35. Set the [[boundFormat]] internal property of dateTimeFormat to undefined.\n    internal['[[boundFormat]]'] = undefined;\n\n    // 36. Set the [[initializedDateTimeFormat]] internal property of dateTimeFormat to\n    //     true.\n    internal['[[initializedDateTimeFormat]]'] = true;\n\n    // In ES3, we need to pre-bind the format() function\n    if (es3) dateTimeFormat.format = GetFormatDateTime.call(dateTimeFormat);\n\n    // Restore the RegExp properties\n    regexpState.exp.test(regexpState.input);\n\n    // Return the newly initialised object\n    return dateTimeFormat;\n}\n\n/**\n * Several DateTimeFormat algorithms use values from the following table, which provides\n * property names and allowable values for the components of date and time formats:\n */\nvar dateTimeComponents = {\n    weekday: [\"narrow\", \"short\", \"long\"],\n    era: [\"narrow\", \"short\", \"long\"],\n    year: [\"2-digit\", \"numeric\"],\n    month: [\"2-digit\", \"numeric\", \"narrow\", \"short\", \"long\"],\n    day: [\"2-digit\", \"numeric\"],\n    hour: [\"2-digit\", \"numeric\"],\n    minute: [\"2-digit\", \"numeric\"],\n    second: [\"2-digit\", \"numeric\"],\n    timeZoneName: [\"short\", \"long\"]\n};\n\n/**\n * When the ToDateTimeOptions abstract operation is called with arguments options,\n * required, and defaults, the following steps are taken:\n */\nfunction ToDateTimeFormats(formats) {\n    if (Object.prototype.toString.call(formats) === '[object Array]') {\n        return formats;\n    }\n    return createDateTimeFormats(formats);\n}\n\n/**\n * When the ToDateTimeOptions abstract operation is called with arguments options,\n * required, and defaults, the following steps are taken:\n */\nfunction ToDateTimeOptions(options, required, defaults) {\n    // 1. If options is undefined, then let options be null, else let options be\n    //    ToObject(options).\n    if (options === undefined) options = null;else {\n        // (#12) options needs to be a Record, but it also needs to inherit properties\n        var opt2 = toObject(options);\n        options = new Record();\n\n        for (var k in opt2) {\n            options[k] = opt2[k];\n        }\n    }\n\n    // 2. Let create be the standard built-in function object defined in ES5, 15.2.3.5.\n    var create = objCreate;\n\n    // 3. Let options be the result of calling the [[Call]] internal method of create with\n    //    undefined as the this value and an argument list containing the single item\n    //    options.\n    options = create(options);\n\n    // 4. Let needDefaults be true.\n    var needDefaults = true;\n\n    // 5. If required is \"date\" or \"any\", then\n    if (required === 'date' || required === 'any') {\n        // a. For each of the property names \"weekday\", \"year\", \"month\", \"day\":\n        // i. If the result of calling the [[Get]] internal method of options with the\n        //    property name is not undefined, then let needDefaults be false.\n        if (options.weekday !== undefined || options.year !== undefined || options.month !== undefined || options.day !== undefined) needDefaults = false;\n    }\n\n    // 6. If required is \"time\" or \"any\", then\n    if (required === 'time' || required === 'any') {\n        // a. For each of the property names \"hour\", \"minute\", \"second\":\n        // i. If the result of calling the [[Get]] internal method of options with the\n        //    property name is not undefined, then let needDefaults be false.\n        if (options.hour !== undefined || options.minute !== undefined || options.second !== undefined) needDefaults = false;\n    }\n\n    // 7. If needDefaults is true and defaults is either \"date\" or \"all\", then\n    if (needDefaults && (defaults === 'date' || defaults === 'all'))\n        // a. For each of the property names \"year\", \"month\", \"day\":\n        // i. Call the [[DefineOwnProperty]] internal method of options with the\n        //    property name, Property Descriptor {[[Value]]: \"numeric\", [[Writable]]:\n        //    true, [[Enumerable]]: true, [[Configurable]]: true}, and false.\n        options.year = options.month = options.day = 'numeric';\n\n    // 8. If needDefaults is true and defaults is either \"time\" or \"all\", then\n    if (needDefaults && (defaults === 'time' || defaults === 'all'))\n        // a. For each of the property names \"hour\", \"minute\", \"second\":\n        // i. Call the [[DefineOwnProperty]] internal method of options with the\n        //    property name, Property Descriptor {[[Value]]: \"numeric\", [[Writable]]:\n        //    true, [[Enumerable]]: true, [[Configurable]]: true}, and false.\n        options.hour = options.minute = options.second = 'numeric';\n\n    // 9. Return options.\n    return options;\n}\n\n/**\n * When the BasicFormatMatcher abstract operation is called with two arguments options and\n * formats, the following steps are taken:\n */\nfunction BasicFormatMatcher(options, formats) {\n    // 1. Let removalPenalty be 120.\n    var removalPenalty = 120;\n\n    // 2. Let additionPenalty be 20.\n    var additionPenalty = 20;\n\n    // 3. Let longLessPenalty be 8.\n    var longLessPenalty = 8;\n\n    // 4. Let longMorePenalty be 6.\n    var longMorePenalty = 6;\n\n    // 5. Let shortLessPenalty be 6.\n    var shortLessPenalty = 6;\n\n    // 6. Let shortMorePenalty be 3.\n    var shortMorePenalty = 3;\n\n    // 7. Let bestScore be -Infinity.\n    var bestScore = -Infinity;\n\n    // 8. Let bestFormat be undefined.\n    var bestFormat = void 0;\n\n    // 9. Let i be 0.\n    var i = 0;\n\n    // 10. Assert: formats is an Array object.\n\n    // 11. Let len be the result of calling the [[Get]] internal method of formats with argument \"length\".\n    var len = formats.length;\n\n    // 12. Repeat while i < len:\n    while (i < len) {\n        // a. Let format be the result of calling the [[Get]] internal method of formats with argument ToString(i).\n        var format = formats[i];\n\n        // b. Let score be 0.\n        var score = 0;\n\n        // c. For each property shown in Table 3:\n        for (var property in dateTimeComponents) {\n            if (!hop.call(dateTimeComponents, property)) continue;\n\n            // i. Let optionsProp be options.[[<property>]].\n            var optionsProp = options['[[' + property + ']]'];\n\n            // ii. Let formatPropDesc be the result of calling the [[GetOwnProperty]] internal method of format\n            //     with argument property.\n            // iii. If formatPropDesc is not undefined, then\n            //     1. Let formatProp be the result of calling the [[Get]] internal method of format with argument property.\n            var formatProp = hop.call(format, property) ? format[property] : undefined;\n\n            // iv. If optionsProp is undefined and formatProp is not undefined, then decrease score by\n            //     additionPenalty.\n            if (optionsProp === undefined && formatProp !== undefined) score -= additionPenalty;\n\n            // v. Else if optionsProp is not undefined and formatProp is undefined, then decrease score by\n            //    removalPenalty.\n            else if (optionsProp !== undefined && formatProp === undefined) score -= removalPenalty;\n\n                // vi. Else\n                else {\n                        // 1. Let values be the array [\"2-digit\", \"numeric\", \"narrow\", \"short\",\n                        //    \"long\"].\n                        var values = ['2-digit', 'numeric', 'narrow', 'short', 'long'];\n\n                        // 2. Let optionsPropIndex be the index of optionsProp within values.\n                        var optionsPropIndex = arrIndexOf.call(values, optionsProp);\n\n                        // 3. Let formatPropIndex be the index of formatProp within values.\n                        var formatPropIndex = arrIndexOf.call(values, formatProp);\n\n                        // 4. Let delta be max(min(formatPropIndex - optionsPropIndex, 2), -2).\n                        var delta = Math.max(Math.min(formatPropIndex - optionsPropIndex, 2), -2);\n\n                        // 5. If delta = 2, decrease score by longMorePenalty.\n                        if (delta === 2) score -= longMorePenalty;\n\n                        // 6. Else if delta = 1, decrease score by shortMorePenalty.\n                        else if (delta === 1) score -= shortMorePenalty;\n\n                            // 7. Else if delta = -1, decrease score by shortLessPenalty.\n                            else if (delta === -1) score -= shortLessPenalty;\n\n                                // 8. Else if delta = -2, decrease score by longLessPenalty.\n                                else if (delta === -2) score -= longLessPenalty;\n                    }\n        }\n\n        // d. If score > bestScore, then\n        if (score > bestScore) {\n            // i. Let bestScore be score.\n            bestScore = score;\n\n            // ii. Let bestFormat be format.\n            bestFormat = format;\n        }\n\n        // e. Increase i by 1.\n        i++;\n    }\n\n    // 13. Return bestFormat.\n    return bestFormat;\n}\n\n/**\n * When the BestFitFormatMatcher abstract operation is called with two arguments options\n * and formats, it performs implementation dependent steps, which should return a set of\n * component representations that a typical user of the selected locale would perceive as\n * at least as good as the one returned by BasicFormatMatcher.\n *\n * This polyfill defines the algorithm to be the same as BasicFormatMatcher,\n * with the addition of bonus points awarded where the requested format is of\n * the same data type as the potentially matching format.\n *\n * This algo relies on the concept of closest distance matching described here:\n * http://unicode.org/reports/tr35/tr35-dates.html#Matching_Skeletons\n * Typically a best match is found using a closest distance match, such as:\n *\n * Symbols requesting a best choice for the locale are replaced.\n *      j  one of {H, k, h, K}; C  one of {a, b, B}\n * -> Covered by cldr.js matching process\n *\n * For fields with symbols representing the same type (year, month, day, etc):\n *     Most symbols have a small distance from each other.\n *         M  L; E  c; a  b  B; H  k  h  K; ...\n *     -> Covered by cldr.js matching process\n *\n *     Width differences among fields, other than those marking text vs numeric, are given small distance from each other.\n *         MMM  MMMM\n *         MM  M\n *     Numeric and text fields are given a larger distance from each other.\n *         MMM  MM\n *     Symbols representing substantial differences (week of year vs week of month) are given much larger a distances from each other.\n *         d  D; ...\n *     Missing or extra fields cause a match to fail. (But see Missing Skeleton Fields).\n *\n *\n * For example,\n *\n *     { month: 'numeric', day: 'numeric' }\n *\n * should match\n *\n *     { month: '2-digit', day: '2-digit' }\n *\n * rather than\n *\n *     { month: 'short', day: 'numeric' }\n *\n * This makes sense because a user requesting a formatted date with numeric parts would\n * not expect to see the returned format containing narrow, short or long part names\n */\nfunction BestFitFormatMatcher(options, formats) {\n\n    // 1. Let removalPenalty be 120.\n    var removalPenalty = 120;\n\n    // 2. Let additionPenalty be 20.\n    var additionPenalty = 20;\n\n    // 3. Let longLessPenalty be 8.\n    var longLessPenalty = 8;\n\n    // 4. Let longMorePenalty be 6.\n    var longMorePenalty = 6;\n\n    // 5. Let shortLessPenalty be 6.\n    var shortLessPenalty = 6;\n\n    // 6. Let shortMorePenalty be 3.\n    var shortMorePenalty = 3;\n\n    var hour12Penalty = 1;\n\n    // 7. Let bestScore be -Infinity.\n    var bestScore = -Infinity;\n\n    // 8. Let bestFormat be undefined.\n    var bestFormat = void 0;\n\n    // 9. Let i be 0.\n    var i = 0;\n\n    // 10. Assert: formats is an Array object.\n\n    // 11. Let len be the result of calling the [[Get]] internal method of formats with argument \"length\".\n    var len = formats.length;\n\n    // 12. Repeat while i < len:\n    while (i < len) {\n        // a. Let format be the result of calling the [[Get]] internal method of formats with argument ToString(i).\n        var format = formats[i];\n\n        // b. Let score be 0.\n        var score = 0;\n\n        // c. For each property shown in Table 3:\n        for (var property in dateTimeComponents) {\n            if (!hop.call(dateTimeComponents, property)) continue;\n\n            // i. Let optionsProp be options.[[<property>]].\n            var optionsProp = options['[[' + property + ']]'];\n\n            // ii. Let formatPropDesc be the result of calling the [[GetOwnProperty]] internal method of format\n            //     with argument property.\n            // iii. If formatPropDesc is not undefined, then\n            //     1. Let formatProp be the result of calling the [[Get]] internal method of format with argument property.\n            var formatProp = hop.call(format, property) ? format[property] : undefined;\n\n            // iv. If optionsProp is undefined and formatProp is not undefined, then decrease score by\n            //     additionPenalty.\n            if (optionsProp === undefined && formatProp !== undefined) score -= additionPenalty;\n\n            // v. Else if optionsProp is not undefined and formatProp is undefined, then decrease score by\n            //    removalPenalty.\n            else if (optionsProp !== undefined && formatProp === undefined) score -= removalPenalty;\n\n                // vi. Else\n                else {\n                        // 1. Let values be the array [\"2-digit\", \"numeric\", \"narrow\", \"short\",\n                        //    \"long\"].\n                        var values = ['2-digit', 'numeric', 'narrow', 'short', 'long'];\n\n                        // 2. Let optionsPropIndex be the index of optionsProp within values.\n                        var optionsPropIndex = arrIndexOf.call(values, optionsProp);\n\n                        // 3. Let formatPropIndex be the index of formatProp within values.\n                        var formatPropIndex = arrIndexOf.call(values, formatProp);\n\n                        // 4. Let delta be max(min(formatPropIndex - optionsPropIndex, 2), -2).\n                        var delta = Math.max(Math.min(formatPropIndex - optionsPropIndex, 2), -2);\n\n                        {\n                            // diverging from spec\n                            // When the bestFit argument is true, subtract additional penalty where data types are not the same\n                            if (formatPropIndex <= 1 && optionsPropIndex >= 2 || formatPropIndex >= 2 && optionsPropIndex <= 1) {\n                                // 5. If delta = 2, decrease score by longMorePenalty.\n                                if (delta > 0) score -= longMorePenalty;else if (delta < 0) score -= longLessPenalty;\n                            } else {\n                                // 5. If delta = 2, decrease score by longMorePenalty.\n                                if (delta > 1) score -= shortMorePenalty;else if (delta < -1) score -= shortLessPenalty;\n                            }\n                        }\n                    }\n        }\n\n        {\n            // diverging to also take into consideration differences between 12 or 24 hours\n            // which is special for the best fit only.\n            if (format._.hour12 !== options.hour12) {\n                score -= hour12Penalty;\n            }\n        }\n\n        // d. If score > bestScore, then\n        if (score > bestScore) {\n            // i. Let bestScore be score.\n            bestScore = score;\n            // ii. Let bestFormat be format.\n            bestFormat = format;\n        }\n\n        // e. Increase i by 1.\n        i++;\n    }\n\n    // 13. Return bestFormat.\n    return bestFormat;\n}\n\n/* 12.2.3 */internals.DateTimeFormat = {\n    '[[availableLocales]]': [],\n    '[[relevantExtensionKeys]]': ['ca', 'nu'],\n    '[[localeData]]': {}\n};\n\n/**\n * When the supportedLocalesOf method of Intl.DateTimeFormat is called, the\n * following steps are taken:\n */\n/* 12.2.2 */\ndefineProperty(Intl.DateTimeFormat, 'supportedLocalesOf', {\n    configurable: true,\n    writable: true,\n    value: fnBind.call(function (locales) {\n        // Bound functions only have the `this` value altered if being used as a constructor,\n        // this lets us imitate a native function that has no constructor\n        if (!hop.call(this, '[[availableLocales]]')) throw new TypeError('supportedLocalesOf() is not a constructor');\n\n        // Create an object whose props can be used to restore the values of RegExp props\n        var regexpState = createRegExpRestore(),\n\n\n        // 1. If options is not provided, then let options be undefined.\n        options = arguments[1],\n\n\n        // 2. Let availableLocales be the value of the [[availableLocales]] internal\n        //    property of the standard built-in object that is the initial value of\n        //    Intl.NumberFormat.\n\n        availableLocales = this['[[availableLocales]]'],\n\n\n        // 3. Let requestedLocales be the result of calling the CanonicalizeLocaleList\n        //    abstract operation (defined in 9.2.1) with argument locales.\n        requestedLocales = CanonicalizeLocaleList(locales);\n\n        // Restore the RegExp properties\n        regexpState.exp.test(regexpState.input);\n\n        // 4. Return the result of calling the SupportedLocales abstract operation\n        //    (defined in 9.2.8) with arguments availableLocales, requestedLocales,\n        //    and options.\n        return SupportedLocales(availableLocales, requestedLocales, options);\n    }, internals.NumberFormat)\n});\n\n/**\n * This named accessor property returns a function that formats a number\n * according to the effective locale and the formatting options of this\n * DateTimeFormat object.\n */\n/* 12.3.2 */defineProperty(Intl.DateTimeFormat.prototype, 'format', {\n    configurable: true,\n    get: GetFormatDateTime\n});\n\ndefineProperty(Intl.DateTimeFormat.prototype, 'formatToParts', {\n    configurable: true,\n    get: GetFormatToPartsDateTime\n});\n\nfunction GetFormatDateTime() {\n    var internal = this !== null && babelHelpers[\"typeof\"](this) === 'object' && getInternalProperties(this);\n\n    // Satisfy test 12.3_b\n    if (!internal || !internal['[[initializedDateTimeFormat]]']) throw new TypeError('`this` value for format() is not an initialized Intl.DateTimeFormat object.');\n\n    // The value of the [[Get]] attribute is a function that takes the following\n    // steps:\n\n    // 1. If the [[boundFormat]] internal property of this DateTimeFormat object\n    //    is undefined, then:\n    if (internal['[[boundFormat]]'] === undefined) {\n        // a. Let F be a Function object, with internal properties set as\n        //    specified for built-in functions in ES5, 15, or successor, and the\n        //    length property set to 0, that takes the argument date and\n        //    performs the following steps:\n        var F = function F() {\n            //   i. If date is not provided or is undefined, then let x be the\n            //      result as if by the expression Date.now() where Date.now is\n            //      the standard built-in function defined in ES5, 15.9.4.4.\n            //  ii. Else let x be ToNumber(date).\n            // iii. Return the result of calling the FormatDateTime abstract\n            //      operation (defined below) with arguments this and x.\n            var x = Number(arguments.length === 0 ? Date.now() : arguments[0]);\n            return FormatDateTime(this, x);\n        };\n        // b. Let bind be the standard built-in function object defined in ES5,\n        //    15.3.4.5.\n        // c. Let bf be the result of calling the [[Call]] internal method of\n        //    bind with F as the this value and an argument list containing\n        //    the single item this.\n        var bf = fnBind.call(F, this);\n        // d. Set the [[boundFormat]] internal property of this NumberFormat\n        //    object to bf.\n        internal['[[boundFormat]]'] = bf;\n    }\n    // Return the value of the [[boundFormat]] internal property of this\n    // NumberFormat object.\n    return internal['[[boundFormat]]'];\n}\n\nfunction GetFormatToPartsDateTime() {\n    var internal = this !== null && babelHelpers[\"typeof\"](this) === 'object' && getInternalProperties(this);\n\n    if (!internal || !internal['[[initializedDateTimeFormat]]']) throw new TypeError('`this` value for formatToParts() is not an initialized Intl.DateTimeFormat object.');\n\n    if (internal['[[boundFormatToParts]]'] === undefined) {\n        var F = function F() {\n            var x = Number(arguments.length === 0 ? Date.now() : arguments[0]);\n            return FormatToPartsDateTime(this, x);\n        };\n        var bf = fnBind.call(F, this);\n        internal['[[boundFormatToParts]]'] = bf;\n    }\n    return internal['[[boundFormatToParts]]'];\n}\n\nfunction CreateDateTimeParts(dateTimeFormat, x) {\n    // 1. If x is not a finite Number, then throw a RangeError exception.\n    if (!isFinite(x)) throw new RangeError('Invalid valid date passed to format');\n\n    var internal = dateTimeFormat.__getInternalProperties(secret);\n\n    // Creating restore point for properties on the RegExp object... please wait\n    /* let regexpState = */createRegExpRestore(); // ###TODO: review this\n\n    // 2. Let locale be the value of the [[locale]] internal property of dateTimeFormat.\n    var locale = internal['[[locale]]'];\n\n    // 3. Let nf be the result of creating a new NumberFormat object as if by the\n    // expression new Intl.NumberFormat([locale], {useGrouping: false}) where\n    // Intl.NumberFormat is the standard built-in constructor defined in 11.1.3.\n    var nf = new Intl.NumberFormat([locale], { useGrouping: false });\n\n    // 4. Let nf2 be the result of creating a new NumberFormat object as if by the\n    // expression new Intl.NumberFormat([locale], {minimumIntegerDigits: 2, useGrouping:\n    // false}) where Intl.NumberFormat is the standard built-in constructor defined in\n    // 11.1.3.\n    var nf2 = new Intl.NumberFormat([locale], { minimumIntegerDigits: 2, useGrouping: false });\n\n    // 5. Let tm be the result of calling the ToLocalTime abstract operation (defined\n    // below) with x, the value of the [[calendar]] internal property of dateTimeFormat,\n    // and the value of the [[timeZone]] internal property of dateTimeFormat.\n    var tm = ToLocalTime(x, internal['[[calendar]]'], internal['[[timeZone]]']);\n\n    // 6. Let result be the value of the [[pattern]] internal property of dateTimeFormat.\n    var pattern = internal['[[pattern]]'];\n\n    // 7.\n    var result = new List();\n\n    // 8.\n    var index = 0;\n\n    // 9.\n    var beginIndex = pattern.indexOf('{');\n\n    // 10.\n    var endIndex = 0;\n\n    // Need the locale minus any extensions\n    var dataLocale = internal['[[dataLocale]]'];\n\n    // Need the calendar data from CLDR\n    var localeData = internals.DateTimeFormat['[[localeData]]'][dataLocale].calendars;\n    var ca = internal['[[calendar]]'];\n\n    // 11.\n    while (beginIndex !== -1) {\n        var fv = void 0;\n        // a.\n        endIndex = pattern.indexOf('}', beginIndex);\n        // b.\n        if (endIndex === -1) {\n            throw new Error('Unclosed pattern');\n        }\n        // c.\n        if (beginIndex > index) {\n            arrPush.call(result, {\n                type: 'literal',\n                value: pattern.substring(index, beginIndex)\n            });\n        }\n        // d.\n        var p = pattern.substring(beginIndex + 1, endIndex);\n        // e.\n        if (dateTimeComponents.hasOwnProperty(p)) {\n            //   i. Let f be the value of the [[<p>]] internal property of dateTimeFormat.\n            var f = internal['[[' + p + ']]'];\n            //  ii. Let v be the value of tm.[[<p>]].\n            var v = tm['[[' + p + ']]'];\n            // iii. If p is \"year\" and v  0, then let v be 1 - v.\n            if (p === 'year' && v <= 0) {\n                v = 1 - v;\n            }\n            //  iv. If p is \"month\", then increase v by 1.\n            else if (p === 'month') {\n                    v++;\n                }\n                //   v. If p is \"hour\" and the value of the [[hour12]] internal property of\n                //      dateTimeFormat is true, then\n                else if (p === 'hour' && internal['[[hour12]]'] === true) {\n                        // 1. Let v be v modulo 12.\n                        v = v % 12;\n                        // 2. If v is 0 and the value of the [[hourNo0]] internal property of\n                        //    dateTimeFormat is true, then let v be 12.\n                        if (v === 0 && internal['[[hourNo0]]'] === true) {\n                            v = 12;\n                        }\n                    }\n\n            //  vi. If f is \"numeric\", then\n            if (f === 'numeric') {\n                // 1. Let fv be the result of calling the FormatNumber abstract operation\n                //    (defined in 11.3.2) with arguments nf and v.\n                fv = FormatNumber(nf, v);\n            }\n            // vii. Else if f is \"2-digit\", then\n            else if (f === '2-digit') {\n                    // 1. Let fv be the result of calling the FormatNumber abstract operation\n                    //    with arguments nf2 and v.\n                    fv = FormatNumber(nf2, v);\n                    // 2. If the length of fv is greater than 2, let fv be the substring of fv\n                    //    containing the last two characters.\n                    if (fv.length > 2) {\n                        fv = fv.slice(-2);\n                    }\n                }\n                // viii. Else if f is \"narrow\", \"short\", or \"long\", then let fv be a String\n                //     value representing f in the desired form; the String value depends upon\n                //     the implementation and the effective locale and calendar of\n                //     dateTimeFormat. If p is \"month\", then the String value may also depend\n                //     on whether dateTimeFormat has a [[day]] internal property. If p is\n                //     \"timeZoneName\", then the String value may also depend on the value of\n                //     the [[inDST]] field of tm.\n                else if (f in dateWidths) {\n                        switch (p) {\n                            case 'month':\n                                fv = resolveDateString(localeData, ca, 'months', f, tm['[[' + p + ']]']);\n                                break;\n\n                            case 'weekday':\n                                try {\n                                    fv = resolveDateString(localeData, ca, 'days', f, tm['[[' + p + ']]']);\n                                    // fv = resolveDateString(ca.days, f)[tm['[['+ p +']]']];\n                                } catch (e) {\n                                    throw new Error('Could not find weekday data for locale ' + locale);\n                                }\n                                break;\n\n                            case 'timeZoneName':\n                                fv = ''; // ###TODO\n                                break;\n\n                            case 'era':\n                                try {\n                                    fv = resolveDateString(localeData, ca, 'eras', f, tm['[[' + p + ']]']);\n                                } catch (e) {\n                                    throw new Error('Could not find era data for locale ' + locale);\n                                }\n                                break;\n\n                            default:\n                                fv = tm['[[' + p + ']]'];\n                        }\n                    }\n            // ix\n            arrPush.call(result, {\n                type: p,\n                value: fv\n            });\n            // f.\n        } else if (p === 'ampm') {\n                // i.\n                var _v = tm['[[hour]]'];\n                // ii./iii.\n                fv = resolveDateString(localeData, ca, 'dayPeriods', _v > 11 ? 'pm' : 'am', null);\n                // iv.\n                arrPush.call(result, {\n                    type: 'dayPeriod',\n                    value: fv\n                });\n                // g.\n            } else {\n                    arrPush.call(result, {\n                        type: 'literal',\n                        value: pattern.substring(beginIndex, endIndex + 1)\n                    });\n                }\n        // h.\n        index = endIndex + 1;\n        // i.\n        beginIndex = pattern.indexOf('{', index);\n    }\n    // 12.\n    if (endIndex < pattern.length - 1) {\n        arrPush.call(result, {\n            type: 'literal',\n            value: pattern.substr(endIndex + 1)\n        });\n    }\n    // 13.\n    return result;\n}\n\n/**\n * When the FormatDateTime abstract operation is called with arguments dateTimeFormat\n * (which must be an object initialized as a DateTimeFormat) and x (which must be a Number\n * value), it returns a String value representing x (interpreted as a time value as\n * specified in ES5, 15.9.1.1) according to the effective locale and the formatting\n * options of dateTimeFormat.\n */\nfunction FormatDateTime(dateTimeFormat, x) {\n    var parts = CreateDateTimeParts(dateTimeFormat, x);\n    var result = '';\n\n    for (var i = 0; parts.length > i; i++) {\n        var part = parts[i];\n        result += part.value;\n    }\n    return result;\n}\n\nfunction FormatToPartsDateTime(dateTimeFormat, x) {\n    var parts = CreateDateTimeParts(dateTimeFormat, x);\n    var result = [];\n    for (var i = 0; parts.length > i; i++) {\n        var part = parts[i];\n        result.push({\n            type: part.type,\n            value: part.value\n        });\n    }\n    return result;\n}\n\n/**\n * When the ToLocalTime abstract operation is called with arguments date, calendar, and\n * timeZone, the following steps are taken:\n */\nfunction ToLocalTime(date, calendar, timeZone) {\n    // 1. Apply calendrical calculations on date for the given calendar and time zone to\n    //    produce weekday, era, year, month, day, hour, minute, second, and inDST values.\n    //    The calculations should use best available information about the specified\n    //    calendar and time zone. If the calendar is \"gregory\", then the calculations must\n    //    match the algorithms specified in ES5, 15.9.1, except that calculations are not\n    //    bound by the restrictions on the use of best available information on time zones\n    //    for local time zone adjustment and daylight saving time adjustment imposed by\n    //    ES5, 15.9.1.7 and 15.9.1.8.\n    // ###TODO###\n    var d = new Date(date),\n        m = 'get' + (timeZone || '');\n\n    // 2. Return a Record with fields [[weekday]], [[era]], [[year]], [[month]], [[day]],\n    //    [[hour]], [[minute]], [[second]], and [[inDST]], each with the corresponding\n    //    calculated value.\n    return new Record({\n        '[[weekday]]': d[m + 'Day'](),\n        '[[era]]': +(d[m + 'FullYear']() >= 0),\n        '[[year]]': d[m + 'FullYear'](),\n        '[[month]]': d[m + 'Month'](),\n        '[[day]]': d[m + 'Date'](),\n        '[[hour]]': d[m + 'Hours'](),\n        '[[minute]]': d[m + 'Minutes'](),\n        '[[second]]': d[m + 'Seconds'](),\n        '[[inDST]]': false });\n}\n\n/**\n * The function returns a new object whose properties and attributes are set as if\n * constructed by an object literal assigning to each of the following properties the\n * value of the corresponding internal property of this DateTimeFormat object (see 12.4):\n * locale, calendar, numberingSystem, timeZone, hour12, weekday, era, year, month, day,\n * hour, minute, second, and timeZoneName. Properties whose corresponding internal\n * properties are not present are not assigned.\n */\n/* 12.3.3 */ // ###TODO###\ndefineProperty(Intl.DateTimeFormat.prototype, 'resolvedOptions', {\n    writable: true,\n    configurable: true,\n    value: function value() {\n        var prop = void 0,\n            descs = new Record(),\n            props = ['locale', 'calendar', 'numberingSystem', 'timeZone', 'hour12', 'weekday', 'era', 'year', 'month', 'day', 'hour', 'minute', 'second', 'timeZoneName'],\n            internal = this !== null && babelHelpers[\"typeof\"](this) === 'object' && getInternalProperties(this);\n\n        // Satisfy test 12.3_b\n        if (!internal || !internal['[[initializedDateTimeFormat]]']) throw new TypeError('`this` value for resolvedOptions() is not an initialized Intl.DateTimeFormat object.');\n\n        for (var i = 0, max = props.length; i < max; i++) {\n            if (hop.call(internal, prop = '[[' + props[i] + ']]')) descs[props[i]] = { value: internal[prop], writable: true, configurable: true, enumerable: true };\n        }\n\n        return objCreate({}, descs);\n    }\n});\n\nvar ls = Intl.__localeSensitiveProtos = {\n    Number: {},\n    Date: {}\n};\n\n/**\n * When the toLocaleString method is called with optional arguments locales and options,\n * the following steps are taken:\n */\n/* 13.2.1 */ls.Number.toLocaleString = function () {\n    // Satisfy test 13.2.1_1\n    if (Object.prototype.toString.call(this) !== '[object Number]') throw new TypeError('`this` value must be a number for Number.prototype.toLocaleString()');\n\n    // 1. Let x be this Number value (as defined in ES5, 15.7.4).\n    // 2. If locales is not provided, then let locales be undefined.\n    // 3. If options is not provided, then let options be undefined.\n    // 4. Let numberFormat be the result of creating a new object as if by the\n    //    expression new Intl.NumberFormat(locales, options) where\n    //    Intl.NumberFormat is the standard built-in constructor defined in 11.1.3.\n    // 5. Return the result of calling the FormatNumber abstract operation\n    //    (defined in 11.3.2) with arguments numberFormat and x.\n    return FormatNumber(new NumberFormatConstructor(arguments[0], arguments[1]), this);\n};\n\n/**\n * When the toLocaleString method is called with optional arguments locales and options,\n * the following steps are taken:\n */\n/* 13.3.1 */ls.Date.toLocaleString = function () {\n    // Satisfy test 13.3.0_1\n    if (Object.prototype.toString.call(this) !== '[object Date]') throw new TypeError('`this` value must be a Date instance for Date.prototype.toLocaleString()');\n\n    // 1. Let x be this time value (as defined in ES5, 15.9.5).\n    var x = +this;\n\n    // 2. If x is NaN, then return \"Invalid Date\".\n    if (isNaN(x)) return 'Invalid Date';\n\n    // 3. If locales is not provided, then let locales be undefined.\n    var locales = arguments[0];\n\n    // 4. If options is not provided, then let options be undefined.\n    var options = arguments[1];\n\n    // 5. Let options be the result of calling the ToDateTimeOptions abstract\n    //    operation (defined in 12.1.1) with arguments options, \"any\", and \"all\".\n    options = ToDateTimeOptions(options, 'any', 'all');\n\n    // 6. Let dateTimeFormat be the result of creating a new object as if by the\n    //    expression new Intl.DateTimeFormat(locales, options) where\n    //    Intl.DateTimeFormat is the standard built-in constructor defined in 12.1.3.\n    var dateTimeFormat = new DateTimeFormatConstructor(locales, options);\n\n    // 7. Return the result of calling the FormatDateTime abstract operation (defined\n    //    in 12.3.2) with arguments dateTimeFormat and x.\n    return FormatDateTime(dateTimeFormat, x);\n};\n\n/**\n * When the toLocaleDateString method is called with optional arguments locales and\n * options, the following steps are taken:\n */\n/* 13.3.2 */ls.Date.toLocaleDateString = function () {\n    // Satisfy test 13.3.0_1\n    if (Object.prototype.toString.call(this) !== '[object Date]') throw new TypeError('`this` value must be a Date instance for Date.prototype.toLocaleDateString()');\n\n    // 1. Let x be this time value (as defined in ES5, 15.9.5).\n    var x = +this;\n\n    // 2. If x is NaN, then return \"Invalid Date\".\n    if (isNaN(x)) return 'Invalid Date';\n\n    // 3. If locales is not provided, then let locales be undefined.\n    var locales = arguments[0],\n\n\n    // 4. If options is not provided, then let options be undefined.\n    options = arguments[1];\n\n    // 5. Let options be the result of calling the ToDateTimeOptions abstract\n    //    operation (defined in 12.1.1) with arguments options, \"date\", and \"date\".\n    options = ToDateTimeOptions(options, 'date', 'date');\n\n    // 6. Let dateTimeFormat be the result of creating a new object as if by the\n    //    expression new Intl.DateTimeFormat(locales, options) where\n    //    Intl.DateTimeFormat is the standard built-in constructor defined in 12.1.3.\n    var dateTimeFormat = new DateTimeFormatConstructor(locales, options);\n\n    // 7. Return the result of calling the FormatDateTime abstract operation (defined\n    //    in 12.3.2) with arguments dateTimeFormat and x.\n    return FormatDateTime(dateTimeFormat, x);\n};\n\n/**\n * When the toLocaleTimeString method is called with optional arguments locales and\n * options, the following steps are taken:\n */\n/* 13.3.3 */ls.Date.toLocaleTimeString = function () {\n    // Satisfy test 13.3.0_1\n    if (Object.prototype.toString.call(this) !== '[object Date]') throw new TypeError('`this` value must be a Date instance for Date.prototype.toLocaleTimeString()');\n\n    // 1. Let x be this time value (as defined in ES5, 15.9.5).\n    var x = +this;\n\n    // 2. If x is NaN, then return \"Invalid Date\".\n    if (isNaN(x)) return 'Invalid Date';\n\n    // 3. If locales is not provided, then let locales be undefined.\n    var locales = arguments[0];\n\n    // 4. If options is not provided, then let options be undefined.\n    var options = arguments[1];\n\n    // 5. Let options be the result of calling the ToDateTimeOptions abstract\n    //    operation (defined in 12.1.1) with arguments options, \"time\", and \"time\".\n    options = ToDateTimeOptions(options, 'time', 'time');\n\n    // 6. Let dateTimeFormat be the result of creating a new object as if by the\n    //    expression new Intl.DateTimeFormat(locales, options) where\n    //    Intl.DateTimeFormat is the standard built-in constructor defined in 12.1.3.\n    var dateTimeFormat = new DateTimeFormatConstructor(locales, options);\n\n    // 7. Return the result of calling the FormatDateTime abstract operation (defined\n    //    in 12.3.2) with arguments dateTimeFormat and x.\n    return FormatDateTime(dateTimeFormat, x);\n};\n\ndefineProperty(Intl, '__applyLocaleSensitivePrototypes', {\n    writable: true,\n    configurable: true,\n    value: function value() {\n        defineProperty(Number.prototype, 'toLocaleString', { writable: true, configurable: true, value: ls.Number.toLocaleString });\n        // Need this here for IE 8, to avoid the _DontEnum_ bug\n        defineProperty(Date.prototype, 'toLocaleString', { writable: true, configurable: true, value: ls.Date.toLocaleString });\n\n        for (var k in ls.Date) {\n            if (hop.call(ls.Date, k)) defineProperty(Date.prototype, k, { writable: true, configurable: true, value: ls.Date[k] });\n        }\n    }\n});\n\n/**\n * Can't really ship a single script with data for hundreds of locales, so we provide\n * this __addLocaleData method as a means for the developer to add the data on an\n * as-needed basis\n */\ndefineProperty(Intl, '__addLocaleData', {\n    value: function value(data) {\n        if (!IsStructurallyValidLanguageTag(data.locale)) throw new Error(\"Object passed doesn't identify itself with a valid language tag\");\n\n        addLocaleData(data, data.locale);\n    }\n});\n\nfunction addLocaleData(data, tag) {\n    // Both NumberFormat and DateTimeFormat require number data, so throw if it isn't present\n    if (!data.number) throw new Error(\"Object passed doesn't contain locale data for Intl.NumberFormat\");\n\n    var locale = void 0,\n        locales = [tag],\n        parts = tag.split('-');\n\n    // Create fallbacks for locale data with scripts, e.g. Latn, Hans, Vaii, etc\n    if (parts.length > 2 && parts[1].length === 4) arrPush.call(locales, parts[0] + '-' + parts[2]);\n\n    while (locale = arrShift.call(locales)) {\n        // Add to NumberFormat internal properties as per 11.2.3\n        arrPush.call(internals.NumberFormat['[[availableLocales]]'], locale);\n        internals.NumberFormat['[[localeData]]'][locale] = data.number;\n\n        // ...and DateTimeFormat internal properties as per 12.2.3\n        if (data.date) {\n            data.date.nu = data.number.nu;\n            arrPush.call(internals.DateTimeFormat['[[availableLocales]]'], locale);\n            internals.DateTimeFormat['[[localeData]]'][locale] = data.date;\n        }\n    }\n\n    // If this is the first set of locale data added, make it the default\n    if (defaultLocale === undefined) setDefaultLocale(tag);\n}\n\nmodule.exports = Intl;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /home/vagrant/~/intl/lib/core.js\n ** module id = 73\n ** module chunks = 1 2\n **/","'use strict';\n\nvar asap = require('asap/raw');\n\nfunction noop() {}\n\n// States:\n//\n// 0 - pending\n// 1 - fulfilled with _value\n// 2 - rejected with _value\n// 3 - adopted the state of another promise, _value\n//\n// once the state is no longer pending (0) it is immutable\n\n// All `_` prefixed properties will be reduced to `_{random number}`\n// at build time to obfuscate them and discourage their use.\n// We don't use symbols or Object.defineProperty to fully hide them\n// because the performance isn't good enough.\n\n\n// to avoid using try/catch inside critical functions, we\n// extract them to here.\nvar LAST_ERROR = null;\nvar IS_ERROR = {};\nfunction getThen(obj) {\n  try {\n    return obj.then;\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\n\nfunction tryCallOne(fn, a) {\n  try {\n    return fn(a);\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\nfunction tryCallTwo(fn, a, b) {\n  try {\n    fn(a, b);\n  } catch (ex) {\n    LAST_ERROR = ex;\n    return IS_ERROR;\n  }\n}\n\nmodule.exports = Promise;\n\nfunction Promise(fn) {\n  if (typeof this !== 'object') {\n    throw new TypeError('Promises must be constructed via new');\n  }\n  if (typeof fn !== 'function') {\n    throw new TypeError('not a function');\n  }\n  this._45 = 0;\n  this._81 = 0;\n  this._65 = null;\n  this._54 = null;\n  if (fn === noop) return;\n  doResolve(fn, this);\n}\nPromise._10 = null;\nPromise._97 = null;\nPromise._61 = noop;\n\nPromise.prototype.then = function(onFulfilled, onRejected) {\n  if (this.constructor !== Promise) {\n    return safeThen(this, onFulfilled, onRejected);\n  }\n  var res = new Promise(noop);\n  handle(this, new Handler(onFulfilled, onRejected, res));\n  return res;\n};\n\nfunction safeThen(self, onFulfilled, onRejected) {\n  return new self.constructor(function (resolve, reject) {\n    var res = new Promise(noop);\n    res.then(resolve, reject);\n    handle(self, new Handler(onFulfilled, onRejected, res));\n  });\n};\nfunction handle(self, deferred) {\n  while (self._81 === 3) {\n    self = self._65;\n  }\n  if (Promise._10) {\n    Promise._10(self);\n  }\n  if (self._81 === 0) {\n    if (self._45 === 0) {\n      self._45 = 1;\n      self._54 = deferred;\n      return;\n    }\n    if (self._45 === 1) {\n      self._45 = 2;\n      self._54 = [self._54, deferred];\n      return;\n    }\n    self._54.push(deferred);\n    return;\n  }\n  handleResolved(self, deferred);\n}\n\nfunction handleResolved(self, deferred) {\n  asap(function() {\n    var cb = self._81 === 1 ? deferred.onFulfilled : deferred.onRejected;\n    if (cb === null) {\n      if (self._81 === 1) {\n        resolve(deferred.promise, self._65);\n      } else {\n        reject(deferred.promise, self._65);\n      }\n      return;\n    }\n    var ret = tryCallOne(cb, self._65);\n    if (ret === IS_ERROR) {\n      reject(deferred.promise, LAST_ERROR);\n    } else {\n      resolve(deferred.promise, ret);\n    }\n  });\n}\nfunction resolve(self, newValue) {\n  // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure\n  if (newValue === self) {\n    return reject(\n      self,\n      new TypeError('A promise cannot be resolved with itself.')\n    );\n  }\n  if (\n    newValue &&\n    (typeof newValue === 'object' || typeof newValue === 'function')\n  ) {\n    var then = getThen(newValue);\n    if (then === IS_ERROR) {\n      return reject(self, LAST_ERROR);\n    }\n    if (\n      then === self.then &&\n      newValue instanceof Promise\n    ) {\n      self._81 = 3;\n      self._65 = newValue;\n      finale(self);\n      return;\n    } else if (typeof then === 'function') {\n      doResolve(then.bind(newValue), self);\n      return;\n    }\n  }\n  self._81 = 1;\n  self._65 = newValue;\n  finale(self);\n}\n\nfunction reject(self, newValue) {\n  self._81 = 2;\n  self._65 = newValue;\n  if (Promise._97) {\n    Promise._97(self, newValue);\n  }\n  finale(self);\n}\nfunction finale(self) {\n  if (self._45 === 1) {\n    handle(self, self._54);\n    self._54 = null;\n  }\n  if (self._45 === 2) {\n    for (var i = 0; i < self._54.length; i++) {\n      handle(self, self._54[i]);\n    }\n    self._54 = null;\n  }\n}\n\nfunction Handler(onFulfilled, onRejected, promise){\n  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n  this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n  this.promise = promise;\n}\n\n/**\n * Take a potentially misbehaving resolver function and make sure\n * onFulfilled and onRejected are only called once.\n *\n * Makes no guarantees about asynchrony.\n */\nfunction doResolve(fn, promise) {\n  var done = false;\n  var res = tryCallTwo(fn, function (value) {\n    if (done) return;\n    done = true;\n    resolve(promise, value);\n  }, function (reason) {\n    if (done) return;\n    done = true;\n    reject(promise, reason);\n  })\n  if (!done && res === IS_ERROR) {\n    done = true;\n    reject(promise, LAST_ERROR);\n  }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /home/vagrant/~/promise/lib/core.js\n ** module id = 164\n ** module chunks = 1\n **/","\"use strict\";\n\n// Use the fastest means possible to execute a task in its own turn, with\n// priority over other events including IO, animation, reflow, and redraw\n// events in browsers.\n//\n// An exception thrown by a task will permanently interrupt the processing of\n// subsequent tasks. The higher level `asap` function ensures that if an\n// exception is thrown by a task, that the task queue will continue flushing as\n// soon as possible, but if you use `rawAsap` directly, you are responsible to\n// either ensure that no exceptions are thrown from your task, or to manually\n// call `rawAsap.requestFlush` if an exception is thrown.\nmodule.exports = rawAsap;\nfunction rawAsap(task) {\n    if (!queue.length) {\n        requestFlush();\n        flushing = true;\n    }\n    // Equivalent to push, but avoids a function call.\n    queue[queue.length] = task;\n}\n\nvar queue = [];\n// Once a flush has been requested, no further calls to `requestFlush` are\n// necessary until the next `flush` completes.\nvar flushing = false;\n// `requestFlush` is an implementation-specific method that attempts to kick\n// off a `flush` event as quickly as possible. `flush` will attempt to exhaust\n// the event queue before yielding to the browser's own event loop.\nvar requestFlush;\n// The position of the next task to execute in the task queue. This is\n// preserved between calls to `flush` so that it can be resumed if\n// a task throws an exception.\nvar index = 0;\n// If a task schedules additional tasks recursively, the task queue can grow\n// unbounded. To prevent memory exhaustion, the task queue will periodically\n// truncate already-completed tasks.\nvar capacity = 1024;\n\n// The flush function processes all tasks that have been scheduled with\n// `rawAsap` unless and until one of those tasks throws an exception.\n// If a task throws an exception, `flush` ensures that its state will remain\n// consistent and will resume where it left off when called again.\n// However, `flush` does not make any arrangements to be called again if an\n// exception is thrown.\nfunction flush() {\n    while (index < queue.length) {\n        var currentIndex = index;\n        // Advance the index before calling the task. This ensures that we will\n        // begin flushing on the next task the task throws an error.\n        index = index + 1;\n        queue[currentIndex].call();\n        // Prevent leaking memory for long chains of recursive calls to `asap`.\n        // If we call `asap` within tasks scheduled by `asap`, the queue will\n        // grow, but to avoid an O(n) walk for every task we execute, we don't\n        // shift tasks off the queue after they have been executed.\n        // Instead, we periodically shift 1024 tasks off the queue.\n        if (index > capacity) {\n            // Manually shift all values starting at the index back to the\n            // beginning of the queue.\n            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {\n                queue[scan] = queue[scan + index];\n            }\n            queue.length -= index;\n            index = 0;\n        }\n    }\n    queue.length = 0;\n    index = 0;\n    flushing = false;\n}\n\n// `requestFlush` is implemented using a strategy based on data collected from\n// every available SauceLabs Selenium web driver worker at time of writing.\n// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593\n\n// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that\n// have WebKitMutationObserver but not un-prefixed MutationObserver.\n// Must use `global` instead of `window` to work in both frames and web\n// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.\nvar BrowserMutationObserver = global.MutationObserver || global.WebKitMutationObserver;\n\n// MutationObservers are desirable because they have high priority and work\n// reliably everywhere they are implemented.\n// They are implemented in all modern browsers.\n//\n// - Android 4-4.3\n// - Chrome 26-34\n// - Firefox 14-29\n// - Internet Explorer 11\n// - iPad Safari 6-7.1\n// - iPhone Safari 7-7.1\n// - Safari 6-7\nif (typeof BrowserMutationObserver === \"function\") {\n    requestFlush = makeRequestCallFromMutationObserver(flush);\n\n// MessageChannels are desirable because they give direct access to the HTML\n// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera\n// 11-12, and in web workers in many engines.\n// Although message channels yield to any queued rendering and IO tasks, they\n// would be better than imposing the 4ms delay of timers.\n// However, they do not work reliably in Internet Explorer or Safari.\n\n// Internet Explorer 10 is the only browser that has setImmediate but does\n// not have MutationObservers.\n// Although setImmediate yields to the browser's renderer, it would be\n// preferrable to falling back to setTimeout since it does not have\n// the minimum 4ms penalty.\n// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and\n// Desktop to a lesser extent) that renders both setImmediate and\n// MessageChannel useless for the purposes of ASAP.\n// https://github.com/kriskowal/q/issues/396\n\n// Timers are implemented universally.\n// We fall back to timers in workers in most engines, and in foreground\n// contexts in the following browsers.\n// However, note that even this simple case requires nuances to operate in a\n// broad spectrum of browsers.\n//\n// - Firefox 3-13\n// - Internet Explorer 6-9\n// - iPad Safari 4.3\n// - Lynx 2.8.7\n} else {\n    requestFlush = makeRequestCallFromTimer(flush);\n}\n\n// `requestFlush` requests that the high priority event queue be flushed as\n// soon as possible.\n// This is useful to prevent an error thrown in a task from stalling the event\n// queue if the exception handled by Node.jss\n// `process.on(\"uncaughtException\")` or by a domain.\nrawAsap.requestFlush = requestFlush;\n\n// To request a high priority event, we induce a mutation observer by toggling\n// the text of a text node between \"1\" and \"-1\".\nfunction makeRequestCallFromMutationObserver(callback) {\n    var toggle = 1;\n    var observer = new BrowserMutationObserver(callback);\n    var node = document.createTextNode(\"\");\n    observer.observe(node, {characterData: true});\n    return function requestCall() {\n        toggle = -toggle;\n        node.data = toggle;\n    };\n}\n\n// The message channel technique was discovered by Malte Ubl and was the\n// original foundation for this library.\n// http://www.nonblocking.io/2011/06/windownexttick.html\n\n// Safari 6.0.5 (at least) intermittently fails to create message ports on a\n// page's first load. Thankfully, this version of Safari supports\n// MutationObservers, so we don't need to fall back in that case.\n\n// function makeRequestCallFromMessageChannel(callback) {\n//     var channel = new MessageChannel();\n//     channel.port1.onmessage = callback;\n//     return function requestCall() {\n//         channel.port2.postMessage(0);\n//     };\n// }\n\n// For reasons explained above, we are also unable to use `setImmediate`\n// under any circumstances.\n// Even if we were, there is another bug in Internet Explorer 10.\n// It is not sufficient to assign `setImmediate` to `requestFlush` because\n// `setImmediate` must be called *by name* and therefore must be wrapped in a\n// closure.\n// Never forget.\n\n// function makeRequestCallFromSetImmediate(callback) {\n//     return function requestCall() {\n//         setImmediate(callback);\n//     };\n// }\n\n// Safari 6.0 has a problem where timers will get lost while the user is\n// scrolling. This problem does not impact ASAP because Safari 6.0 supports\n// mutation observers, so that implementation is used instead.\n// However, if we ever elect to use timers in Safari, the prevalent work-around\n// is to add a scroll event listener that calls for a flush.\n\n// `setTimeout` does not call the passed callback if the delay is less than\n// approximately 7 in web workers in Firefox 8 through 18, and sometimes not\n// even then.\n\nfunction makeRequestCallFromTimer(callback) {\n    return function requestCall() {\n        // We dispatch a timeout with a specified delay of 0 for engines that\n        // can reliably accommodate that request. This will usually be snapped\n        // to a 4 milisecond delay, but once we're flushing, there's no delay\n        // between events.\n        var timeoutHandle = setTimeout(handleTimer, 0);\n        // However, since this timer gets frequently dropped in Firefox\n        // workers, we enlist an interval handle that will try to fire\n        // an event 20 times per second until it succeeds.\n        var intervalHandle = setInterval(handleTimer, 50);\n\n        function handleTimer() {\n            // Whichever timer succeeds will cancel both timers and\n            // execute the callback.\n            clearTimeout(timeoutHandle);\n            clearInterval(intervalHandle);\n            callback();\n        }\n    };\n}\n\n// This is for `asap.js` only.\n// Its name will be periodically randomized to break any code that depends on\n// its existence.\nrawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;\n\n// ASAP was originally a nextTick shim included in Q. This was factored out\n// into this ASAP package. It was later adapted to RSVP which made further\n// amendments. These decisions, particularly to marginalize MessageChannel and\n// to capture the MutationObserver implementation in a closure, were integrated\n// back into ASAP proper.\n// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /home/vagrant/~/asap/browser-raw.js\n ** module id = 202\n ** module chunks = 1\n **/","/*\n * Copyright 2015, Yahoo Inc.\n * Copyrights licensed under the New BSD License.\n * See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nmodule.exports = areIntlLocalesSupported;\n\nfunction areIntlLocalesSupported(locales) {\n    if (typeof Intl === 'undefined') {\n        return false;\n    }\n\n    if (!locales) {\n        throw new Error('locales must be supplied.');\n    }\n\n    if (!Array.isArray(locales)) {\n        locales = [locales];\n    }\n\n    var intlConstructors = [\n        Intl.Collator,\n        Intl.DateTimeFormat,\n        Intl.NumberFormat\n    ].filter(function (intlConstructor) {\n        return intlConstructor;\n    });\n\n    if (intlConstructors.length === 0) {\n        return false;\n    }\n\n    return intlConstructors.every(function (intlConstructor) {\n        var supportedLocales = intlConstructor.supportedLocalesOf(locales);\n        return supportedLocales.length === locales.length;\n    });\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /home/vagrant/~/intl-locales-supported/index.js\n ** module id = 261\n ** module chunks = 1\n **/","'use strict';\n\n//This file contains the ES6 extensions to the core Promises/A+ API\n\nvar Promise = require('./core.js');\n\nmodule.exports = Promise;\n\n/* Static Functions */\n\nvar TRUE = valuePromise(true);\nvar FALSE = valuePromise(false);\nvar NULL = valuePromise(null);\nvar UNDEFINED = valuePromise(undefined);\nvar ZERO = valuePromise(0);\nvar EMPTYSTRING = valuePromise('');\n\nfunction valuePromise(value) {\n  var p = new Promise(Promise._61);\n  p._81 = 1;\n  p._65 = value;\n  return p;\n}\nPromise.resolve = function (value) {\n  if (value instanceof Promise) return value;\n\n  if (value === null) return NULL;\n  if (value === undefined) return UNDEFINED;\n  if (value === true) return TRUE;\n  if (value === false) return FALSE;\n  if (value === 0) return ZERO;\n  if (value === '') return EMPTYSTRING;\n\n  if (typeof value === 'object' || typeof value === 'function') {\n    try {\n      var then = value.then;\n      if (typeof then === 'function') {\n        return new Promise(then.bind(value));\n      }\n    } catch (ex) {\n      return new Promise(function (resolve, reject) {\n        reject(ex);\n      });\n    }\n  }\n  return valuePromise(value);\n};\n\nPromise.all = function (arr) {\n  var args = Array.prototype.slice.call(arr);\n\n  return new Promise(function (resolve, reject) {\n    if (args.length === 0) return resolve([]);\n    var remaining = args.length;\n    function res(i, val) {\n      if (val && (typeof val === 'object' || typeof val === 'function')) {\n        if (val instanceof Promise && val.then === Promise.prototype.then) {\n          while (val._81 === 3) {\n            val = val._65;\n          }\n          if (val._81 === 1) return res(i, val._65);\n          if (val._81 === 2) reject(val._65);\n          val.then(function (val) {\n            res(i, val);\n          }, reject);\n          return;\n        } else {\n          var then = val.then;\n          if (typeof then === 'function') {\n            var p = new Promise(then.bind(val));\n            p.then(function (val) {\n              res(i, val);\n            }, reject);\n            return;\n          }\n        }\n      }\n      args[i] = val;\n      if (--remaining === 0) {\n        resolve(args);\n      }\n    }\n    for (var i = 0; i < args.length; i++) {\n      res(i, args[i]);\n    }\n  });\n};\n\nPromise.reject = function (value) {\n  return new Promise(function (resolve, reject) {\n    reject(value);\n  });\n};\n\nPromise.race = function (values) {\n  return new Promise(function (resolve, reject) {\n    values.forEach(function(value){\n      Promise.resolve(value).then(resolve, reject);\n    });\n  });\n};\n\n/* Prototype Methods */\n\nPromise.prototype['catch'] = function (onRejected) {\n  return this.then(null, onRejected);\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /home/vagrant/~/promise/lib/es6-extensions.js\n ** module id = 383\n ** module chunks = 1\n **/","'use strict';\n\nvar Promise = require('./core');\n\nvar DEFAULT_WHITELIST = [\n  ReferenceError,\n  TypeError,\n  RangeError\n];\n\nvar enabled = false;\nexports.disable = disable;\nfunction disable() {\n  enabled = false;\n  Promise._10 = null;\n  Promise._97 = null;\n}\n\nexports.enable = enable;\nfunction enable(options) {\n  options = options || {};\n  if (enabled) disable();\n  enabled = true;\n  var id = 0;\n  var displayId = 0;\n  var rejections = {};\n  Promise._10 = function (promise) {\n    if (\n      promise._81 === 2 && // IS REJECTED\n      rejections[promise._72]\n    ) {\n      if (rejections[promise._72].logged) {\n        onHandled(promise._72);\n      } else {\n        clearTimeout(rejections[promise._72].timeout);\n      }\n      delete rejections[promise._72];\n    }\n  };\n  Promise._97 = function (promise, err) {\n    if (promise._45 === 0) { // not yet handled\n      promise._72 = id++;\n      rejections[promise._72] = {\n        displayId: null,\n        error: err,\n        timeout: setTimeout(\n          onUnhandled.bind(null, promise._72),\n          // For reference errors and type errors, this almost always\n          // means the programmer made a mistake, so log them after just\n          // 100ms\n          // otherwise, wait 2 seconds to see if they get handled\n          matchWhitelist(err, DEFAULT_WHITELIST)\n            ? 100\n            : 2000\n        ),\n        logged: false\n      };\n    }\n  };\n  function onUnhandled(id) {\n    if (\n      options.allRejections ||\n      matchWhitelist(\n        rejections[id].error,\n        options.whitelist || DEFAULT_WHITELIST\n      )\n    ) {\n      rejections[id].displayId = displayId++;\n      if (options.onUnhandled) {\n        rejections[id].logged = true;\n        options.onUnhandled(\n          rejections[id].displayId,\n          rejections[id].error\n        );\n      } else {\n        rejections[id].logged = true;\n        logError(\n          rejections[id].displayId,\n          rejections[id].error\n        );\n      }\n    }\n  }\n  function onHandled(id) {\n    if (rejections[id].logged) {\n      if (options.onHandled) {\n        options.onHandled(rejections[id].displayId, rejections[id].error);\n      } else if (!rejections[id].onUnhandled) {\n        console.warn(\n          'Promise Rejection Handled (id: ' + rejections[id].displayId + '):'\n        );\n        console.warn(\n          '  This means you can ignore any previous messages of the form \"Possible Unhandled Promise Rejection\" with id ' +\n          rejections[id].displayId + '.'\n        );\n      }\n    }\n  }\n}\n\nfunction logError(id, error) {\n  console.warn('Possible Unhandled Promise Rejection (id: ' + id + '):');\n  var errStr = (error && (error.stack || error)) + '';\n  errStr.split('\\n').forEach(function (line) {\n    console.warn('  ' + line);\n  });\n}\n\nfunction matchWhitelist(error, list) {\n  return list.some(function (cls) {\n    return error instanceof cls;\n  });\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /home/vagrant/~/promise/lib/rejection-tracking.js\n ** module id = 384\n ** module chunks = 1\n **/","(function(self) {\n  'use strict';\n\n  if (self.fetch) {\n    return\n  }\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob: 'FileReader' in self && 'Blob' in self && (function() {\n      try {\n        new Blob()\n        return true\n      } catch(e) {\n        return false\n      }\n    })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name)\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value)\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift()\n        return {done: value === undefined, value: value}\n      }\n    }\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      }\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {}\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value)\n      }, this)\n\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name])\n      }, this)\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name)\n    value = normalizeValue(value)\n    var list = this.map[name]\n    if (!list) {\n      list = []\n      this.map[name] = list\n    }\n    list.push(value)\n  }\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)]\n  }\n\n  Headers.prototype.get = function(name) {\n    var values = this.map[normalizeName(name)]\n    return values ? values[0] : null\n  }\n\n  Headers.prototype.getAll = function(name) {\n    return this.map[normalizeName(name)] || []\n  }\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  }\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = [normalizeValue(value)]\n  }\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    Object.getOwnPropertyNames(this.map).forEach(function(name) {\n      this.map[name].forEach(function(value) {\n        callback.call(thisArg, value, name, this)\n      }, this)\n    }, this)\n  }\n\n  Headers.prototype.keys = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push(name) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.values = function() {\n    var items = []\n    this.forEach(function(value) { items.push(value) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.entries = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push([name, value]) })\n    return iteratorFor(items)\n  }\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result)\n      }\n      reader.onerror = function() {\n        reject(reader.error)\n      }\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader()\n    reader.readAsArrayBuffer(blob)\n    return fileReaderReady(reader)\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader()\n    reader.readAsText(blob)\n    return fileReaderReady(reader)\n  }\n\n  function Body() {\n    this.bodyUsed = false\n\n    this._initBody = function(body) {\n      this._bodyInit = body\n      if (typeof body === 'string') {\n        this._bodyText = body\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString()\n      } else if (!body) {\n        this._bodyText = ''\n      } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {\n        // Only support ArrayBuffers for POST method.\n        // Receiving ArrayBuffers happens via Blobs, instead.\n      } else {\n        throw new Error('unsupported BodyInit type')\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8')\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type)\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n        }\n      }\n    }\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      }\n\n      this.arrayBuffer = function() {\n        return this.blob().then(readBlobAsArrayBuffer)\n      }\n\n      this.text = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return readBlobAsText(this._bodyBlob)\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as text')\n        } else {\n          return Promise.resolve(this._bodyText)\n        }\n      }\n    } else {\n      this.text = function() {\n        var rejected = consumed(this)\n        return rejected ? rejected : Promise.resolve(this._bodyText)\n      }\n    }\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      }\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    }\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase()\n    return (methods.indexOf(upcased) > -1) ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {}\n    var body = options.body\n    if (Request.prototype.isPrototypeOf(input)) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url\n      this.credentials = input.credentials\n      if (!options.headers) {\n        this.headers = new Headers(input.headers)\n      }\n      this.method = input.method\n      this.mode = input.mode\n      if (!body) {\n        body = input._bodyInit\n        input.bodyUsed = true\n      }\n    } else {\n      this.url = input\n    }\n\n    this.credentials = options.credentials || this.credentials || 'omit'\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers)\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET')\n    this.mode = options.mode || this.mode || null\n    this.referrer = null\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body)\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this)\n  }\n\n  function decode(body) {\n    var form = new FormData()\n    body.trim().split('&').forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n    return form\n  }\n\n  function headers(xhr) {\n    var head = new Headers()\n    var pairs = (xhr.getAllResponseHeaders() || '').trim().split('\\n')\n    pairs.forEach(function(header) {\n      var split = header.trim().split(':')\n      var key = split.shift().trim()\n      var value = split.join(':').trim()\n      head.append(key, value)\n    })\n    return head\n  }\n\n  Body.call(Request.prototype)\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {}\n    }\n\n    this.type = 'default'\n    this.status = options.status\n    this.ok = this.status >= 200 && this.status < 300\n    this.statusText = options.statusText\n    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)\n    this.url = options.url || ''\n    this._initBody(bodyInit)\n  }\n\n  Body.call(Response.prototype)\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  }\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''})\n    response.type = 'error'\n    return response\n  }\n\n  var redirectStatuses = [301, 302, 303, 307, 308]\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  }\n\n  self.Headers = Headers\n  self.Request = Request\n  self.Response = Response\n\n  self.fetch = function(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request\n      if (Request.prototype.isPrototypeOf(input) && !init) {\n        request = input\n      } else {\n        request = new Request(input, init)\n      }\n\n      var xhr = new XMLHttpRequest()\n\n      function responseURL() {\n        if ('responseURL' in xhr) {\n          return xhr.responseURL\n        }\n\n        // Avoid security warnings on getResponseHeader when not allowed by CORS\n        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {\n          return xhr.getResponseHeader('X-Request-URL')\n        }\n\n        return\n      }\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: headers(xhr),\n          url: responseURL()\n        }\n        var body = 'response' in xhr ? xhr.response : xhr.responseText\n        resolve(new Response(body, options))\n      }\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.open(request.method, request.url, true)\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob'\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n    })\n  }\n  self.fetch.polyfill = true\n})(typeof self !== 'undefined' ? self : this);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /home/vagrant/~/whatwg-fetch/fetch.js\n ** module id = 481\n ** module chunks = 1\n **/"],"sourceRoot":""}